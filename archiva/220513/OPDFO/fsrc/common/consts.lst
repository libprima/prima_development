
 Lahey/Fujitsu Fortran 95 Compiler Release L8.10b  Sat Feb 12 17:36:58 2022
 Copyright (C) 1994-2008 Lahey Computer Systems.  All rights reserved.
 Copyright (C) 1998-2008 FUJITSU LIMITED. All rights reserved.

 Compilation information
   Current directory : /home/zaikunzhang/Bureau/neupdfo/fsrc/classical/uobyqa
   Source file       : ../../common/consts.F90
   Cpp options       : -Xs -Dunix -Dx86_64 -D__unix -D__x86_64 -D__ELF__ -D__x86_64__ -D__unix__ -D__linux__ -D__linux -Asystem(unix) -Asystem(posix) -Acpu(x86_64) -Amachine(x86_64) -Dlinux
   Compiler options  : --ap --nblock -c --chk aefosux --chkglobal --nco 
                     : --nconcc --dal --ndbl --nf95 --nfast -g --in --info 
                     : --ninline --li --lst --nlong --maxfatals 50 --nml 
                     : --nmldefault --o0 --no --nocl --nopenmp --nparallel 
                     : --nprefetch --npca --nprivate --nquad --quiet --sav 
                     : --nshared --sse2 --nstaticlink --nswm --nthreadheap 
                     : --nthreads --trace --ntrap --nunroll --nvarheap 
                     : --nvarstack --nversion --warn --nwide --nwisk --wo --zfm 
                     : --xref

 Module "consts_mod"
  (line-no.)(nest)
          1        #include "ppf.h"
          2        
          3        module consts_mod
          4        !--------------------------------------------------------------------------------------------------!
          5        ! This is a module defining some constants.
          6        !
          7        ! Coded by Zaikun ZHANG (www.zhangzk.net).
          8        !
          9        ! Started: July 2020
         10        !
         11        ! Last Modified: Thursday, February 03, 2022 PM09:15:10
         12        !--------------------------------------------------------------------------------------------------!
         13        
         14        !--------------------------------------------------------------------------------------------------!
         15        ! Remarks:
         16        !
         17        ! 1. REAL*4, REAL*8, INTEGER*4, INTEGER*8 are not Fortran standard expressions. Do not use them!
         18        !
         19        ! 2. Never use KIND with a literal value, e.g., REAL(KIND = 8), because Fortran standards never
         20        ! define what KIND = 8 means. There is NO guarantee that REAL(KIND = 8) will be legal, let alone
         21        ! being double precision.
         22        !
         23        ! 3. Fortran standard (as of F2003) specifies the following for types INTEGER and REAL.
         24        !
         25        !    - A processor shall provide ONE OR MORE representation methods that define sets of values for
         26        !    data of type integer; if the kind type parameter is not specified, the default kind value is
         27        !    KIND(0) and the type specified is DEFAULT INTEGER.
         28        !    - A processor shall provide TWO OR MORE approximation methods that define sets of values for
         29        !    data of type real; if the type keyword REAL is specified and the kind type parameter is not
         30        !    specified, the default kind value is KIND (0.0) and the type specified is DEFAULT REAL; If the
         31        !    type keyword DOUBLE PRECISION is specified, the kind value is KIND (0.0D0) and the type
         32        !    specified is DOUBLE PRECISION real; the decimal precision of the double precision real
         33        !    approximation method shall be greater than that of the default real method.
         34        !
         35        !    In other words, the standard only imposes that the following three types should be supported:
         36        !    - INTEGER(KIND(0)), i.e., default integer,
         37        !    - REAL(KIND(0.0)), i.e., default real (single-precision real),
         38        !    - REAL(KIND(0.0D0)), i.e., double-precision real.
         39        !
         40        !    Therefore, the following should be noted.
         41        !
         42        !    - Other types of INTEGER/REAL may not be available on all platforms (e.g., nvfortran 20 and
         43        !    flang 7.1.0 do not support REAL128).
         44        !    - The standard does not specify the range of the default integer.
         45        !    - The standard does not specify what the range and precision of the default real or the
         46        !    double-precision real, except that KIND(0.0D0) should have a greater precision than KIND(0.0)
         47        !    --- no requirement about the range.
         48        !
         49        !    Consequently, the following should be observed in all Fortran code.
         50        !
         51        !    - DO NOT use any kind parameter other than IK, IK_DFT, RP, RP_DFT, SP, or DP, unless you are
         52        !    sure that it is supported by your platform.
         53        !    - DO NOT make any assumption on the range of INTEGER, REAL, or REAL(0.0D0) unless you are sure.
         54        !    - Be cautious about OVERFLOW! In particular, for integers working as the lower/upper limit of
         55        !    arrays, overflow can lead to Segmentation Faults!
         56        !--------------------------------------------------------------------------------------------------!
         57        
         58        #if __USE_ISO_FORTRAN_ENV_INTREAL__ == 1
         59        
         60        #if __INTEGER_KIND__ == 16
         61        use, intrinsic :: iso_fortran_env, only : INT16
         62        #elif __INTEGER_KIND__ == 32
         63        use, intrinsic :: iso_fortran_env, only : INT32
         64        #elif __INTEGER_KIND__ == 64
         65        use, intrinsic :: iso_fortran_env, only : INT64
         66        #endif
         67        
         68        use, intrinsic :: iso_fortran_env, only : REAL32, REAL64, REAL128
         69        ! Unsupported kinds will be negative.
         70        
         71        ! Standard IO units
         72        use, intrinsic :: iso_fortran_env, only : STDIN => INPUT_UNIT, &
         73                                                & STDOUT => OUTPUT_UNIT, &
         74                                                & STDERR => ERROR_UNIT
         75        #endif
         76        
         77        implicit none
         78        private
         79        public :: DEBUGGING
         80        public :: IK, IK_DFT
         81        public :: RP, DP, SP, QP, RP_DFT
         82        public :: ZERO, ONE, TWO, HALF, QUART, TEN, TENTH, PI
         83        public :: REALMIN, EPS, HUGENUM, ALMOST_INFINITY, HUGEFUN, HUGECON
         84        public :: MSGLEN, FNAMELEN
         85        public :: OUTUNIT, STDIN, STDOUT, STDERR
         86        public :: RHOBEG_DFT, RHOEND_DFT, FTARGET_DFT, CTOL_DFT, CWEIGHT_DFT
         87        public :: ETA1_DFT, ETA2_DFT, GAMMA1_DFT, GAMMA2_DFT
         88        public :: MAXFUN_DIM_DFT, MAXMEMORY, MIN_MAXFILT, MAXFILT_DFT, IPRINT_DFT
         89        
         90        
         91        #if __DEBUGGING__ == 1
         92        logical, parameter :: DEBUGGING = .true.
         93        #else
         94        logical, parameter :: DEBUGGING = .false.
         95        #endif
         96        
         97        #if __USE_ISO_FORTRAN_ENV_INTREAL__ != 1
         98        ! For gfortran, SELECTED_REAL_KIND(K) returns INT16 with K = 3--4, INT32 with k = 5--9, and INT64
         99        ! with K = 10--18. SELECTED_REAL_KIND returns a negative value for an unsupported kind.
        100        #if __INTEGER_KIND__ == 16
        101        integer, parameter :: INT16 = selected_int_kind(4)
        102        #elif __INTEGER_KIND__ == 32
        103        integer, parameter :: INT32 = selected_int_kind(7)
        104        #elif __INTEGER_KIND__ == 64
        105        integer, parameter :: INT64 = selected_int_kind(14)
        106        #endif
        107        
        108        integer, parameter :: REAL32 = kind(0.0)
        109        integer, parameter :: REAL64 = kind(0.0D0)
        110        integer, parameter :: REAL128 = selected_real_kind(p=30)
        111        
        112        #endif
        113        integer, parameter :: IK_DFT = kind(0)  ! Default integer kind
        114        integer, parameter :: RP_DFT = kind(0.0)  ! Default real kind
        115        integer, parameter :: SP = REAL32  ! Kind for single precision
        116        integer, parameter :: DP = REAL64  ! Kind for double precision
        117        integer, parameter :: QP = REAL128  ! Kind for quadruple precision
        118        
        119        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        120        ! Define the integer kind to be used in the Fortran code.
        121        #if __INTEGER_KIND__  == 0
        122        integer, parameter :: IK = IK_DFT
        123        #elif __INTEGER_KIND__ == 16
        124        integer, parameter :: IK = INT16
        125        #elif __INTEGER_KIND__ == 32
        126        integer, parameter :: IK = INT32
        127        #elif __INTEGER_KIND__ == 64
        128        integer, parameter :: IK = INT64
        129        #else
        130        integer, parameter :: IK = IK_DFT
        131        #endif
        132        ! Define the real kind to be used in the Fortran code.
        133        #if __REAL_PRECISION__ == 0
        134        integer, parameter :: RP = RP_DFT
        135        #elif __REAL_PRECISION__ == 32
        136        integer, parameter :: RP = REAL32
        137        #elif __REAL_PRECISION__ == 64
        138        integer, parameter :: RP = REAL64
        139        #elif __REAL_PRECISION__ == 128
        140        integer, parameter :: RP = REAL128
        141        #else
        142        integer, parameter :: RP = REAL64  ! double precision
        143        #endif
        144        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        145        
        146        real(RP), parameter :: ZERO = 0.0_RP
        147        real(RP), parameter :: ONE = 1.0_RP
        148        real(RP), parameter :: TWO = 2.0_RP
        149        real(RP), parameter :: HALF = 0.5_RP
        150        real(RP), parameter :: QUART = 0.25_RP
        151        real(RP), parameter :: TEN = 10.0_RP
        152        real(RP), parameter :: TENTH = 0.1_RP
        153        real(RP), parameter :: PI = 3.141592653589793238462643383279502884_RP
        154        ! We may set PI to acos(-1.0_RP), but some compilers may complain about `Elemental function as
        155        ! initialization expression with non-integer or non-character arguments`.
        156        
        157        ! REALMIN is the smallest positive normalized floating-point number, which is 2^(-1022), ~2.225E-308
        158        ! for IEEE double precision. Taking double precision as an example, REALMIN in other languages:
        159        ! MATLAB: realmin or realmin('double')
        160        ! Python: numpy.finfo(numpy.float64).tiny
        161        ! Julia: realmin(Float64)
        162        real(RP), parameter :: REALMIN = tiny(ZERO)
        163        real(RP), parameter :: EPS = epsilon(ZERO)  ! Machine epsilon
        164        real(RP), parameter :: HUGENUM = huge(ZERO)
        165        real(RP), parameter :: ALMOST_INFINITY = HALF * HUGENUM
        166        
        167        integer, parameter :: MAXE = maxexponent(ZERO)
        168        real(RP), parameter :: HUGEFUN = TWO**min(100, MAXE / 2)
        169        real(RP), parameter :: HUGECON = HUGEFUN
        170        
        171        ! The maximal length of messages; used in output.f90 and fmexapi.F90
        172        integer, parameter :: MSGLEN = 1000
        173        
        174        ! The maximal length of output file names; used in output.f90
        175        integer, parameter :: FNAMELEN = 1000
        176        ! Output unit, can be any integer between 9 and 99; used in output.f90
        177        integer, parameter :: OUTUNIT = 42
        178        ! Standard IO units
        179        #if __USE_ISO_FORTRAN_ENV_INTREAL__ != 1
        180        integer, parameter :: STDIN = 5
        181        integer, parameter :: STDOUT = 6
        182        integer, parameter :: STDERR = 0
        183        #endif
        184        
        185        ! Some default values
        186        real(RP), parameter :: RHOBEG_DFT = ONE
        187        real(RP), parameter :: RHOEND_DFT = 1.0E-6_RP
        188        real(RP), parameter :: FTARGET_DFT = -HUGENUM
        189        real(RP), parameter :: CTOL_DFT = EPS
        190        real(RP), parameter :: CWEIGHT_DFT = 1.0E8_RP
        191        real(RP), parameter :: ETA1_DFT = TENTH
        192        real(RP), parameter :: ETA2_DFT = 0.7_RP
        193        real(RP), parameter :: GAMMA1_DFT = HALF
        194        real(RP), parameter :: GAMMA2_DFT = TWO
        195        integer(IK), parameter :: IPRINT_DFT = 0_IK
        196        integer(IK), parameter :: MAXFUN_DIM_DFT = 500_IK
        197        
        198        ! Maximal amount of memory (Byte) allowed for XHIST, FHIST, CONHIST, CHIST, and the filters.
        199        integer, parameter :: MXMMY = 21 * (10**8)   ! 21*10**8 = 2G.
        200        ! Make sure that MAXMEMORY does not exceed HUGE(0) to avoid overflow and memory errors.
        201        integer, parameter :: MAXMEMORY = min(MXMMY, huge(0))
        202        
        203        ! Maximal length of the filter used in constrained solvers.
        204        integer(IK), parameter :: MIN_MAXFILT = 200_IK  ! Should be positive; < 200 is not recommended.
        205        integer(IK), parameter :: MAXFILT_DFT = 10_IK * MIN_MAXFILT
        206        
        207        end module consts_mod

 Procedure information
   Lines      : 475
   Statements : 61

 Scoping unit of module : consts_mod
   Attribute and Cross reference of name
     ALMOST_INFINITY
      |(Class and Type) : named constant, REAL(8)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 83  165
      |(Definition)     : 
      |(Reference)      : 
     CTOL_DFT
      |(Class and Type) : named constant, REAL(8)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 86  189
      |(Definition)     : 
      |(Reference)      : 
     CWEIGHT_DFT
      |(Class and Type) : named constant, REAL(8)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 86  190
      |(Definition)     : 
      |(Reference)      : 
     consts_mod
      |(Class and Type) : module name
      |(Attributes)     : PRIVATE
      |(Declaration)    : 3
      |(Definition)     : 
      |(Reference)      : 207
     DEBUGGING
      |(Class and Type) : named constant, LOGICAL(4)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 79  92
      |(Definition)     : 
      |(Reference)      : 
     DP
      |(Class and Type) : named constant, INTEGER(4)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 81  116
      |(Definition)     : 
      |(Reference)      : 
     EPS
      |(Class and Type) : named constant, REAL(8)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 83  163
      |(Definition)     : 
      |(Reference)      : 189
     ETA1_DFT
      |(Class and Type) : named constant, REAL(8)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 87  191
      |(Definition)     : 
      |(Reference)      : 
     ETA2_DFT
      |(Class and Type) : named constant, REAL(8)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 87  192
      |(Definition)     : 
      |(Reference)      : 
     epsilon
      |(Class and Type) : intrinsic function name, none
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 
      |(Reference)      : 163
     FNAMELEN
      |(Class and Type) : named constant, INTEGER(4)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 84  175
      |(Definition)     : 
      |(Reference)      : 
     FTARGET_DFT
      |(Class and Type) : named constant, REAL(8)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 86  188
      |(Definition)     : 
      |(Reference)      : 
     GAMMA1_DFT
      |(Class and Type) : named constant, REAL(8)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 87  193
      |(Definition)     : 
      |(Reference)      : 
     GAMMA2_DFT
      |(Class and Type) : named constant, REAL(8)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 87  194
      |(Definition)     : 
      |(Reference)      : 
     HALF
      |(Class and Type) : named constant, REAL(8)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 82  149
      |(Definition)     : 
      |(Reference)      : 165  193
     HUGECON
      |(Class and Type) : named constant, REAL(8)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 83  169
      |(Definition)     : 
      |(Reference)      : 
     HUGEFUN
      |(Class and Type) : named constant, REAL(8)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 83  168
      |(Definition)     : 
      |(Reference)      : 169
     HUGENUM
      |(Class and Type) : named constant, REAL(8)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 83  164
      |(Definition)     : 
      |(Reference)      : 165  188
     huge
      |(Class and Type) : intrinsic function name, none
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 
      |(Reference)      : 164  201
     IK
      |(Class and Type) : named constant, INTEGER(4)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 80  122
      |(Definition)     : 
      |(Reference)      : 195  195  196  196  204  204  205  205
     IK_DFT
      |(Class and Type) : named constant, INTEGER(4)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 80  113
      |(Definition)     : 
      |(Reference)      : 122
     IPRINT_DFT
      |(Class and Type) : named constant, INTEGER(4)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 88  195
      |(Definition)     : 
      |(Reference)      : 
     kind
      |(Class and Type) : intrinsic function name, none
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 
      |(Reference)      : 108  109  113  114
     MAXE
      |(Class and Type) : named constant, INTEGER(4)
      |(Attributes)     : PRIVATE
      |(Declaration)    : 167
      |(Definition)     : 
      |(Reference)      : 168
     MAXFILT_DFT
      |(Class and Type) : named constant, INTEGER(4)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 88  205
      |(Definition)     : 
      |(Reference)      : 
     MAXFUN_DIM_DFT
      |(Class and Type) : named constant, INTEGER(4)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 88  196
      |(Definition)     : 
      |(Reference)      : 
     MAXMEMORY
      |(Class and Type) : named constant, INTEGER(4)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 88  201
      |(Definition)     : 
      |(Reference)      : 
     MIN_MAXFILT
      |(Class and Type) : named constant, INTEGER(4)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 88  204
      |(Definition)     : 
      |(Reference)      : 205
     MSGLEN
      |(Class and Type) : named constant, INTEGER(4)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 84  172
      |(Definition)     : 
      |(Reference)      : 
     MXMMY
      |(Class and Type) : named constant, INTEGER(4)
      |(Attributes)     : PRIVATE
      |(Declaration)    : 199
      |(Definition)     : 
      |(Reference)      : 201
     maxexponent
      |(Class and Type) : intrinsic function name, none
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 
      |(Reference)      : 167
     min
      |(Class and Type) : intrinsic function name, none
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 
      |(Reference)      : 168  201
     ONE
      |(Class and Type) : named constant, REAL(8)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 82  147
      |(Definition)     : 
      |(Reference)      : 186
     OUTUNIT
      |(Class and Type) : named constant, INTEGER(4)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 85  177
      |(Definition)     : 
      |(Reference)      : 
     PI
      |(Class and Type) : named constant, REAL(8)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 82  153
      |(Definition)     : 
      |(Reference)      : 
     p
      |(Class and Type) : keyword argument name
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 
      |(Reference)      : 110
     QP
      |(Class and Type) : named constant, INTEGER(4)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 81  117
      |(Definition)     : 
      |(Reference)      : 
     QUART
      |(Class and Type) : named constant, REAL(8)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 82  150
      |(Definition)     : 
      |(Reference)      : 
     REAL128
      |(Class and Type) : named constant, INTEGER(4)
      |(Attributes)     : PRIVATE
      |(Declaration)    : 110
      |(Definition)     : 
      |(Reference)      : 117
     REAL32
      |(Class and Type) : named constant, INTEGER(4)
      |(Attributes)     : PRIVATE
      |(Declaration)    : 108
      |(Definition)     : 
      |(Reference)      : 115
     REAL64
      |(Class and Type) : named constant, INTEGER(4)
      |(Attributes)     : PRIVATE
      |(Declaration)    : 109
      |(Definition)     : 
      |(Reference)      : 116  138
     REALMIN
      |(Class and Type) : named constant, REAL(8)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 83  162
      |(Definition)     : 
      |(Reference)      : 
     RHOBEG_DFT
      |(Class and Type) : named constant, REAL(8)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 86  186
      |(Definition)     : 
      |(Reference)      : 
     RHOEND_DFT
      |(Class and Type) : named constant, REAL(8)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 86  187
      |(Definition)     : 
      |(Reference)      : 
     RP
      |(Class and Type) : named constant, INTEGER(4)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 81  138
      |(Definition)     : 
      |(Reference)      : 146  146  147  147  148  148  149  149  150  150  151  151  152  152  153  153  162  163  164  165  168  169  186  187  187  188  189  190  190  191  192  192  193  194
     RP_DFT
      |(Class and Type) : named constant, INTEGER(4)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 81  114
      |(Definition)     : 
      |(Reference)      : 
     SP
      |(Class and Type) : named constant, INTEGER(4)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 81  115
      |(Definition)     : 
      |(Reference)      : 
     STDERR
      |(Class and Type) : named constant, INTEGER(4)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 85  182
      |(Definition)     : 
      |(Reference)      : 
     STDIN
      |(Class and Type) : named constant, INTEGER(4)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 85  180
      |(Definition)     : 
      |(Reference)      : 
     STDOUT
      |(Class and Type) : named constant, INTEGER(4)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 85  181
      |(Definition)     : 
      |(Reference)      : 
     selected_real_kind
      |(Class and Type) : intrinsic function name, none
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 
      |(Reference)      : 110
     TEN
      |(Class and Type) : named constant, REAL(8)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 82  151
      |(Definition)     : 
      |(Reference)      : 
     TENTH
      |(Class and Type) : named constant, REAL(8)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 82  152
      |(Definition)     : 
      |(Reference)      : 191
     TWO
      |(Class and Type) : named constant, REAL(8)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 82  148
      |(Definition)     : 
      |(Reference)      : 168  194
     tiny
      |(Class and Type) : intrinsic function name, none
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 
      |(Reference)      : 162
     ZERO
      |(Class and Type) : named constant, REAL(8)
      |(Attributes)     : PUBLIC
      |(Declaration)    : 82  146
      |(Definition)     : 
      |(Reference)      : 162  163  164  167

 Total information
   Procedures       : 1
   Total lines      : 475
   Total statements : 61


 Lahey/Fujitsu Fortran 95 Compiler Release L8.10b  Sat Feb 12 17:36:58 2022
 Copyright (C) 1994-2008 Lahey Computer Systems.  All rights reserved.
 Copyright (C) 1998-2008 FUJITSU LIMITED. All rights reserved.

 Compilation information
   Current directory : /home/zaikunzhang/Bureau/neupdfo/fsrc/classical/uobyqa
   Source file       : ../../common/debug.F90
   Cpp options       : -Xs -Dunix -Dx86_64 -D__unix -D__x86_64 -D__ELF__ -D__x86_64__ -D__unix__ -D__linux__ -D__linux -Asystem(unix) -Asystem(posix) -Acpu(x86_64) -Amachine(x86_64) -Dlinux
   Compiler options  : --ap --nblock -c --chk aefosux --chkglobal --nco 
                     : --nconcc --dal --ndbl --nf95 --nfast -g --in --info 
                     : --ninline --li --lst --nlong --maxfatals 50 --nml 
                     : --nmldefault --o0 --no --nocl --nopenmp --nparallel 
                     : --nprefetch --npca --nprivate --nquad --quiet --sav 
                     : --nshared --sse2 --nstaticlink --nswm --nthreadheap 
                     : --nthreads --trace --ntrap --nunroll --nvarheap 
                     : --nvarstack --nversion --warn --nwide --nwisk --wo --zfm 
                     : --xref

 Module "debug_mod"
  (line-no.)(nest)
          1        #include "ppf.h"
          2        
          3        module debug_mod
          4        !--------------------------------------------------------------------------------------------------!
          5        ! This is a module defining some procedures concerning debugging, errors, and warnings.
          6        !
          7        ! Coded by Zaikun ZHANG (www.zhangzk.net).
          8        !
          9        ! Started: July 2020.
         10        !
         11        ! Last Modified: Saturday, January 22, 2022 PM07:48:54
         12        !--------------------------------------------------------------------------------------------------!
         13        implicit none
         14        private
         15        public :: assert, validate, backtr, warning, errstop, verisize
         16        
         17        interface verisize
         18            module procedure verisize_real_1, verisize_real_2
         19            module procedure verisize_int_1, verisize_int_2
         20            module procedure verisize_logical_1, verisize_logical_2
         21        end interface verisize
         22        
         23        
         24        contains
         25        
         26        
         27        subroutine assert(condition, description, srname)
         28        !--------------------------------------------------------------------------------------------------!
         29        ! This subroutine checks whether ASSERTION is true.
         30        ! If no, print SRNAME // 'Assertion failed: ' // DESCRIPTION
         31        ! to STDERR and then stop the program by calling ERRSTOP.
         32        ! MATLAB analogue: assert(condition, sprintf('%s: Assertion failed: %s', srname, description))
         33        ! Python analogue: assert condition, srname + ': Assertion failed: ' + description
         34        ! C analogue: assert(condition)  /* An error message will be produced by the compiler */
         35        !--------------------------------------------------------------------------------------------------!
         36        !! N.B.: As in C, we design ASSERT to operate only in the debug mode, i.e., when __DEBUGGING__ == 1;
         37        !! when __DEBUGGING__ == 0, ASSERT does nothing. For the checking that should take effect in both
         38        !! the debug and release modes, use VALIDATE (see below) instead. In the optimized mode of Python
         39        !! (python -O), the Python `assert` will also be ignored. MATLAB does not behave in this way.
         40        !--------------------------------------------------------------------------------------------------!
         41        use, non_intrinsic :: consts_mod, only : DEBUGGING
         42        implicit none
         43        logical, intent(in) :: condition  ! A condition that is expected to be true
         44        character(len=*), intent(in) :: description  ! Description of the condition in human language
         45        character(len=*), intent(in) :: srname  ! Name of the subroutine that calls this procedure
         46     1  if (DEBUGGING) then
         47     2      if (.not. condition) then
         48     2          call errstop(trim(srname), 'Assertion failed: '//trim(description))
         49     2      end if
         50     1  end if
         51        end subroutine assert
         52        
         53        
         54        subroutine validate(condition, description, srname)
         55        !--------------------------------------------------------------------------------------------------!
         56        ! This subroutine checks whether CONDITION is true.
         57        ! If no, print SRNAME // 'Validation failed: ' // DESCRIPTION
         58        ! to STDERR and then stop the program by calling ERRSTOP.
         59        ! MATLAB analogue: assert(condition, sprintf('%s: Validation failed: %s', srname, description))
         60        ! In Python or C, VALIDATE can be implemented following the Fortran implementation below.
         61        !--------------------------------------------------------------------------------------------------!
         62        implicit none
         63        logical, intent(in) :: condition  ! A condition that is expected to be true
         64        character(len=*), intent(in) :: description  ! Description of the condition in human language
         65        character(len=*), intent(in) :: srname  ! Name of the subroutine that calls this procedure
         66     1  if (.not. condition) then
         67     1      call errstop(trim(srname), 'Validation failed: '//trim(description))
         68     1  end if
         69        end subroutine validate
         70        
         71        
         72        subroutine errstop(srname, msg)
         73        !--------------------------------------------------------------------------------------------------!
         74        ! This subroutine prints 'ERROR: '//TRIM(SRNAME)//': '//TRIM(MSG)//'!' to STDERR, then stop. In the
         75        ! debug mode, it also calls BACKTR to print the backtrace.
         76        !--------------------------------------------------------------------------------------------------!
         77        use, non_intrinsic :: consts_mod, only : STDERR, DEBUGGING
         78        implicit none
         79        character(len=*), intent(in) :: srname
         80        character(len=*), intent(in) :: msg
         81        
         82     1  if (DEBUGGING) then
         83     1      call backtr()
         84     1  end if
         85        
         86        write (STDERR, '(/1A/)') 'ERROR: '//trim(srname)//': '//trim(msg)//'!'
         87        stop  ! This means to stop the whole program.
         88        end subroutine errstop
         89        
         90        
         91        subroutine backtr
         92        !--------------------------------------------------------------------------------------------------!
         93        ! This subroutine calls a compiler-dependent intrinsic to show a backtrace if we are in the debuge
         94        ! mode, i.e., __DEBUGGING__ == 1.
         95        ! N.B.:
         96        ! 1. The intrinsic is compiler-dependent and does not exist in all compilers. Indeed, it is not
         97        ! standard-conforming. Therefore, compilers may warn that a non-standard intrinsic is in use.
         98        ! 2. More seriously, if the compiler is instructed to conform to the standards (e.g., gfortran with
         99        ! the option -std=f2003) while __DEBUGGING__ is set to 1, then the compilation may FAIL when linking,
        100        ! complaining that a subroutine cannot be found (e.g., backtrace for gfortran). In that case, we
        101        ! must set __DEBUGGING__ to 0 in ppf.h.
        102        !--------------------------------------------------------------------------------------------------!
        103        #if __DEBUGGING__ == 1
        104        
        105        #if defined __GFORTRAN__
        106        implicit none
        107        call backtrace
        108        #elif defined __INTEL_COMPILER
        109        use, non_intrinsic :: ifcore, only : tracebackqq
        110        implicit none
        111        call tracebackqq(user_exit_code=-1)
        112        ! According to "Intel Fortran Compiler 19.1 Developer Guide and Reference", item "TRACEBACKQQ":
        113        ! By specifying a user exit code of -1, control returns to the calling program. Specifying a user
        114        ! exit code with a positive value requests that specified value be returned to the operating system.
        115        ! The default value is 0, which causes the application to abort execution.
        116        #endif
        117        
        118        #endif
        119        end subroutine backtr
        120        
        121        
        122        subroutine warning(srname, msg)
        123        !--------------------------------------------------------------------------------------------------!
        124        ! This subroutine prints 'Warning: '//TRIM(SRNAME)//': '//TRIM(MSG)//'.' to STDERR.
        125        !--------------------------------------------------------------------------------------------------!
        126        use, non_intrinsic :: consts_mod, only : STDERR
        127        implicit none
        128        character(len=*), intent(in) :: srname
        129        character(len=*), intent(in) :: msg
        130        
        131        write (STDERR, '(/1A/)') 'Warning: '//trim(srname)//': '//trim(msg)//'.'
        132        end subroutine warning
        133        
        134        
        135        subroutine verisize_real_1(x, n)
        136        !--------------------------------------------------------------------------------------------------!
        137        ! VERISIZE_REAL_1 verifies whether SIZE(X) = N.
        138        !--------------------------------------------------------------------------------------------------!
        139        use, non_intrinsic :: consts_mod, only : RP, IK
        140        implicit none
        141        real(RP), intent(in) :: x(:)
        142        integer(IK), intent(in) :: n
        143        
        144        character(len=*), parameter :: srname = 'VERISIZE_REAL_1'
        145        
        146     1  if (int(size(x), IK) /= n) then
        147     1      call errstop(srname, 'SIZE(X) /= N')
        148     1  end if
        149        end subroutine verisize_real_1
        150        
        151        
        152        subroutine verisize_real_2(x, m, n)
        153        !--------------------------------------------------------------------------------------------------!
        154        ! VERISIZE_REAL_2 verifies whether SIZE(X, 1) = M, SIZE(X, 2) = N.
        155        !--------------------------------------------------------------------------------------------------!
        156        use, non_intrinsic :: consts_mod, only : RP, IK
        157        implicit none
        158        real(RP), intent(in) :: x(:, :)
        159        integer(IK), intent(in) :: m
        160        integer(IK), intent(in) :: n
        161        
        162        character(len=*), parameter :: srname = 'VERISIZE_REAL_2'
        163        
        164     1  if (int(size(x, 1), IK) /= m) then
        165     1      call errstop(srname, 'SIZE(X, 1) /= M')
        166     1  end if
        167     1  if (int(size(x, 2), IK) /= n) then
        168     1      call errstop(srname, 'SIZE(X, 2) /= N')
        169     1  end if
        170        end subroutine verisize_real_2
        171        
        172        
        173        subroutine verisize_int_1(x, n)
        174        !--------------------------------------------------------------------------------------------------!
        175        ! VERISIZE_INT_1 verifies whether SIZE(X) = N.
        176        !--------------------------------------------------------------------------------------------------!
        177        use, non_intrinsic :: consts_mod, only : IK
        178        implicit none
        179        integer(IK), intent(in) :: x(:)
        180        integer(IK), intent(in) :: n
        181        
        182        character(len=*), parameter :: srname = 'VERISIZE_INT_1'
        183        
        184     1  if (int(size(x), IK) /= n) then
        185     1      call errstop(srname, 'SIZE(X) /= N')
        186     1  end if
        187        end subroutine verisize_int_1
        188        
        189        
        190        subroutine verisize_int_2(x, m, n)
        191        !--------------------------------------------------------------------------------------------------!
        192        ! VERISIZE_INT_2 verifies whether SIZE(X, 1) = M, SIZE(X, 2) = N.
        193        !--------------------------------------------------------------------------------------------------!
        194        use, non_intrinsic :: consts_mod, only : IK
        195        implicit none
        196        integer(IK), intent(in) :: x(:, :)
        197        integer(IK), intent(in) :: m
        198        integer(IK), intent(in) :: n
        199        
        200        character(len=*), parameter :: srname = 'VERISIZE_INT_2'
        201        
        202     1  if (int(size(x, 1), IK) /= m) then
        203     1      call errstop(srname, 'SIZE(X, 1) /= M')
        204     1  end if
        205     1  if (int(size(x, 2), IK) /= n) then
        206     1      call errstop(srname, 'SIZE(X, 2) /= N')
        207     1  end if
        208        end subroutine verisize_int_2
        209        
        210        
        211        subroutine verisize_logical_1(x, n)
        212        !--------------------------------------------------------------------------------------------------!
        213        ! VERISIZE_LOGICAL_1 verifies whether SIZE(X) = N.
        214        !--------------------------------------------------------------------------------------------------!
        215        use, non_intrinsic :: consts_mod, only : IK
        216        implicit none
        217        logical, intent(in) :: x(:)
        218        integer(IK), intent(in) :: n
        219        
        220        character(len=*), parameter :: srname = 'VERISIZE_LOGICAL_1'
        221        
        222     1  if (int(size(x), IK) /= n) then
        223     1      call errstop(srname, 'SIZE(X) /= N')
        224     1  end if
        225        end subroutine verisize_logical_1
        226        
        227        
        228        subroutine verisize_logical_2(x, m, n)
        229        !--------------------------------------------------------------------------------------------------!
        230        ! VERISIZE_LOGICAL_2 verifies whether SIZE(X, 1) = M, SIZE(X, 2) = N.
        231        !--------------------------------------------------------------------------------------------------!
        232        use, non_intrinsic :: consts_mod, only : IK
        233        implicit none
        234        logical, intent(in) :: x(:, :)
        235        integer(IK), intent(in) :: m
        236        integer(IK), intent(in) :: n
        237        
        238        character(len=*), parameter :: srname = 'VERISIZE_LOGICAL_2'
        239        
        240     1  if (int(size(x, 1), IK) /= m) then
        241     1      call errstop(srname, 'SIZE(X, 1) /= M')
        242     1  end if
        243     1  if (int(size(x, 2), IK) /= n) then
        244     1      call errstop(srname, 'SIZE(X, 2) /= N')
        245     1  end if
        246        end subroutine verisize_logical_2
        247        
        248        
        249        end module debug_mod

 Diagnostic messages: program name(debug_mod)
  Module subprogram name(assert)
   1333-S: "../../common/debug.F90", line 41, column 4: Name expected.
   2018-S: "../../common/debug.F90", line 46: When IMPLICIT NONE is specified, 'DEBUGGING' must be declared in a type declaration statement.
  Module subprogram name(errstop)
   1333-S: "../../common/debug.F90", line 77, column 4: Name expected.
   2018-S: "../../common/debug.F90", line 82: When IMPLICIT NONE is specified, 'DEBUGGING' must be declared in a type declaration statement.
   2018-S: "../../common/debug.F90", line 86: When IMPLICIT NONE is specified, 'STDERR' must be declared in a type declaration statement.
  Module subprogram name(warning)
   1333-S: "../../common/debug.F90", line 126, column 4: Name expected.
   2018-S: "../../common/debug.F90", line 131: When IMPLICIT NONE is specified, 'STDERR' must be declared in a type declaration statement.
  Module subprogram name(verisize_real_1)
   2018-S: "../../common/debug.F90", line 135: When IMPLICIT NONE is specified, 'n' must be declared in a type declaration statement.
   2018-S: "../../common/debug.F90", line 135: When IMPLICIT NONE is specified, 'x' must be declared in a type declaration statement.
   1333-S: "../../common/debug.F90", line 139, column 4: Name expected.
   1185-S: "../../common/debug.F90", line 141: In an initialization or specification expression, 'RP' must be a named constant.
   2018-S: "../../common/debug.F90", line 141: When IMPLICIT NONE is specified, 'RP' must be declared in a type declaration statement.
   1326-S: "../../common/debug.F90", line 141, column 6: Type specification or length specification invalid.
   1185-S: "../../common/debug.F90", line 142: In an initialization or specification expression, 'IK' must be a named constant.
   2018-S: "../../common/debug.F90", line 142: When IMPLICIT NONE is specified, 'IK' must be declared in a type declaration statement.
   1326-S: "../../common/debug.F90", line 142, column 9: Type specification or length specification invalid.
  Module subprogram name(verisize_real_2)
   2018-S: "../../common/debug.F90", line 152: When IMPLICIT NONE is specified, 'n' must be declared in a type declaration statement.
   2018-S: "../../common/debug.F90", line 152: When IMPLICIT NONE is specified, 'm' must be declared in a type declaration statement.
   2018-S: "../../common/debug.F90", line 152: When IMPLICIT NONE is specified, 'x' must be declared in a type declaration statement.
   1333-S: "../../common/debug.F90", line 156, column 4: Name expected.
   1185-S: "../../common/debug.F90", line 158: In an initialization or specification expression, 'RP' must be a named constant.
   2018-S: "../../common/debug.F90", line 158: When IMPLICIT NONE is specified, 'RP' must be declared in a type declaration statement.
   1326-S: "../../common/debug.F90", line 158, column 6: Type specification or length specification invalid.
   1185-S: "../../common/debug.F90", line 159: In an initialization or specification expression, 'IK' must be a named constant.
   2018-S: "../../common/debug.F90", line 159: When IMPLICIT NONE is specified, 'IK' must be declared in a type declaration statement.
   1326-S: "../../common/debug.F90", line 159, column 9: Type specification or length specification invalid.
   1185-S: "../../common/debug.F90", line 160: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/debug.F90", line 160, column 9: Type specification or length specification invalid.
  Module subprogram name(verisize_int_1)
   2018-S: "../../common/debug.F90", line 173: When IMPLICIT NONE is specified, 'n' must be declared in a type declaration statement.
   1333-S: "../../common/debug.F90", line 177, column 4: Name expected.
   1185-S: "../../common/debug.F90", line 179: In an initialization or specification expression, 'IK' must be a named constant.
   2018-S: "../../common/debug.F90", line 179: When IMPLICIT NONE is specified, 'IK' must be declared in a type declaration statement.
   1326-S: "../../common/debug.F90", line 179, column 9: Type specification or length specification invalid.
   1185-S: "../../common/debug.F90", line 180: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/debug.F90", line 180, column 9: Type specification or length specification invalid.
  Module subprogram name(verisize_int_2)
   1333-S: "../../common/debug.F90", line 194, column 4: Name expected.
   1185-S: "../../common/debug.F90", line 196: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/debug.F90", line 196, column 9: Type specification or length specification invalid.
   1185-S: "../../common/debug.F90", line 197: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/debug.F90", line 197, column 9: Type specification or length specification invalid.
   1185-S: "../../common/debug.F90", line 198: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/debug.F90", line 198, column 9: Type specification or length specification invalid.
  Module subprogram name(verisize_logical_1)
   1333-S: "../../common/debug.F90", line 215, column 4: Name expected.
   1185-S: "../../common/debug.F90", line 218: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/debug.F90", line 218, column 9: Type specification or length specification invalid.
  Module subprogram name(verisize_logical_2)
   1333-S: "../../common/debug.F90", line 232, column 4: Name expected.
   1185-S: "../../common/debug.F90", line 235: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/debug.F90", line 235, column 9: Type specification or length specification invalid.
   1185-S: "../../common/debug.F90", line 236: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/debug.F90", line 236, column 9: Type specification or length specification invalid.

 Procedure information
   Lines      : 517
   Statements : 124

 Total information
   Procedures       : 1
   Total lines      : 517
   Total statements : 124


 Lahey/Fujitsu Fortran 95 Compiler Release L8.10b  Sat Feb 12 17:36:58 2022
 Copyright (C) 1994-2008 Lahey Computer Systems.  All rights reserved.
 Copyright (C) 1998-2008 FUJITSU LIMITED. All rights reserved.

 Compilation information
   Current directory : /home/zaikunzhang/Bureau/neupdfo/fsrc/classical/uobyqa
   Source file       : ../../common/infnan.F90
   Cpp options       : -Xs -Dunix -Dx86_64 -D__unix -D__x86_64 -D__ELF__ -D__x86_64__ -D__unix__ -D__linux__ -D__linux -Asystem(unix) -Asystem(posix) -Acpu(x86_64) -Amachine(x86_64) -Dlinux
   Compiler options  : --ap --nblock -c --chk aefosux --chkglobal --nco 
                     : --nconcc --dal --ndbl --nf95 --nfast -g --in --info 
                     : --ninline --li --lst --nlong --maxfatals 50 --nml 
                     : --nmldefault --o0 --no --nocl --nopenmp --nparallel 
                     : --nprefetch --npca --nprivate --nquad --quiet --sav 
                     : --nshared --sse2 --nstaticlink --nswm --nthreadheap 
                     : --nthreads --trace --ntrap --nunroll --nvarheap 
                     : --nvarstack --nversion --warn --nwide --nwisk --wo --zfm 
                     : --xref

 Module "infnan_mod"
  (line-no.)(nest)
          1        #include "ppf.h"
          2        
          3        module infnan_mod
          4        !--------------------------------------------------------------------------------------------------!
          5        ! This module provides functions that check whether a real number x is infinite, NaN, or finite.
          6        !
          7        ! N.B.:
          8        !
          9        ! 1. We implement all the procedures for single, double, and quadruple precisions (when available).
         10        ! When we interface the Fortran code with other languages (e.g., MATLAB), the procedures may be
         11        ! invoked in both the Fortran code and the gateway (e.g., MEX gateway), which may use different real
         12        ! precisions (e.g., the Fortran code may use single, but the MEX gateway uses double by default).
         13        !
         14        ! 2. We decide not to use IEEE_IS_NAN and IEEE_IS_FINITE provided by the intrinsic IEEE_ARITHMETIC
         15        ! available since Fortran 2003. The reason is as follows. These two procedures are supposed to
         16        ! return default logical values. However, if the code is compiled by gfortran 9.3.0 with the option
         17        ! -fdefault-integer-8 (which is adopted by MEX as the default), then compiler will enforce the
         18        ! default logical value to be 64-bit, but the returned kinds of IEEE_IS_NAN and IEEE_IS_FINITE will
         19        ! not be changed accordingly, and they will remain 32-bit if that is the default logical kind
         20        ! without -fdefault-integer-8. Consequently, the returned kinds of IEEE_IS_NAN and IEEE_IS_FINITE
         21        ! may actually differ from the default logical kind due to this compiler option and hence violate
         22        ! the Fortran standard! This is fatal, because a ! piece of perfectly standard-compliant may fail to
         23        ! be compiled due to type mismatches. It is similar with ifort 2021.2.0 and nagfor 7.0. See the
         24        ! following address for more discussions: https://stackoverflow.com/questions/69060408 .
         25        !
         26        ! 3. The functions aim to work even when compilers are invoked with aggressive optimization flags,
         27        ! such as `gfortran -Ofast`.
         28        !
         29        ! 4. There are many ways to implement functions like IS_NAN. However, not all of them work with
         30        ! aggressive optimization flags. For example, for gfortran 9.3.0, the IEEE_IS_NAN included in
         31        ! IEEE_ARITHMETIC does not work with `gfortran -Ofast`. Another example, when X is NaN, (X == X) and
         32        ! (X >= X) are evaluated as TRUE by Flang 7.1.0 and nvfortran 21.3-0, even if they are invoked
         33        ! without any explicit optimization flag. See the following for discussions
         34        ! https://stackoverflow.com/questions/15944614
         35        !
         36        ! 5. The most naive implementation for IS_NAN is (X /= X). However, compilers (e.g., gfortran) may
         37        ! complain about inequality comparison between floating-point numbers. In addition, it is likely to
         38        ! fail when compliers are invoked with aggressive optimization flags.
         39        !
         40        ! 6. The implementation below is totally empirical, in the sense that I have not studied in-depth
         41        ! what the aggressive optimization flags really do, but only made some tests and found the
         42        ! implementation that worked correctly. The story may change when compilers are changed/updated.
         43        !
         44        ! 7. N.B.: Do NOT change the functions without thorough testing. Their implementation is delicate.
         45        ! For example, when compilers are invoked with aggressive optimization flags,
         46        ! (X <= HUGE(X) .AND. X >= -HUGE(X)) may differ from (ABS(X) <= HUGE(X)) ,
         47        ! (X > HUGE(X) .OR. X < -HUGE(X)) may differ from (ABS(X) > HUGE(X)) ,
         48        ! (ABS(X) > HUGE(X) .AND. X > 0) may differ from (X > HUGE(X)) .
         49        !
         50        ! 8. Even though the functions involve invocation of ABS and HUGE, their performance (in terms of
         51        ! CPU time) turns out comparable to or even better than the functions in IEEE_ARITHMETIC.
         52        !
         53        ! Coded by Zaikun ZHANG (www.zhangzk.net).
         54        !
         55        ! Started: July 2020.
         56        !
         57        ! Last Modified: Saturday, December 18, 2021 PM02:59:59
         58        !--------------------------------------------------------------------------------------------------!
         59        
         60        implicit none
         61        private
         62        public :: is_nan, is_finite, is_posinf, is_neginf, is_inf
         63        
         64        #if __QP_AVAILABLE__ == 1
         65        
         66        interface is_nan
         67            module procedure is_nan_sp, is_nan_dp, is_nan_qp
         68        end interface is_nan
         69        
         70        interface is_finite
         71            module procedure is_finite_sp, is_finite_dp, is_finite_qp
         72        end interface is_finite
         73        
         74        interface is_posinf
         75            module procedure is_posinf_sp, is_posinf_dp, is_posinf_qp
         76        end interface is_posinf
         77        
         78        interface is_neginf
         79            module procedure is_neginf_sp, is_neginf_dp, is_neginf_qp
         80        end interface is_neginf
         81        
         82        interface is_inf
         83            module procedure is_inf_sp, is_inf_dp, is_inf_qp
         84        end interface is_inf
         85        
         86        #else
         87        
         88        interface is_nan
         89            module procedure is_nan_sp, is_nan_dp
         90        end interface is_nan
         91        
         92        interface is_finite
         93            module procedure is_finite_sp, is_finite_dp
         94        end interface is_finite
         95        
         96        interface is_posinf
         97            module procedure is_posinf_sp, is_posinf_dp
         98        end interface is_posinf
         99        
        100        interface is_neginf
        101            module procedure is_neginf_sp, is_neginf_dp
        102        end interface is_neginf
        103        
        104        interface is_inf
        105            module procedure is_inf_sp, is_inf_dp
        106        end interface is_inf
        107        
        108        #endif
        109        
        110        
        111        contains
        112        
        113        
        114        pure elemental function is_nan_sp(x) result(y)
        115        use, non_intrinsic :: consts_mod, only : SP
        116        implicit none
        117        real(SP), intent(in) :: x
        118        logical :: y
        119        y = (.not. (x <= huge(x) .and. x >= -huge(x))) .and. (.not. abs(x) > huge(x))
        120        end function is_nan_sp
        121        
        122        pure elemental function is_nan_dp(x) result(y)
        123        use, non_intrinsic :: consts_mod, only : DP
        124        implicit none
        125        real(DP), intent(in) :: x
        126        logical :: y
        127        y = (.not. (x <= huge(x) .and. x >= -huge(x))) .and. (.not. abs(x) > huge(x))
        128        end function is_nan_dp
        129        
        130        pure elemental function is_finite_sp(x) result(y)
        131        use, non_intrinsic :: consts_mod, only : SP
        132        implicit none
        133        real(SP), intent(in) :: x
        134        logical :: y
        135        y = (x <= huge(x) .and. x >= -huge(x))
        136        end function is_finite_sp
        137        
        138        pure elemental function is_finite_dp(x) result(y)
        139        use, non_intrinsic :: consts_mod, only : DP
        140        implicit none
        141        real(DP), intent(in) :: x
        142        logical :: y
        143        y = (x <= huge(x) .and. x >= -huge(x))
        144        end function is_finite_dp
        145        
        146        pure elemental function is_posinf_sp(x) result(y)
        147        use, non_intrinsic :: consts_mod, only : SP
        148        implicit none
        149        real(SP), intent(in) :: x
        150        logical :: y
        151        y = (abs(x) > huge(x)) .and. (x > 0)
        152        end function is_posinf_sp
        153        
        154        pure elemental function is_posinf_dp(x) result(y)
        155        use, non_intrinsic :: consts_mod, only : DP
        156        implicit none
        157        real(DP), intent(in) :: x
        158        logical :: y
        159        y = (abs(x) > huge(x)) .and. (x > 0)
        160        end function is_posinf_dp
        161        
        162        pure elemental function is_neginf_sp(x) result(y)
        163        use, non_intrinsic :: consts_mod, only : SP
        164        implicit none
        165        real(SP), intent(in) :: x
        166        logical :: y
        167        y = (abs(x) > huge(x)) .and. (x < 0)
        168        end function is_neginf_sp
        169        
        170        pure elemental function is_neginf_dp(x) result(y)
        171        use, non_intrinsic :: consts_mod, only : DP
        172        implicit none
        173        real(DP), intent(in) :: x
        174        logical :: y
        175        y = (abs(x) > huge(x)) .and. (x < 0)
        176        end function is_neginf_dp
        177        
        178        pure elemental function is_inf_sp(x) result(y)
        179        use, non_intrinsic :: consts_mod, only : SP
        180        implicit none
        181        real(SP), intent(in) :: x
        182        logical :: y
        183        y = (abs(x) > huge(x))
        184        end function is_inf_sp
        185        
        186        pure elemental function is_inf_dp(x) result(y)
        187        use, non_intrinsic :: consts_mod, only : DP
        188        implicit none
        189        real(DP), intent(in) :: x
        190        logical :: y
        191        y = (abs(x) > huge(x))
        192        end function is_inf_dp
        193        
        194        
        195        #if __QP_AVAILABLE__ == 1
        196        
        197        pure elemental function is_nan_qp(x) result(y)
        198        use, non_intrinsic :: consts_mod, only : QP
        199        implicit none
        200        real(QP), intent(in) :: x
        201        logical :: y
        202        y = (.not. (x <= huge(x) .and. x >= -huge(x))) .and. (.not. abs(x) > huge(x))
        203        end function is_nan_qp
        204        
        205        pure elemental function is_finite_qp(x) result(y)
        206        use, non_intrinsic :: consts_mod, only : QP
        207        implicit none
        208        real(QP), intent(in) :: x
        209        logical :: y
        210        y = (x <= huge(x) .and. x >= -huge(x))
        211        end function is_finite_qp
        212        
        213        pure elemental function is_posinf_qp(x) result(y)
        214        use, non_intrinsic :: consts_mod, only : QP
        215        implicit none
        216        real(QP), intent(in) :: x
        217        logical :: y
        218        y = (abs(x) > huge(x)) .and. (x > 0)
        219        end function is_posinf_qp
        220        
        221        pure elemental function is_neginf_qp(x) result(y)
        222        use, non_intrinsic :: consts_mod, only : QP
        223        implicit none
        224        real(QP), intent(in) :: x
        225        logical :: y
        226        y = (abs(x) > huge(x)) .and. (x < 0)
        227        end function is_neginf_qp
        228        
        229        pure elemental function is_inf_qp(x) result(y)
        230        use, non_intrinsic :: consts_mod, only : QP
        231        implicit none
        232        real(QP), intent(in) :: x
        233        logical :: y
        234        y = (abs(x) > huge(x))
        235        end function is_inf_qp
        236        
        237        #endif
        238        
        239        
        240        end module infnan_mod

 Diagnostic messages: program name(infnan_mod)
  Module subprogram name(is_nan_sp)
   1090-S: "../../common/infnan.F90", line 114: Dummy argument of pure function 'x' must have the INTENT(IN) attribute unless it is a procedure argument or an argument with the POINTER attribute.
   2018-S: "../../common/infnan.F90", line 114: When IMPLICIT NONE is specified, 'x' must be declared in a type declaration statement.
   1333-S: "../../common/infnan.F90", line 115, column 4: Name expected.
   1185-S: "../../common/infnan.F90", line 117: In an initialization or specification expression, 'SP' must be a named constant.
   2018-S: "../../common/infnan.F90", line 117: When IMPLICIT NONE is specified, 'SP' must be declared in a type declaration statement.
   1326-S: "../../common/infnan.F90", line 117, column 6: Type specification or length specification invalid.
  Module subprogram name(is_nan_dp)
   1090-S: "../../common/infnan.F90", line 122: Dummy argument of pure function 'x' must have the INTENT(IN) attribute unless it is a procedure argument or an argument with the POINTER attribute.
   2018-S: "../../common/infnan.F90", line 122: When IMPLICIT NONE is specified, 'x' must be declared in a type declaration statement.
   1333-S: "../../common/infnan.F90", line 123, column 4: Name expected.
   1185-S: "../../common/infnan.F90", line 125: In an initialization or specification expression, 'DP' must be a named constant.
   2018-S: "../../common/infnan.F90", line 125: When IMPLICIT NONE is specified, 'DP' must be declared in a type declaration statement.
   1326-S: "../../common/infnan.F90", line 125, column 6: Type specification or length specification invalid.
  Module subprogram name(is_finite_sp)
   1090-S: "../../common/infnan.F90", line 130: Dummy argument of pure function 'x' must have the INTENT(IN) attribute unless it is a procedure argument or an argument with the POINTER attribute.
   2018-S: "../../common/infnan.F90", line 130: When IMPLICIT NONE is specified, 'x' must be declared in a type declaration statement.
   1333-S: "../../common/infnan.F90", line 131, column 4: Name expected.
   1185-S: "../../common/infnan.F90", line 133: In an initialization or specification expression, 'SP' must be a named constant.
   2018-S: "../../common/infnan.F90", line 133: When IMPLICIT NONE is specified, 'SP' must be declared in a type declaration statement.
   1326-S: "../../common/infnan.F90", line 133, column 6: Type specification or length specification invalid.
  Module subprogram name(is_finite_dp)
   1090-S: "../../common/infnan.F90", line 138: Dummy argument of pure function 'x' must have the INTENT(IN) attribute unless it is a procedure argument or an argument with the POINTER attribute.
   2018-S: "../../common/infnan.F90", line 138: When IMPLICIT NONE is specified, 'x' must be declared in a type declaration statement.
   1333-S: "../../common/infnan.F90", line 139, column 4: Name expected.
   1185-S: "../../common/infnan.F90", line 141: In an initialization or specification expression, 'DP' must be a named constant.
   2018-S: "../../common/infnan.F90", line 141: When IMPLICIT NONE is specified, 'DP' must be declared in a type declaration statement.
   1326-S: "../../common/infnan.F90", line 141, column 6: Type specification or length specification invalid.
  Module subprogram name(is_posinf_sp)
   1090-S: "../../common/infnan.F90", line 146: Dummy argument of pure function 'x' must have the INTENT(IN) attribute unless it is a procedure argument or an argument with the POINTER attribute.
   2018-S: "../../common/infnan.F90", line 146: When IMPLICIT NONE is specified, 'x' must be declared in a type declaration statement.
   1333-S: "../../common/infnan.F90", line 147, column 4: Name expected.
   1185-S: "../../common/infnan.F90", line 149: In an initialization or specification expression, 'SP' must be a named constant.
   2018-S: "../../common/infnan.F90", line 149: When IMPLICIT NONE is specified, 'SP' must be declared in a type declaration statement.
   1326-S: "../../common/infnan.F90", line 149, column 6: Type specification or length specification invalid.
  Module subprogram name(is_posinf_dp)
   1090-S: "../../common/infnan.F90", line 154: Dummy argument of pure function 'x' must have the INTENT(IN) attribute unless it is a procedure argument or an argument with the POINTER attribute.
   1333-S: "../../common/infnan.F90", line 155, column 4: Name expected.
   1185-S: "../../common/infnan.F90", line 157: In an initialization or specification expression, 'DP' must be a named constant.
   1326-S: "../../common/infnan.F90", line 157, column 6: Type specification or length specification invalid.
  Module subprogram name(is_neginf_sp)
   1090-S: "../../common/infnan.F90", line 162: Dummy argument of pure function 'x' must have the INTENT(IN) attribute unless it is a procedure argument or an argument with the POINTER attribute.
   1333-S: "../../common/infnan.F90", line 163, column 4: Name expected.
   1185-S: "../../common/infnan.F90", line 165: In an initialization or specification expression, 'SP' must be a named constant.
   1326-S: "../../common/infnan.F90", line 165, column 6: Type specification or length specification invalid.
  Module subprogram name(is_neginf_dp)
   1090-S: "../../common/infnan.F90", line 170: Dummy argument of pure function 'x' must have the INTENT(IN) attribute unless it is a procedure argument or an argument with the POINTER attribute.
   1333-S: "../../common/infnan.F90", line 171, column 4: Name expected.
   1185-S: "../../common/infnan.F90", line 173: In an initialization or specification expression, 'DP' must be a named constant.
   1326-S: "../../common/infnan.F90", line 173, column 6: Type specification or length specification invalid.
  Module subprogram name(is_inf_sp)
   1090-S: "../../common/infnan.F90", line 178: Dummy argument of pure function 'x' must have the INTENT(IN) attribute unless it is a procedure argument or an argument with the POINTER attribute.
   1333-S: "../../common/infnan.F90", line 179, column 4: Name expected.
   1185-S: "../../common/infnan.F90", line 181: In an initialization or specification expression, 'SP' must be a named constant.
   1326-S: "../../common/infnan.F90", line 181, column 6: Type specification or length specification invalid.
  Module subprogram name(is_inf_dp)
   1090-S: "../../common/infnan.F90", line 186: Dummy argument of pure function 'x' must have the INTENT(IN) attribute unless it is a procedure argument or an argument with the POINTER attribute.
   1333-S: "../../common/infnan.F90", line 187, column 4: Name expected.
   1185-S: "../../common/infnan.F90", line 189: In an initialization or specification expression, 'DP' must be a named constant.
   1326-S: "../../common/infnan.F90", line 189, column 6: Type specification or length specification invalid.

 Procedure information
   Lines      : 508
   Statements : 91

 Total information
   Procedures       : 1
   Total lines      : 508
   Total statements : 91


 Lahey/Fujitsu Fortran 95 Compiler Release L8.10b  Sat Feb 12 17:36:58 2022
 Copyright (C) 1994-2008 Lahey Computer Systems.  All rights reserved.
 Copyright (C) 1998-2008 FUJITSU LIMITED. All rights reserved.

 Compilation information
   Current directory : /home/zaikunzhang/Bureau/neupdfo/fsrc/classical/uobyqa
   Source file       : ../../common/memory.F90
   Cpp options       : -Xs -Dunix -Dx86_64 -D__unix -D__x86_64 -D__ELF__ -D__x86_64__ -D__unix__ -D__linux__ -D__linux -Asystem(unix) -Asystem(posix) -Acpu(x86_64) -Amachine(x86_64) -Dlinux
   Compiler options  : --ap --nblock -c --chk aefosux --chkglobal --nco 
                     : --nconcc --dal --ndbl --nf95 --nfast -g --in --info 
                     : --ninline --li --lst --nlong --maxfatals 50 --nml 
                     : --nmldefault --o0 --no --nocl --nopenmp --nparallel 
                     : --nprefetch --npca --nprivate --nquad --quiet --sav 
                     : --nshared --sse2 --nstaticlink --nswm --nthreadheap 
                     : --nthreads --trace --ntrap --nunroll --nvarheap 
                     : --nvarstack --nversion --warn --nwide --nwisk --wo --zfm 
                     : --xref

 Module "memory_mod"
  (line-no.)(nest)
          1        #include "ppf.h"
          2        
          3        module memory_mod
          4        !--------------------------------------------------------------------------------------------------!
          5        ! This module provides subroutines concerning memory management.
          6        !
          7        ! Coded by Zaikun ZHANG (www.zhangzk.net).
          8        !
          9        ! Started: July 2020
         10        !
         11        ! Last Modified: Wednesday, February 02, 2022 PM08:07:20
         12        !--------------------------------------------------------------------------------------------------!
         13        
         14        implicit none
         15        private
         16        public :: cstyle_sizeof
         17        public :: safealloc
         18        
         19        interface cstyle_sizeof
         20            module procedure size_of_sp, size_of_dp
         21        #if __QP_AVAILABLE__ == 1
         22            module procedure size_of_qp
         23        #endif
         24        end interface cstyle_sizeof
         25        
         26        interface safealloc
         27            module procedure alloc_ivector, alloc_imatrix
         28            module procedure alloc_rvector_sp, alloc_rmatrix_sp
         29            module procedure alloc_rvector_dp, alloc_rmatrix_dp
         30        #if __QP_AVAILABLE__ == 1
         31            module procedure alloc_rvector_qp, alloc_rmatrix_qp
         32        #endif
         33        end interface safealloc
         34        
         35        
         36        contains
         37        
         38        
         39        pure function size_of_sp(x) result(y)
         40        !--------------------------------------------------------------------------------------------------!
         41        ! Return the storage size of X in Bytes, X being a REAL(SP) scalar.
         42        !--------------------------------------------------------------------------------------------------!
         43        use, non_intrinsic :: consts_mod, only : SP, IK
         44        implicit none
         45        ! Inputs
         46        real(SP), intent(in) :: x
         47        ! Outputs
         48        integer(IK) :: y
         49        
         50        #if __USE_STORAGE_SIZE__ == 1
         51        ! We prefer STORAGE_SIZE to C_SIZEOF, because the former is intrinsic while the later requires the
         52        ! intrinsic module ISO_C_BINDING.
         53        y = int(storage_size(x) / 8, kind(y))  ! Y = INT(C_SIZEOF(X), KIND(Y))
         54        #else
         55        y = int(kind(x), kind(y)) ! Avoid complaint
         56        y = int(4, kind(y))  ! This is not portable
         57        #endif
         58        end function size_of_sp
         59        
         60        
         61        pure function size_of_dp(x) result(y)
         62        !--------------------------------------------------------------------------------------------------!
         63        ! Return the storage size of X in Bytes, X being a REAL(DP) scalar.
         64        !--------------------------------------------------------------------------------------------------!
         65        use, non_intrinsic :: consts_mod, only : DP, IK
         66        implicit none
         67        ! Inputs
         68        real(DP), intent(in) :: x
         69        ! Outputs
         70        integer(IK) :: y
         71        
         72        #if __USE_STORAGE_SIZE__ == 1
         73        y = int(storage_size(x) / 8, kind(y))
         74        #else
         75        y = int(kind(x), kind(y)) ! Avoid complaint
         76        y = int(8, kind(y))  ! This is not portable
         77        #endif
         78        end function size_of_dp
         79        
         80        
         81        #if __QP_AVAILABLE__ == 1
         82        
         83        pure function size_of_qp(x) result(y)
         84        !--------------------------------------------------------------------------------------------------!
         85        ! Return the storage size of X in Bytes, X being a REAL(QP) scalar.
         86        !--------------------------------------------------------------------------------------------------!
         87        use, non_intrinsic :: consts_mod, only : QP, IK
         88        implicit none
         89        ! Inputs
         90        real(QP), intent(in) :: x
         91        ! Outputs
         92        integer(IK) :: y
         93        
         94        #if __USE_STORAGE_SIZE__ == 1
         95        y = int(storage_size(x) / 8, kind(y))
         96        #else
         97        y = int(kind(x), kind(y)) ! Avoid complaint
         98        y = int(16, kind(y))  ! This is not portable
         99        #endif
        100        end function size_of_qp
        101        
        102        #endif
        103        
        104        
        105        subroutine alloc_rvector_sp(x, n)
        106        !--------------------------------------------------------------------------------------------------!
        107        ! Allocate space for an allocatable REAL(SP) vector X, whose size is N after allocation.
        108        !--------------------------------------------------------------------------------------------------!
        109        use, non_intrinsic :: consts_mod, only : SP, IK
        110        use, non_intrinsic :: debug_mod, only : validate
        111        implicit none
        112        
        113        ! Inputs
        114        integer(IK), intent(in) :: n
        115        
        116        ! Outputs
        117        real(SP), allocatable, intent(out) :: x(:)
        118        
        119        ! Local variables
        120        integer :: alloc_status
        121        character(len=*), parameter :: srname = 'ALLOC_RVECTOR_SP'
        122        
        123        ! Preconditions (checked even not debugging)
        124        call validate(n >= 0, 'N >= 0', srname)
        125        
        126        ! According to the Fortran 2003 standard, when a procedure is invoked, any allocated ALLOCATABLE
        127        ! object that is an actual argument associated with an INTENT(OUT) ALLOCATABLE dummy argument is
        128        ! deallocated. So the following line is unnecessary since F2003 as X is INTENT(OUT):
        129        !!if (allocated(x)) deallocate (x)
        130        ! Allocate memory for X
        131        allocate (x(1:n), stat=alloc_status)
        132        call validate(alloc_status == 0, 'Memory allocation succeeds (ALLOC_STATUS == 0)', srname)
        133        call validate(allocated(x), 'X is allocated', srname)
        134        
        135        ! Initialize X to a strange value independent of the compiler; it can be costly for a large size.
        136        x = -huge(x)
        137        
        138        ! Postconditions (checked even not debugging)
        139        call validate(size(x) == n, 'SIZE(X) == N', srname)
        140        end subroutine alloc_rvector_sp
        141        
        142        
        143        subroutine alloc_rmatrix_sp(x, m, n)
        144        !--------------------------------------------------------------------------------------------------!
        145        ! Allocate space for an allocatable REAL(SP) matrix X, whose size is (M, N) after allocation.
        146        !--------------------------------------------------------------------------------------------------!
        147        use, non_intrinsic :: consts_mod, only : SP, IK
        148        use, non_intrinsic :: debug_mod, only : validate
        149        implicit none
        150        
        151        ! Inputs
        152        integer(IK), intent(in) :: m, n
        153        
        154        ! Outputs
        155        real(SP), allocatable, intent(out) :: x(:, :)
        156        
        157        ! Local variables
        158        integer :: alloc_status
        159        character(len=*), parameter :: srname = 'ALLOC_RMATRIX_SP'
        160        
        161        ! Preconditions (checked even not debugging)
        162        call validate(m >= 0 .and. n >= 0, 'M >= 0, N >= 0', srname)
        163        
        164        !!if (allocated(x)) deallocate (x)  ! Unnecessary in F03 since X is INTENT(OUT)
        165        ! Allocate memory for X
        166        allocate (x(1:m, 1:n), stat=alloc_status)
        167        call validate(alloc_status == 0, 'Memory allocation succeeds (ALLOC_STATUS == 0)', srname)
        168        call validate(allocated(x), 'X is allocated', srname)
        169        
        170        ! Initialize X to a strange value independent of the compiler; it can be costly for a large size.
        171        x = -huge(x)
        172        
        173        ! Postconditions (checked even not debugging)
        174        call validate(size(x, 1) == m .and. size(x, 2) == n, 'SIZE(X) == [M, N]', srname)
        175        end subroutine alloc_rmatrix_sp
        176        
        177        
        178        subroutine alloc_rvector_dp(x, n)
        179        !--------------------------------------------------------------------------------------------------!
        180        ! Allocate space for an allocatable REAL(DP) vector X, whose size is N after allocation.
        181        !--------------------------------------------------------------------------------------------------!
        182        use, non_intrinsic :: consts_mod, only : DP, IK
        183        use, non_intrinsic :: debug_mod, only : validate
        184        implicit none
        185        
        186        ! Inputs
        187        integer(IK), intent(in) :: n
        188        
        189        ! Outputs
        190        real(DP), allocatable, intent(out) :: x(:)
        191        
        192        ! Local variables
        193        integer :: alloc_status
        194        character(len=*), parameter :: srname = 'ALLOC_RVECTOR_DP'
        195        
        196        ! Preconditions (checked even not debugging)
        197        call validate(n >= 0, 'N >= 0', srname)
        198        
        199        ! According to the Fortran 2003 standard, when a procedure is invoked, any allocated ALLOCATABLE
        200        ! object that is an actual argument associated with an INTENT(OUT) ALLOCATABLE dummy argument is
        201        ! deallocated. So the following line is unnecessary since F2003 as X is INTENT(OUT):
        202        !!if (allocated(x)) deallocate (x)
        203        ! Allocate memory for X
        204        allocate (x(1:n), stat=alloc_status)
        205        call validate(alloc_status == 0, 'Memory allocation succeeds (ALLOC_STATUS == 0)', srname)
        206        call validate(allocated(x), 'X is allocated', srname)
        207        
        208        ! Initialize X to a strange value independent of the compiler; it can be costly for a large size.
        209        x = -huge(x)
        210        
        211        ! Postconditions (checked even not debugging)
        212        call validate(size(x) == n, 'SIZE(X) == N', srname)
        213        end subroutine alloc_rvector_dp
        214        
        215        
        216        subroutine alloc_rmatrix_dp(x, m, n)
        217        !--------------------------------------------------------------------------------------------------!
        218        ! Allocate space for an allocatable REAL(DP) matrix X, whose size is (M, N) after allocation.
        219        !--------------------------------------------------------------------------------------------------!
        220        use, non_intrinsic :: consts_mod, only : DP, IK
        221        use, non_intrinsic :: debug_mod, only : validate
        222        implicit none
        223        
        224        ! Inputs
        225        integer(IK), intent(in) :: m, n
        226        
        227        ! Outputs
        228        real(DP), allocatable, intent(out) :: x(:, :)
        229        
        230        ! Local variables
        231        integer :: alloc_status
        232        character(len=*), parameter :: srname = 'ALLOC_RMATRIX_DP'
        233        
        234        ! Preconditions (checked even not debugging)
        235        call validate(m >= 0 .and. n >= 0, 'M >= 0, N >= 0', srname)
        236        
        237        !!if (allocated(x)) deallocate (x)  ! Unnecessary in F03 since X is INTENT(OUT)
        238        ! Allocate memory for X
        239        allocate (x(1:m, 1:n), stat=alloc_status)
        240        call validate(alloc_status == 0, 'Memory allocation succeeds (ALLOC_STATUS == 0)', srname)
        241        call validate(allocated(x), 'X is allocated', srname)
        242        
        243        ! Initialize X to a strange value independent of the compiler; it can be costly for a large size.
        244        x = -huge(x)
        245        
        246        ! Postconditions (checked even not debugging)
        247        call validate(size(x, 1) == m .and. size(x, 2) == n, 'SIZE(X) == [M, N]', srname)
        248        end subroutine alloc_rmatrix_dp
        249        
        250        
        251        #if __QP_AVAILABLE__ == 1
        252        
        253        subroutine alloc_rvector_qp(x, n)
        254        !--------------------------------------------------------------------------------------------------!
        255        ! Allocate space for an allocatable REAL(QP) vector X, whose size is N after allocation.
        256        !--------------------------------------------------------------------------------------------------!
        257        use, non_intrinsic :: consts_mod, only : QP, IK
        258        use, non_intrinsic :: debug_mod, only : validate
        259        implicit none
        260        
        261        ! Inputs
        262        integer(IK), intent(in) :: n
        263        
        264        ! Outputs
        265        real(QP), allocatable, intent(out) :: x(:)
        266        
        267        ! Local variables
        268        integer :: alloc_status
        269        character(len=*), parameter :: srname = 'ALLOC_RVECTOR_QP'
        270        
        271        ! Preconditions (checked even not debugging)
        272        call validate(n >= 0, 'N >= 0', srname)
        273        
        274        ! According to the Fortran 2003 standard, when a procedure is invoked, any allocated ALLOCATABLE
        275        ! object that is an actual argument associated with an INTENT(OUT) ALLOCATABLE dummy argument is
        276        ! deallocated. So the following line is unnecessary since F2003 as X is INTENT(OUT):
        277        !!if (allocated(x)) deallocate (x)
        278        ! Allocate memory for X
        279        allocate (x(1:n), stat=alloc_status)
        280        call validate(alloc_status == 0, 'Memory allocation succeeds (ALLOC_STATUS == 0)', srname)
        281        call validate(allocated(x), 'X is allocated', srname)
        282        
        283        ! Initialize X to a strange value independent of the compiler; it can be costly for a large size.
        284        x = -huge(x)
        285        
        286        ! Postconditions (checked even not debugging)
        287        call validate(size(x) == n, 'SIZE(X) == N', srname)
        288        end subroutine alloc_rvector_qp
        289        
        290        
        291        subroutine alloc_rmatrix_qp(x, m, n)
        292        !--------------------------------------------------------------------------------------------------!
        293        ! Allocate space for an allocatable REAL(QP) matrix X, whose size is (M, N) after allocation.
        294        !--------------------------------------------------------------------------------------------------!
        295        use, non_intrinsic :: consts_mod, only : QP, IK
        296        use, non_intrinsic :: debug_mod, only : validate
        297        implicit none
        298        
        299        ! Inputs
        300        integer(IK), intent(in) :: m, n
        301        
        302        ! Outputs
        303        real(QP), allocatable, intent(out) :: x(:, :)
        304        
        305        ! Local variables
        306        integer :: alloc_status
        307        character(len=*), parameter :: srname = 'ALLOC_RMATRIX_QP'
        308        
        309        ! Preconditions (checked even not debugging)
        310        call validate(m >= 0 .and. n >= 0, 'M >= 0, N >= 0', srname)
        311        
        312        !!if (allocated(x)) deallocate (x)  ! Unnecessary in F03 since X is INTENT(OUT)
        313        ! Allocate memory for X
        314        allocate (x(1:m, 1:n), stat=alloc_status)
        315        call validate(alloc_status == 0, 'Memory allocation succeeds (ALLOC_STATUS == 0)', srname)
        316        call validate(allocated(x), 'X is allocated', srname)
        317        
        318        ! Initialize X to a strange value independent of the compiler; it can be costly for a large size.
        319        x = -huge(x)
        320        
        321        ! Postconditions (checked even not debugging)
        322        call validate(size(x, 1) == m .and. size(x, 2) == n, 'SIZE(X) == [M, N]', srname)
        323        end subroutine alloc_rmatrix_qp
        324        
        325        #endif
        326        
        327        
        328        subroutine alloc_ivector(x, n)
        329        !--------------------------------------------------------------------------------------------------!
        330        ! Allocate space for an allocatable INTEGER(IK) vector X, whose size is N after allocation.
        331        !--------------------------------------------------------------------------------------------------!
        332        use, non_intrinsic :: consts_mod, only : IK
        333        use, non_intrinsic :: debug_mod, only : validate
        334        implicit none
        335        
        336        ! Inputs
        337        integer(IK), intent(in) :: n
        338        
        339        ! Outputs
        340        integer(IK), allocatable, intent(out) :: x(:)
        341        
        342        ! Local variables
        343        integer :: alloc_status
        344        character(len=*), parameter :: srname = 'ALLOC_IVECTOR'
        345        
        346        ! Preconditions (checked even not debugging)
        347        call validate(n >= 0, 'N >= 0', srname)
        348        
        349        !!if (allocated(x)) deallocate (x)  ! Unnecessary in F03 since X is INTENT(OUT)
        350        ! Allocate memory for X
        351        allocate (x(1:n), stat=alloc_status)
        352        call validate(alloc_status == 0, 'Memory allocation succeeds (ALLOC_STATUS == 0)', srname)
        353        call validate(allocated(x), 'X is allocated', srname)
        354        
        355        ! Initialize X to a strange value independent of the compiler; it can be costly for a large size.
        356        x = -huge(x)
        357        
        358        ! Postconditions (checked even not debugging)
        359        call validate(size(x) == n, 'SIZE(X) == N', srname)
        360        end subroutine alloc_ivector
        361        
        362        
        363        subroutine alloc_imatrix(x, m, n)
        364        !--------------------------------------------------------------------------------------------------!
        365        ! Allocate space for a INTEGER(IK) matrix X, whose size is (M, N) after allocation.
        366        !--------------------------------------------------------------------------------------------------!
        367        use, non_intrinsic :: consts_mod, only : IK
        368        use, non_intrinsic :: debug_mod, only : validate
        369        implicit none
        370        
        371        ! Inputs
        372        integer(IK), intent(in) :: m, n
        373        
        374        ! Outputs
        375        integer(IK), allocatable, intent(out) :: x(:, :)
        376        
        377        ! Local variables
        378        integer :: alloc_status
        379        character(len=*), parameter :: srname = 'ALLOC_IMATRIX'
        380        
        381        ! Preconditions (checked even not debugging)
        382        call validate(m >= 0 .and. n >= 0, 'M >= 0, N >= 0', srname)
        383        
        384        !!if (allocated(x)) deallocate (x)  ! Unnecessary in F03 since X is INTENT(OUT)
        385        ! Allocate memory for X
        386        allocate (x(1:m, 1:n), stat=alloc_status)
        387        call validate(alloc_status == 0, 'Memory allocation succeeds (ALLOC_STATUS == 0)', srname)
        388        call validate(allocated(x), 'X is allocated', srname)
        389        
        390        ! Initialize X to a strange value independent of the compiler; it can be costly for a large size.
        391        x = -huge(x)
        392        
        393        ! Postconditions (checked even not debugging)
        394        call validate(size(x, 1) == m .and. size(x, 2) == n, 'SIZE(X) == [M, N]', srname)
        395        end subroutine alloc_imatrix
        396        
        397        
        398        end module memory_mod

 Diagnostic messages: program name(memory_mod)
  Module subprogram name(size_of_sp)
   1090-S: "../../common/memory.F90", line 39: Dummy argument of pure function 'x' must have the INTENT(IN) attribute unless it is a procedure argument or an argument with the POINTER attribute.
   1333-S: "../../common/memory.F90", line 43, column 4: Name expected.
   1185-S: "../../common/memory.F90", line 46: In an initialization or specification expression, 'SP' must be a named constant.
   1326-S: "../../common/memory.F90", line 46, column 6: Type specification or length specification invalid.
   1185-S: "../../common/memory.F90", line 48: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/memory.F90", line 48, column 9: Type specification or length specification invalid.
  Module subprogram name(size_of_dp)
   1090-S: "../../common/memory.F90", line 61: Dummy argument of pure function 'x' must have the INTENT(IN) attribute unless it is a procedure argument or an argument with the POINTER attribute.
   1333-S: "../../common/memory.F90", line 65, column 4: Name expected.
   1185-S: "../../common/memory.F90", line 68: In an initialization or specification expression, 'DP' must be a named constant.
   1326-S: "../../common/memory.F90", line 68, column 6: Type specification or length specification invalid.
   1185-S: "../../common/memory.F90", line 70: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/memory.F90", line 70, column 9: Type specification or length specification invalid.
  Module subprogram name(alloc_rvector_sp)
   1333-S: "../../common/memory.F90", line 109, column 4: Name expected.
   1333-S: "../../common/memory.F90", line 110, column 4: Name expected.
   1185-S: "../../common/memory.F90", line 114: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/memory.F90", line 114, column 9: Type specification or length specification invalid.
   1185-S: "../../common/memory.F90", line 117: In an initialization or specification expression, 'SP' must be a named constant.
   1326-S: "../../common/memory.F90", line 117, column 6: Type specification or length specification invalid.
   1361-S: "../../common/memory.F90", line 131, column 11: Allocate object in an ALLOCATE or DEALLOCATE statement must be a variable name or structure component which is a pointer or allocatable array.
  Module subprogram name(alloc_rmatrix_sp)
   1333-S: "../../common/memory.F90", line 147, column 4: Name expected.
   1333-S: "../../common/memory.F90", line 148, column 4: Name expected.
   1185-S: "../../common/memory.F90", line 152: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/memory.F90", line 152, column 9: Type specification or length specification invalid.
   1185-S: "../../common/memory.F90", line 155: In an initialization or specification expression, 'SP' must be a named constant.
   1326-S: "../../common/memory.F90", line 155, column 6: Type specification or length specification invalid.
   1619-S: "../../common/memory.F90", line 166, column 11: 'x' not an array name or invalid array reference.
  Module subprogram name(alloc_rvector_dp)
   1333-S: "../../common/memory.F90", line 182, column 4: Name expected.
   1333-S: "../../common/memory.F90", line 183, column 4: Name expected.
   1185-S: "../../common/memory.F90", line 187: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/memory.F90", line 187, column 9: Type specification or length specification invalid.
   1185-S: "../../common/memory.F90", line 190: In an initialization or specification expression, 'DP' must be a named constant.
   1326-S: "../../common/memory.F90", line 190, column 6: Type specification or length specification invalid.
   1361-S: "../../common/memory.F90", line 204, column 11: Allocate object in an ALLOCATE or DEALLOCATE statement must be a variable name or structure component which is a pointer or allocatable array.
  Module subprogram name(alloc_rmatrix_dp)
   1333-S: "../../common/memory.F90", line 220, column 4: Name expected.
   1333-S: "../../common/memory.F90", line 221, column 4: Name expected.
   1185-S: "../../common/memory.F90", line 225: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/memory.F90", line 225, column 9: Type specification or length specification invalid.
   1185-S: "../../common/memory.F90", line 228: In an initialization or specification expression, 'DP' must be a named constant.
   1326-S: "../../common/memory.F90", line 228, column 6: Type specification or length specification invalid.
   1619-S: "../../common/memory.F90", line 239, column 11: 'x' not an array name or invalid array reference.
  Module subprogram name(alloc_ivector)
   1333-S: "../../common/memory.F90", line 332, column 4: Name expected.
   1333-S: "../../common/memory.F90", line 333, column 4: Name expected.
   1185-S: "../../common/memory.F90", line 337: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/memory.F90", line 337, column 9: Type specification or length specification invalid.
   1185-S: "../../common/memory.F90", line 340: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/memory.F90", line 340, column 9: Type specification or length specification invalid.
   1361-S: "../../common/memory.F90", line 351, column 11: Allocate object in an ALLOCATE or DEALLOCATE statement must be a variable name or structure component which is a pointer or allocatable array.
  Module subprogram name(alloc_imatrix)
   1333-S: "../../common/memory.F90", line 367, column 4: Name expected.
   1333-S: "../../common/memory.F90", line 368, column 4: Name expected.
   1185-S: "../../common/memory.F90", line 372: In an initialization or specification expression, 'IK' must be a named constant.

 Procedure information
   Lines      : 666
   Statements : 121

 Total information
   Procedures       : 1
   Total lines      : 666
   Total statements : 121


 Lahey/Fujitsu Fortran 95 Compiler Release L8.10b  Sat Feb 12 17:36:58 2022
 Copyright (C) 1994-2008 Lahey Computer Systems.  All rights reserved.
 Copyright (C) 1998-2008 FUJITSU LIMITED. All rights reserved.

 Compilation information
   Current directory : /home/zaikunzhang/Bureau/neupdfo/fsrc/classical/uobyqa
   Source file       : ../../common/string.f90
   Compiler options  : --ap --nblock -c --chk aefosux --chkglobal --nco 
                     : --nconcc --dal --ndbl --nf95 --nfast -g --in --info 
                     : --ninline --li --lst --nlong --maxfatals 50 --nml 
                     : --nmldefault --o0 --no --nocl --nopenmp --nparallel 
                     : --nprefetch --npca --nprivate --nquad --quiet --sav 
                     : --nshared --sse2 --nstaticlink --nswm --nthreadheap 
                     : --nthreads --trace --ntrap --nunroll --nvarheap 
                     : --nvarstack --nversion --warn --nwide --nwisk --wo --zfm 
                     : --xref

 Module "string_mod"
  (line-no.)(nest)
          1        module string_mod
          2        !--------------------------------------------------------------------------------------------------!
          3        ! This module provides some procedures for manipulating strings.
          4        !
          5        ! Coded by Zaikun ZHANG (www.zhangzk.net).
          6        !
          7        ! Started: September 2021
          8        !
          9        ! Last Modified: Wednesday, September 22, 2021 PM06:52:11
         10        !--------------------------------------------------------------------------------------------------!
         11        
         12        implicit none
         13        private
         14        public :: lower, upper, trimstr, istr
         15        
         16        
         17        contains
         18        
         19        
         20        pure function lower(x) result(y)
         21        !--------------------------------------------------------------------------------------------------!
         22        ! This function maps the characters of a string to the lower case, if applicable.
         23        !--------------------------------------------------------------------------------------------------!
         24        
         25        implicit none
         26        
         27        character(len=*), intent(in) :: x
         28        character(len=len(x)) :: y
         29        
         30        integer, parameter :: dist = ichar('A') - ichar('a')
         31        integer :: i
         32        
         33        y = x
         34     1  do i = 1, len(y)
         35     2      if (y(i:i) >= 'A' .and. y(i:i) <= 'Z') then
         36     2          y(i:i) = char(ichar(y(i:i)) - dist)
         37     2      end if
         38     1  end do
         39        end function lower
         40        
         41        
         42        pure function upper(x) result(y)
         43        !--------------------------------------------------------------------------------------------------!
         44        ! This function maps the characters of a string to the upper case, if applicable.
         45        !--------------------------------------------------------------------------------------------------!
         46        
         47        implicit none
         48        
         49        character(len=*), intent(in) :: x
         50        character(len=len(x)) :: y
         51        
         52        integer, parameter :: dist = ichar('A') - ichar('a')
         53        integer :: i
         54        
         55        y = x
         56     1  do i = 1, len(y)
         57     2      if (y(i:i) >= 'a' .and. y(i:i) <= 'z') then
         58     2          y(i:i) = char(ichar(y(i:i)) + dist)
         59     2      end if
         60     1  end do
         61        end function upper
         62        
         63        
         64        pure function trimstr(x) result(y)
         65        !--------------------------------------------------------------------------------------------------!
         66        ! This function removes the leading and trailing spaces of a string.
         67        !--------------------------------------------------------------------------------------------------!
         68        
         69        implicit none
         70        
         71        character(len=*), intent(in) :: x
         72        character(len=len(trim(adjustl(x)))) :: y
         73        
         74        y = trim(adjustl(x))
         75        end function trimstr
         76        
         77        
         78        pure function istr(x) result(y)
         79        use, non_intrinsic :: consts_mod, only : IK
         80        implicit none
         81        character(len=*), intent(in) :: x
         82        integer(IK) :: y(len(x))
         83        
         84        integer(IK) :: i
         85        
         86        y = [(int(ichar(x(i:i)), IK), i=1, int(len(x), IK))]
         87        
         88        end function istr
         89        
         90        end module string_mod

 Diagnostic messages: program name(string_mod)
  Module subprogram name(istr)
   2018-S: "../../common/string.f90", line 78: When IMPLICIT NONE is specified, 'y' must be declared in a type declaration statement.
   2008-I: "../../common/string.f90", line 78: Dummy argument 'x' not used in this subprogram.
   2007-W: "../../common/string.f90", line 78: No value assigned to function, entry, or function result name of function subprogram.
   1333-S: "../../common/string.f90", line 79, column 4: Name expected.
   1185-S: "../../common/string.f90", line 82: In an initialization or specification expression, 'IK' must be a named constant.
   2018-S: "../../common/string.f90", line 82: When IMPLICIT NONE is specified, 'IK' must be declared in a type declaration statement.
   1326-S: "../../common/string.f90", line 82, column 9: Type specification or length specification invalid.
   1185-S: "../../common/string.f90", line 84: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/string.f90", line 84, column 9: Type specification or length specification invalid.
   1006-S: "../../common/string.f90", line 86, column 5: Character not allowed by syntax rules or not a valid Fortran character.
   1035-S: "../../common/string.f90", line 86, column 5: Invalid operator.

 Procedure information
   Lines      : 90
   Statements : 46

 Scoping unit of module : string_mod
   Attribute and Cross reference of name
     istr
      |(Class and Type) : module function name, none
      |(Attributes)     : PUBLIC, PURE
      |(Declaration)    : 14
      |(Definition)     : 
      |(Reference)      : 
     lower
      |(Class and Type) : module function name, CHARACTER((expression),1)
      |(Attributes)     : PUBLIC, PURE
      |(Declaration)    : 14
      |(Definition)     : 
      |(Reference)      : 
     string_mod
      |(Class and Type) : module name
      |(Attributes)     : PRIVATE
      |(Declaration)    : 1
      |(Definition)     : 
      |(Reference)      : 90
     trimstr
      |(Class and Type) : module function name, CHARACTER((expression),1)
      |(Attributes)     : PUBLIC, PURE
      |(Declaration)    : 14
      |(Definition)     : 
      |(Reference)      : 
     upper
      |(Class and Type) : module function name, CHARACTER((expression),1)
      |(Attributes)     : PUBLIC, PURE
      |(Declaration)    : 14
      |(Definition)     : 
      |(Reference)      : 

 Scoping unit of module sub-program : lower
   Attribute and Cross reference of name
     char
      |(Class and Type) : intrinsic function name, CHARACTER((unknown),1)
      |(Attributes)     : PURE, ELEMENTAL
      |(Declaration)    : 
      |(Definition)     : 
      |(Reference)      : 36
     dist
      |(Class and Type) : named constant, INTEGER(4)
      |(Attributes)     : 
      |(Declaration)    : 30
      |(Definition)     : 
      |(Reference)      : 36
     i
      |(Class and Type) : variable name, INTEGER(4)
      |(Attributes)     : 
      |(Declaration)    : 31
      |(Definition)     : 34
      |(Reference)      : 35  35  35  35  36  36  36  36
     ichar
      |(Class and Type) : intrinsic function name, INTEGER(4)
      |(Attributes)     : PURE, ELEMENTAL
      |(Declaration)    : 
      |(Definition)     : 
      |(Reference)      : 30  30  36
     len
      |(Class and Type) : intrinsic function name, INTEGER(4)
      |(Attributes)     : PURE
      |(Declaration)    : 
      |(Definition)     : 
      |(Reference)      : 28  34
     lower
      |(Class and Type) : module function name, CHARACTER((expression),1)
      |(Attributes)     : PURE
      |(Declaration)    : 
      |(Definition)     : 20
      |(Reference)      : 39
     x
      |(Class and Type) : variable name, CHARACTER(*,1)
      |(Attributes)     : INTENT(IN), dummy-argument
      |(Declaration)    : 20  27
      |(Definition)     : 
      |(Reference)      : 28  33
     y
      |(Class and Type) : variable name, CHARACTER((expression),1)
      |(Attributes)     : result-value
      |(Declaration)    : 20  28
      |(Definition)     : 33  36
      |(Reference)      : 34  35  35  36

 Scoping unit of module sub-program : upper
   Attribute and Cross reference of name
     char
      |(Class and Type) : intrinsic function name, CHARACTER((unknown),1)
      |(Attributes)     : PURE, ELEMENTAL
      |(Declaration)    : 
      |(Definition)     : 
      |(Reference)      : 58
     dist
      |(Class and Type) : named constant, INTEGER(4)
      |(Attributes)     : 
      |(Declaration)    : 52
      |(Definition)     : 
      |(Reference)      : 58
     i
      |(Class and Type) : variable name, INTEGER(4)
      |(Attributes)     : 
      |(Declaration)    : 53
      |(Definition)     : 56
      |(Reference)      : 57  57  57  57  58  58  58  58
     ichar
      |(Class and Type) : intrinsic function name, INTEGER(4)
      |(Attributes)     : PURE, ELEMENTAL
      |(Declaration)    : 
      |(Definition)     : 
      |(Reference)      : 52  52  58
     len
      |(Class and Type) : intrinsic function name, INTEGER(4)
      |(Attributes)     : PURE
      |(Declaration)    : 
      |(Definition)     : 
      |(Reference)      : 50  56
     upper
      |(Class and Type) : module function name, CHARACTER((expression),1)
      |(Attributes)     : PURE
      |(Declaration)    : 
      |(Definition)     : 42
      |(Reference)      : 61
     x
      |(Class and Type) : variable name, CHARACTER(*,1)
      |(Attributes)     : INTENT(IN), dummy-argument
      |(Declaration)    : 42  49
      |(Definition)     : 
      |(Reference)      : 50  55
     y
      |(Class and Type) : variable name, CHARACTER((expression),1)
      |(Attributes)     : result-value
      |(Declaration)    : 42  50
      |(Definition)     : 55  58
      |(Reference)      : 56  57  57  58

 Scoping unit of module sub-program : trimstr
   Attribute and Cross reference of name
     adjustl
      |(Class and Type) : intrinsic function name, CHARACTER((unknown),1)
      |(Attributes)     : PURE, ELEMENTAL
      |(Declaration)    : 
      |(Definition)     : 
      |(Reference)      : 72  74
     len
      |(Class and Type) : intrinsic function name, INTEGER(4)
      |(Attributes)     : PURE
      |(Declaration)    : 
      |(Definition)     : 
      |(Reference)      : 72
     trim
      |(Class and Type) : intrinsic function name, CHARACTER((unknown),1)
      |(Attributes)     : PURE
      |(Declaration)    : 
      |(Definition)     : 
      |(Reference)      : 72  74
     trimstr
      |(Class and Type) : module function name, CHARACTER((expression),1)
      |(Attributes)     : PURE
      |(Declaration)    : 
      |(Definition)     : 64
      |(Reference)      : 75
     x
      |(Class and Type) : variable name, CHARACTER(*,1)
      |(Attributes)     : INTENT(IN), dummy-argument
      |(Declaration)    : 64  71
      |(Definition)     : 
      |(Reference)      : 72  74
     y
      |(Class and Type) : variable name, CHARACTER((expression),1)
      |(Attributes)     : result-value
      |(Declaration)    : 64  72
      |(Definition)     : 74
      |(Reference)      : 

 Scoping unit of module sub-program : istr
   Attribute and Cross reference of name
     istr
      |(Class and Type) : module function name, none
      |(Attributes)     : PURE
      |(Declaration)    : 
      |(Definition)     : 78
      |(Reference)      : 88
     x
      |(Class and Type) : variable name, CHARACTER(*,1)
      |(Attributes)     : INTENT(IN), dummy-argument
      |(Declaration)    : 78  81
      |(Definition)     : 
      |(Reference)      : 
     y
      |(Class and Type) : variable name, none
      |(Attributes)     : result-value
      |(Declaration)    : 78
      |(Definition)     : 
      |(Reference)      : 

 Total information
   Procedures       : 1
   Total lines      : 90
   Total statements : 46


 Lahey/Fujitsu Fortran 95 Compiler Release L8.10b  Sat Feb 12 17:36:58 2022
 Copyright (C) 1994-2008 Lahey Computer Systems.  All rights reserved.
 Copyright (C) 1998-2008 FUJITSU LIMITED. All rights reserved.

 Compilation information
   Current directory : /home/zaikunzhang/Bureau/neupdfo/fsrc/classical/uobyqa
   Source file       : ../../common/linalg.F90
   Cpp options       : -Xs -Dunix -Dx86_64 -D__unix -D__x86_64 -D__ELF__ -D__x86_64__ -D__unix__ -D__linux__ -D__linux -Asystem(unix) -Asystem(posix) -Acpu(x86_64) -Amachine(x86_64) -Dlinux
   Compiler options  : --ap --nblock -c --chk aefosux --chkglobal --nco 
                     : --nconcc --dal --ndbl --nf95 --nfast -g --in --info 
                     : --ninline --li --lst --nlong --maxfatals 50 --nml 
                     : --nmldefault --o0 --no --nocl --nopenmp --nparallel 
                     : --nprefetch --npca --nprivate --nquad --quiet --sav 
                     : --nshared --sse2 --nstaticlink --nswm --nthreadheap 
                     : --nthreads --trace --ntrap --nunroll --nvarheap 
                     : --nvarstack --nversion --warn --nwide --nwisk --wo --zfm 
                     : --xref

 Module "linalg_mod"
  (line-no.)(nest)
          1        #include "ppf.h"
          2        
          3        module linalg_mod
          4        !--------------------------------------------------------------------------------------------------
          5        ! This module provides some basic linear algebra procedures. To improve the performance of
          6        ! these procedures, especially matprod, one can customize their implementations according to the
          7        ! resources (hardware, e.g., cache, and libraries, e.g., BLAS) available and the sizes of the
          8        ! matrices/vectors.
          9        !
         10        ! N.B.
         11        ! When implementing the code by MATLAB, Python, ..., note the following.
         12        ! 1. We should follow the implementation with __USE_POWELL_ALGEBRA__ == 0, which uses matrix/vector
         13        ! operations instead of loops.
         14        ! 2. Most of the subroutines/functions here are better coded inline, because the code is short
         15        ! using matrix/vector operations, and because the overhead of subroutine/function calling can be
         16        ! high in these languages. Here we implement them as subroutines/functions in order to align with
         17        ! Powell's original code, which cannot be translated directly to matrix/vector operations that
         18        ! produce the same results in floating-point arithmetic.
         19        !
         20        ! Coded by Zaikun ZHANG (www.zhangzk.net).
         21        !
         22        ! Started: July 2020
         23        !
         24        ! Last Modified: Tuesday, February 08, 2022 PM09:58:37
         25        !--------------------------------------------------------------------------------------------------
         26        
         27        implicit none
         28        private
         29        ! Mathematically, inprod = dot_product, matprod = matmul
         30        public :: inprod, matprod, outprod
         31        public :: r1update, r2update, symmetrize
         32        public :: Ax_plus_y
         33        public :: eye
         34        public :: hypotenuse, planerot, lsqr
         35        public :: project
         36        public :: inv, isinv
         37        public :: qradd, qrexc
         38        public :: calquad, errquad, hess_mul
         39        public :: omega_col, omega_mul, omega_inprod
         40        public :: errh
         41        public :: isminor
         42        public :: issymmetric, isorth
         43        public :: norm
         44        public :: sort
         45        public :: int
         46        public :: trueloc, falseloc
         47        public :: minimum, maximum
         48        
         49        interface matprod
         50        ! N.B.:
         51        ! 1. When __USE_INTRINSIC_ALGEBRA__ = 0, matprod22(x, y) may differ from matmul(x, y) due to
         52        ! finite-precision arithmetic. This means that the implementation of matmul is not a naive triple
         53        ! loop. The difference has been observed on matprod22 and matprod12. The second case occurred on
         54        ! Oct. 11, 2021 in the trust-region subproblem solver of COBYLA, and it took enormous time to find
         55        ! out that Powell's code and the modernized code behaved differently due to matmul and matprod12
         56        ! when calculating RESMAX (in Powell's code) and CSTRV (in the modernized code) when stage 2 starts.
         57        ! 2. When interfaced with MATLAB, the intrinsic matmul and dot_product seem not as efficient as the
         58        ! implementations below (mostly by loops). This may depend on the machine (e.g., cache size),
         59        ! compiler, compiling options, and MATLAB version.
         60            module procedure matprod12, matprod21, matprod22
         61        end interface matprod
         62        
         63        interface r1update
         64            module procedure r1_sym, r1
         65        end interface r1update
         66        
         67        interface r2update
         68            module procedure r2_sym, r2
         69        end interface r2update
         70        
         71        interface eye
         72            module procedure eye1, eye2
         73        end interface eye
         74        
         75        interface project
         76            module procedure project1, project2
         77        end interface
         78        
         79        interface isminor
         80            module procedure isminor0, isminor1
         81        end interface isminor
         82        
         83        interface sort
         84            module procedure sort_i1, sort_i2
         85        end interface sort
         86        
         87        interface int
         88            module procedure logical_to_int
         89        end interface int
         90        
         91        
         92        contains
         93        
         94        
         95        subroutine r1_sym(A, alpha, x)
         96        ! R1_SYM sets
         97        ! A = A + ALPHA*( X*X^T ),
         98        ! where A is an NxN matrix, ALPHA is a scalar, and X is an N-dimenional vector.
         99        use, non_intrinsic :: consts_mod, only : RP
        100        
        101        #if __USE_POWELL_ALGEBRA__ == 1
        102        use, non_intrinsic :: consts_mod, only : IK
        103        #endif
        104        
        105        #if __DEBUGGING__ == 1
        106        use, non_intrinsic :: debug_mod, only : errstop, assert
        107        #endif
        108        
        109        implicit none
        110        real(RP), intent(in) :: alpha
        111        real(RP), intent(in) :: x(:)
        112        real(RP), intent(inout) :: A(:, :)  ! A(SIZE(X), SIZE(X))
        113        
        114        #if __USE_POWELL_ALGEBRA__ == 1
        115        integer(IK) :: n, j
        116        #endif
        117        
        118        #if __DEBUGGING__ == 1
        119        character(len=*), parameter :: srname = 'R1_SYM'
        120        ! Be careful with initialization!
        121        ! In Fortran >=90, the initialization in the declaration implies the "save" attribute.
        122        ! If the variable is not a parameter, it may cause unwanted behavior.
        123     1  if (size(A, 1) /= size(x) .or. size(A, 2) /= size(x)) then
        124     1      call errstop(srname, 'SIZE(A) is invalid')
        125     1  end if
        126        #endif
        127        
        128        #if __USE_POWELL_ALGEBRA__ == 1
        129        n = int(size(x), kind(n))
        130        ! Only update the LOWER TRIANGULAR part of A. Both of the following cases are invoked in NEWUOA.
        131     1  do j = 1, n
        132     1      A(j:n, j) = A(j:n, j) + alpha * x(j:n) * x(j)
        133     1  end do
        134        call symmetrize(A)  ! Set A(UPPER_TRI) by COPYING A(LOWER_TRI).
        135        #else
        136        ! For some reason, A + alpha*outprod(x,x), A + (outprod(alpha*x, x) + outprod(x, alpha*x))/2,
        137        ! A + symmetrize(x, alpha*x), or A = A + sign(alpha) * outprod(sqrt(|alpha|) * x, sqrt(|alpha|) * x)
        138        ! does not work as well as the following lines for NEWUOA, where SYMMETRIZE should set A(UPPER_TRI)
        139        ! by COPYING A(LOWER_TRI) rather than set A = (A'+A)/2. This is essentially the same as Powell's
        140        ! code, although it computes A(UPPER_TRI) unnecessarily. When X is rather small or large, calculating
        141        ! OUTPROD(X, X) can be a bad idea, even though it guarantees symmetry in finite-precision arithmetic.
        142        A = A + outprod(alpha * x, x)
        143        call symmetrize(A)
        144        #endif
        145        
        146        #if __DEBUGGING__ == 1
        147        call assert(issymmetric(A), 'A is symmetric', srname)
        148        #endif
        149        end subroutine r1_sym
        150        
        151        
        152        subroutine r1(A, alpha, x, y)
        153        ! R1 sets
        154        ! A = A + ALPHA*( X*Y^T ),
        155        ! where A is an MxN matrix, ALPHA is a real scalar, X is an M-dimenional vector, and Y is an
        156        ! N-dimenional vector.
        157        use, non_intrinsic :: consts_mod, only : RP
        158        
        159        #if __DEBUGGING__ == 1
        160        use, non_intrinsic :: debug_mod, only : errstop
        161        #endif
        162        
        163        implicit none
        164        real(RP), intent(in) :: alpha
        165        real(RP), intent(in) :: x(:)
        166        real(RP), intent(in) :: y(:)
        167        real(RP), intent(inout) :: A(:, :)  ! A(SIZE(X), SIZE(Y))
        168        
        169        #if __DEBUGGING__ == 1
        170        character(len=*), parameter :: srname = 'R1'
        171        ! Be careful with initialization!
        172        ! In Fortran >=90, the initialization in the declaration implies the "save" attribute. If the
        173        ! variable is not a parameter, it may cause unwanted behavior.
        174     1  if (size(A, 1) /= size(x) .or. size(A, 2) /= size(y)) then
        175     1      call errstop(srname, 'SIZE(A) is invalid')
        176     1  end if
        177        #endif
        178        
        179        A = A + outprod(alpha * x, y)
        180        !A = A + alpha * outprod(x, y)
        181        end subroutine r1
        182        
        183        
        184        subroutine r2_sym(A, alpha, x, y)
        185        ! R2_SYM sets
        186        ! A = A + ALPHA*( X*Y^T + Y*X^T ),
        187        ! where A is an NxN matrix, X and Y are N-dimenional vectors, and alpha is a scalar.
        188        use, non_intrinsic :: consts_mod, only : RP
        189        
        190        #if __USE_POWELL_ALGEBRA__ == 1
        191        use, non_intrinsic :: consts_mod, only : IK
        192        #endif
        193        
        194        #if __DEBUGGING__ == 1
        195        use, non_intrinsic :: debug_mod, only : errstop, assert
        196        #endif
        197        
        198        implicit none
        199        real(RP), intent(in) :: alpha
        200        real(RP), intent(in) :: x(:)
        201        real(RP), intent(in) :: y(:)
        202        real(RP), intent(inout) :: A(:, :)  ! A(SIZE(X), SIZE(X))
        203        
        204        #if __USE_POWELL_ALGEBRA__ == 1
        205        integer(IK) :: n, j
        206        #endif
        207        
        208        #if __DEBUGGING__ == 1
        209        character(len=*), parameter :: srname = 'R2_SYM'
        210     1  if (size(x) /= size(y)) then
        211     1      call errstop(srname, 'SIZE(X) /= SIZE(Y)')
        212     1  end if
        213     1  if (size(A, 1) /= size(x) .or. size(A, 2) /= size(x)) then
        214     1      call errstop(srname, 'SIZE(A) is invalid')
        215     1  end if
        216        #endif
        217        
        218        
        219        #if __USE_POWELL_ALGEBRA__ == 1
        220        n = int(size(x), kind(n))
        221     1  do j = 1, n
        222     1      A(j:n, j) = A(j:n, j) + alpha * x(j:n) * y(j) + alpha * y(j:n) * x(j)
        223     1  end do
        224        ! Set A(UPPER_TRI) by copying A(LOWER_TRI).
        225        call symmetrize(A)
        226        #else
        227        ! For some reason, A = A + ALPHA * (OUTPROD(X, Y) + OUTPROD(Y, X)) does not work as well as the
        228        ! following lines for NEWUOA, where SYMMETRIZE should set A(UPPER_TRI) by copying A(LOWER_TRI),
        229        ! although ALPHA*( X*Y^T + Y*X^T) is guaranteed symmetric even in floating-point arithmetic. These
        230        ! lines are essentially the same as Powell's code, although it calculates A(UPPER_TRI) unnecessarily.
        231        A = A + outprod(alpha * x, y) + outprod(alpha * y, x)
        232        call symmetrize(A)
        233        #endif
        234        
        235        #if __DEBUGGING__ == 1
        236        call assert(issymmetric(A), 'A is symmetric', srname)
        237        #endif
        238        end subroutine r2_sym
        239        
        240        
        241        subroutine r2(A, alpha, x, y, beta, u, v)
        242        ! R2 sets
        243        ! A = A + ( ALPHA*( X*Y^T ) + BETA*( U*V^T ) ),
        244        ! where A is an MxN matrix, ALPHA and BETA are real scalars, X and U are M-dimenional vectors,
        245        ! Y and V are N-dimenional vectors.
        246        use, non_intrinsic :: consts_mod, only : RP
        247        
        248        #if __DEBUGGING__ == 1
        249        use, non_intrinsic :: debug_mod, only : errstop
        250        #endif
        251        
        252        implicit none
        253        real(RP), intent(in) :: alpha
        254        real(RP), intent(in) :: beta
        255        real(RP), intent(in) :: x(:)
        256        real(RP), intent(in) :: y(:)
        257        real(RP), intent(in) :: u(:)          ! U(SIZE(X))
        258        real(RP), intent(in) :: v(:)          ! V(SIZE(Y))
        259        real(RP), intent(inout) :: A(:, :)    ! A(SIZE(X), SIZE(Y))
        260        
        261        
        262        #if __DEBUGGING__ == 1
        263        character(len=*), parameter :: srname = 'R2'
        264     1  if (size(u) /= size(x)) then
        265     1      call errstop(srname, 'SIZE(U) /= SIZE(X)')
        266     1  end if
        267     1  if (size(v) /= size(y)) then
        268     1      call errstop(srname, 'SIZE(V) /= SIZE(Y)')
        269     1  end if
        270     1  if (size(A, 1) /= size(x) .or. size(A, 2) /= size(y)) then
        271     1      call errstop(srname, 'SIZE(A) is invalid')
        272     1  end if
        273        #endif
        274        
        275        A = A + outprod(alpha * x, y) + outprod(beta * u, v)
        276        !A = A + (alpha * outprod(x, y) + beta * outprod(u, v))
        277        end subroutine r2
        278        
        279        
        280        function matprod12(x, y) result(z)
        281        
        282        #if __USE_INTRINSIC_ALGEBRA__ == 1
        283        use, non_intrinsic :: consts_mod, only : RP
        284        #else
        285        use, non_intrinsic :: consts_mod, only : RP, IK
        286        #endif
        287        
        288        #if __DEBUGGING__ == 1
        289        use, non_intrinsic :: debug_mod, only : errstop
        290        #endif
        291        
        292        implicit none
        293        real(RP), intent(in) :: x(:)
        294        real(RP), intent(in) :: y(:, :)
        295        real(RP) :: z(size(y, 2))
        296        
        297        #if __USE_INTRINSIC_ALGEBRA__ == 0
        298        integer(IK) :: j
        299        #endif
        300        
        301        #if __DEBUGGING__ == 1
        302        character(len=*), parameter :: srname = 'MATPROD12'
        303     1  if (size(x) /= size(y, 1)) then
        304     1      call errstop(srname, 'SIZE(X) /= SIZE(Y, 1)')
        305     1  end if
        306        #endif
        307        
        308        #if __USE_INTRINSIC_ALGEBRA__ == 1
        309        z = matmul(x, y)
        310        #else
        311     1  do j = 1, int(size(y, 2), kind(j))
        312     1      ! When interfaced with MATLAB, the following seems more efficient than a loop, which is strange
        313     1      ! since inprod itself is implemented by a loop. This may depend on the machine (e.g., cache
        314     1      ! size), compiler, compiling options, and MATLAB version.
        315     1      z(j) = inprod(x, y(:, j))
        316     1  end do
        317        #endif
        318        end function matprod12
        319        
        320        
        321        function matprod21(x, y) result(z)
        322        
        323        #if __USE_INTRINSIC_ALGEBRA__ == 1
        324        use, non_intrinsic :: consts_mod, only : RP
        325        #else
        326        use, non_intrinsic :: consts_mod, only : RP, IK, ZERO
        327        #endif
        328        
        329        #if __DEBUGGING__ == 1
        330        use, non_intrinsic :: debug_mod, only : errstop
        331        #endif
        332        
        333        implicit none
        334        real(RP), intent(in) :: x(:, :)
        335        real(RP), intent(in) :: y(:)
        336        real(RP) :: z(size(x, 1))
        337        
        338        #if __USE_INTRINSIC_ALGEBRA__ == 0
        339        integer(IK) :: j
        340        #endif
        341        
        342        #if __DEBUGGING__ == 1
        343        character(len=*), parameter :: srname = 'MATPROD21'
        344     1  if (size(x, 2) /= size(y)) then
        345     1      call errstop(srname, 'SIZE(X, 2) /= SIZE(Y)')
        346     1  end if
        347        #endif
        348        
        349        #if __USE_INTRINSIC_ALGEBRA__ == 1
        350        z = matmul(x, y)
        351        #else
        352        z = ZERO
        353     1  do j = 1, int(size(x, 2), kind(j))
        354     1      z = z + x(:, j) * y(j)
        355     1  end do
        356        #endif
        357        end function matprod21
        358        
        359        
        360        function matprod22(x, y) result(z)
        361        ! N.B.: When __USE_INTRINSIC_ALGEBRA__ = 0, matprod22(x, y) may differ from matmul(x, y) due to
        362        ! finite-precision arithmetic. This means that the implementation of matmul is not a naive triple
        363        ! loop. Of course, the implementation depends on the platform.
        364        
        365        #if __USE_INTRINSIC_ALGEBRA__ == 1
        366        use, non_intrinsic :: consts_mod, only : RP
        367        #else
        368        use, non_intrinsic :: consts_mod, only : RP, IK, ZERO
        369        #endif
        370        
        371        #if __DEBUGGING__ == 1
        372        use, non_intrinsic :: debug_mod, only : errstop
        373        #endif
        374        
        375        implicit none
        376        real(RP), intent(in) :: x(:, :)
        377        real(RP), intent(in) :: y(:, :)
        378        real(RP) :: z(size(x, 1), size(y, 2))
        379        
        380        #if __USE_INTRINSIC_ALGEBRA__ == 0
        381        integer(IK) :: i, j
        382        #endif
        383        
        384        #if __DEBUGGING__ == 1
        385        character(len=*), parameter :: srname = 'MATPROD22'
        386     1  if (size(x, 2) /= size(y, 1)) then
        387     1      call errstop(srname, 'SIZE(X, 2) /= SIZE(Y, 1)')
        388     1  end if
        389        #endif
        390        
        391        #if __USE_INTRINSIC_ALGEBRA__ == 1
        392        z = matmul(x, y)
        393        #else
        394        z = ZERO
        395     1  do j = 1, int(size(y, 2), kind(j))
        396     2      do i = 1, int(size(x, 2), kind(i))
        397     2          z(:, j) = z(:, j) + x(:, i) * y(i, j)
        398     2      end do
        399     1  end do
        400        #endif
        401        end function matprod22
        402        
        403        
        404        function inprod(x, y) result(z)
        405        
        406        #if __USE_INTRINSIC_ALGEBRA__ == 1
        407        use, non_intrinsic :: consts_mod, only : RP
        408        #else
        409        use, non_intrinsic :: consts_mod, only : RP, IK, ZERO
        410        #endif
        411        
        412        #if __DEBUGGING__ == 1
        413        use, non_intrinsic :: debug_mod, only : errstop
        414        #endif
        415        
        416        implicit none
        417        real(RP), intent(in) :: x(:)
        418        real(RP), intent(in) :: y(:)
        419        real(RP) :: z
        420        
        421        #if __USE_INTRINSIC_ALGEBRA__ == 0
        422        integer(IK) :: i
        423        #endif
        424        
        425        #if __DEBUGGING__ == 1
        426        character(len=*), parameter :: srname = 'INPROD'
        427     1  if (size(x) /= size(y)) then
        428     1      call errstop(srname, 'SIZE(X) /= SIZE(Y)')
        429     1  end if
        430        #endif
        431        
        432        #if __USE_INTRINSIC_ALGEBRA__ == 1
        433        z = dot_product(x, y)
        434        #else
        435        !z = sum(x*y)
        436        ! Using sum seems not as efficient as a loop when interfaced with MATLAB, but this may depend
        437        ! on the machine (e.g., cache size), compiler, compiling options, and MATLAB version.
        438        z = ZERO
        439     1  do i = 1, int(size(x), kind(i))
        440     1      z = z + x(i) * y(i)
        441     1  end do
        442        #endif
        443        end function inprod
        444        
        445        function outprod(x, y) result(z)
        446        ! OUTPROD calculates the outer product of X and Y, i.e., Z = X*Y^T, regarding both X and Y as columns
        447        use, non_intrinsic :: consts_mod, only : RP, IK
        448        implicit none
        449        ! Input
        450        real(RP), intent(in) :: x(:)
        451        real(RP), intent(in) :: y(:)
        452        ! Output
        453        real(RP) :: z(size(x), size(y))
        454        
        455        integer(IK) :: i
        456     1  do i = 1, int(size(y), kind(i))
        457     1      z(:, i) = x * y(i)
        458     1  end do
        459        end function outprod
        460        
        461        
        462        pure function eye1(n) result(x)
        463        !--------------------------------------------------------------------------------------------------!
        464        ! EYE1 is the univariate case of EYE, a function similar to the MATLAB function with the same name.
        465        !--------------------------------------------------------------------------------------------------!
        466        use, non_intrinsic :: consts_mod, only : RP, IK, ZERO, ONE
        467        implicit none
        468        ! Inputs
        469        integer(IK), intent(in) :: n
        470        ! Outputs
        471        real(RP) :: x(max(n, 0_IK), max(n, 0_IK))
        472        ! Local variables
        473        integer(IK) :: i
        474     1  if (size(x, 1) * size(x, 2) > 0) then
        475     1      x = ZERO
        476     2      do i = 1, int(min(size(x, 1), size(x, 2)), kind(i))
        477     2          x(i, i) = ONE
        478     2      end do
        479     1  end if
        480        end function eye1
        481        
        482        
        483        pure function eye2(m, n) result(x)
        484        !--------------------------------------------------------------------------------------------------!
        485        ! EYE2 is the bivariate case of EYE, a function similar to the MATLAB function with the same name.
        486        !--------------------------------------------------------------------------------------------------!
        487        use, non_intrinsic :: consts_mod, only : RP, IK, ZERO, ONE
        488        implicit none
        489        ! Inputs
        490        integer(IK), intent(in) :: m
        491        integer(IK), intent(in) :: n
        492        ! Outputs
        493        real(RP) :: x(max(m, 0_IK), max(n, 0_IK))
        494        ! Local variables
        495        integer(IK) :: i
        496     1  if (size(x, 1) * size(x, 2) > 0) then
        497     1      x = ZERO
        498     2      do i = 1, int(min(size(x, 1), size(x, 2)), kind(i))
        499     2          x(i, i) = ONE
        500     2      end do
        501     1  end if
        502        end function eye2
        503        
        504        
        505        function inv(A) result(B)
        506        !--------------------------------------------------------------------------------------------------!
        507        ! This function calculates the inverse of a matrix A, which is ASSUMED TO BE SMALL AND INVERTIBLE.
        508        ! The function is implemented NAIVELY. It is NOT coded for general purposes but only for the usage
        509        ! in this project. Indeed, only the lower triangular case is used.
        510        ! TODO: extend this function to calculate the pseudo inverse of any matrix of full rank. Better to
        511        ! implement it into several subfunctions: triu with M >= N, tril with M <= N; general with M >= N,
        512        ! general with M <= N, etc.
        513        !--------------------------------------------------------------------------------------------------!
        514        use, non_intrinsic :: consts_mod, only : RP, IK, ZERO, ONE, EPS, DEBUGGING
        515        use, non_intrinsic :: debug_mod, only : assert
        516        implicit none
        517        
        518        ! Inputs
        519        real(RP), intent(in) :: A(:, :)
        520        
        521        ! Outputs
        522        real(RP) :: B(size(A, 1), size(A, 1))
        523        
        524        ! Local variables
        525        character(len=*), parameter :: srname = 'INV'
        526        integer(IK) :: P(size(A, 1))
        527        integer(IK) :: PI(size(A, 1))
        528        integer(IK) :: i
        529        integer(IK) :: n
        530        real(RP) :: Q(size(A, 1), size(A, 1))
        531        real(RP) :: R(size(A, 1), size(A, 1))
        532        real(RP) :: tol
        533        
        534        ! Sizes
        535        n = int(size(A, 1), kind(n))
        536        
        537        ! Preconditions
        538     1  if (DEBUGGING) then
        539     1      call assert(size(A, 1) == size(A, 2), 'A is squre', srname)
        540     1  end if
        541        
        542        !====================!
        543        ! Calculation starts !
        544        !====================!
        545        
        546     1  if (istril(A)) then
        547     1      ! This case is invoked in COBYLA.
        548     1      R = transpose(A)  ! Take transpose to work on columns.
        549     1      B = ZERO
        550     2      do i = 1, n
        551     2          B(i, i) = ONE / R(i, i)
        552     2          B(1:i - 1, i) = -matprod(B(1:i - 1, 1:i - 1), R(1:i - 1, i) / R(i, i))
        553     2      end do
        554     1      B = transpose(B)
        555     1  elseif (istriu(A)) then
        556     1      B = ZERO
        557     2      do i = 1, n
        558     2          B(i, i) = ONE / A(i, i)
        559     2          B(1:i - 1, i) = -matprod(B(1:i - 1, 1:i - 1), A(1:i - 1, i) / A(i, i))
        560     2      end do
        561     1  else
        562     1      ! This is NOT the best algorithm for INV, but since the QR subroutine is available ...
        563     1      call qr(A, Q, R, P)
        564     1      R = transpose(R)  ! Take transpose to work on columns.
        565     2      do i = n, 1, -1
        566     2          B(:, i) = (Q(:, i) - matprod(B(:, i + 1:n), R(i + 1:n, i))) / R(i, i)
        567     2      end do
        568     1      PI(P) = [(i, i=1, n)]  ! The inverse permutation
        569     1      B = transpose(B(:, PI))
        570     1  end if
        571        
        572        !====================!
        573        !  Calculation ends  !
        574        !====================!
        575        
        576        ! Postconditions
        577     1  if (DEBUGGING) then
        578     1      call assert(size(B, 1) == n .and. size(B, 2) == n, 'SIZE(B) == [N, N]', srname)
        579     1      call assert(istril(B) .or. .not. istril(A), 'If A is lower triangular, then so is B', srname)
        580     1      call assert(istriu(B) .or. .not. istriu(A), 'If A is upper triangular, then so is B', srname)
        581     1      tol = max(1.0E-10_RP, min(1.0E-3_RP, 1.0E6_RP * EPS * real(n + 1_IK, RP)))
        582     1      call assert(isinv(A, B, tol), 'B = A^{-1}', srname)
        583     1  end if
        584        
        585        end function inv
        586        
        587        
        588        function isinv(A, B, tol) result(is_inv)
        589        use, non_intrinsic :: consts_mod, only : RP, IK, EPS, DEBUGGING
        590        use, non_intrinsic :: debug_mod, only : assert
        591        implicit none
        592        
        593        ! Inputs
        594        real(RP), intent(in) :: A(:, :)
        595        real(RP), intent(in) :: B(:, :)
        596        real(RP), intent(in), optional :: tol
        597        
        598        ! Outputs
        599        logical :: is_inv
        600        
        601        ! Local variables
        602        character(len=*), parameter :: srname = 'ISINV'
        603        real(RP) :: tol_loc
        604        integer(IK) :: n
        605        
        606        ! Sizes
        607        n = int(size(A, 1), kind(n))
        608        
        609        ! Preconditions
        610     1  if (DEBUGGING) then
        611     1      call assert(size(A, 1) == size(A, 2), 'A is suqare', srname)
        612     1      call assert(size(B, 1) == size(B, 2), 'B is suqare', srname)
        613     1      call assert(size(A, 1) == size(B, 1), 'SIZE(A) == SIZE(B)', srname)
        614     1  end if
        615        
        616     1  if (present(tol)) then
        617     1      tol_loc = tol
        618     1  else
        619     1      tol_loc = min(1.0E-3_RP, 1.0E2_RP * EPS * real(max(size(A, 1), size(A, 2)), RP))
        620     1  end if
        621        tol_loc = maxval([tol_loc, tol_loc * maxval(abs(A)), tol_loc * maxval(abs(B))])
        622        
        623        is_inv = all(abs(matprod(A, B) - eye(n)) <= tol_loc) .or. all(abs(matprod(B, A) - eye(n)) <= tol_loc)
        624        end function isinv
        625        
        626        
        627        subroutine qr(A, Q, R, P)
        628        !--------------------------------------------------------------------------------------------------!
        629        ! This subroutine calculates the QR factorization of A, possibly with column pivoting, so that
        630        ! A = Q*R (if no pivoting) or A(:, P) = Q*R (if pivoting), where the columns of Q are orthonormal,
        631        ! and R is upper triangular.
        632        !--------------------------------------------------------------------------------------------------!
        633        use, non_intrinsic :: consts_mod, only : RP, IK, ZERO, EPS, DEBUGGING
        634        use, non_intrinsic :: debug_mod, only : assert
        635        implicit none
        636        
        637        ! Inputs
        638        real(RP), intent(in) :: A(:, :)
        639        
        640        ! Outputs
        641        real(RP), intent(out), optional :: Q(:, :)
        642        real(RP), intent(out), optional :: R(:, :)
        643        integer(IK), intent(out), optional :: P(:)
        644        
        645        ! Local variables
        646        character(len=*), parameter :: srname = 'QR'
        647        logical :: pivote
        648        integer(IK) :: i
        649        integer(IK) :: j
        650        integer(IK) :: k
        651        integer(IK) :: m
        652        integer(IK) :: n
        653        real(RP) :: G(2, 2)
        654        real(RP) :: Q_loc(size(A, 1), size(A, 1))
        655        real(RP) :: T(size(A, 2), size(A, 1))
        656        real(RP) :: tol
        657        
        658     1  if (.not. (present(Q) .or. present(R) .or. present(R))) then
        659     1      return
        660     1  end if
        661        
        662        ! Sizes
        663        m = int(size(A, 1), kind(m))
        664        n = int(size(A, 2), kind(n))
        665        
        666        ! Preconditions
        667     1  if (DEBUGGING) then
        668     2      if (present(Q)) then
        669     2          call assert(size(Q, 1) == m .and. (size(Q, 2) == m .or. size(Q, 2) == min(m, n)), &
        670     2              & 'SIZE(Q) == [M, N] .or. SIZE(Q) == [M, MIN(M, N)]', srname)
        671     2      end if
        672     2      if (present(R)) then
        673     2          call assert((size(R, 1) == m .or. size(R, 1) == min(m, n)) .and. size(R, 2) == n, &
        674     2              & 'SIZE(R) == [M, N] .or. SIZE(R) == [MIN(M, N), N]', srname)
        675     2      end if
        676     2      if (present(Q) .and. present(R)) then
        677     2          call assert(size(Q, 2) == size(R, 1), 'SIZE(Q, 2) == SIZE(R, 1)', srname)
        678     2      end if
        679     2      if (present(P)) then
        680     2          call assert(size(P) == n, 'SIZE(P) == N', srname)
        681     2      end if
        682     1  end if
        683        
        684        !====================!
        685        ! Calculation starts !
        686        !====================!
        687        
        688        pivote = (present(P))
        689        Q_loc = eye(m)
        690        T = transpose(A)  ! T is the transpose of R. We consider T in order to work on columns.
        691     1  if (pivote) then
        692     1      P = [(j, j=1, n)]
        693     1  end if
        694        
        695     1  do j = 1, n
        696     2      if (pivote) then
        697     2          k = int(maxloc(sum(T(j:n, j:m)**2, dim=2), dim=1), kind(k))
        698     3          if (k > 1 .and. k <= n - j + 1) then
        699     3              k = k + j - 1_IK
        700     3              P([j, k]) = P([k, j])
        701     3              T([j, k], :) = T([k, j], :)
        702     3          end if
        703     2      end if
        704     2      do i = m, j + 1_IK, -1_IK
        705     2          G = transpose(planerot(T(j, [j, i])))
        706     2          T(j, [j, i]) = [hypotenuse(T(j, j), T(j, i)), ZERO]
        707     2          !T(j, [j, i]) = [sqrt(T(j, j)**2 + T(j, i)**2), ZERO]
        708     2          T(j + 1:n, [j, i]) = matprod(T(j + 1:n, [j, i]), G)
        709     2          Q_loc(:, [j, i]) = matprod(Q_loc(:, [j, i]), G)
        710     2      end do
        711     1  end do
        712        
        713     1  if (present(Q)) then
        714     1      Q = Q_loc(:, 1:size(Q, 2))
        715     1  end if
        716     1  if (present(R)) then
        717     1      R = transpose(T(:, 1:size(R, 1)))
        718     1  end if
        719        
        720        ! Postconditions
        721     1  if (DEBUGGING) then
        722     1      tol = max(1.0E-10_RP, min(1.0E-1_RP, 1.0E4_RP * EPS * real(max(m, n) + 1_IK, RP)))
        723     1      call assert(isorth(Q_loc, tol), 'The columns of Q are orthonormal', srname)
        724     1      call assert(istril(T, tol), 'R is upper triangular', srname)
        725     2      if (pivote) then
        726     2          call assert(all(abs(matprod(Q_loc, transpose(T)) - A(:, P)) <= &
        727     2                          max(tol, tol * maxval(abs(A)))), 'A(:, P) == Q*R', srname)
        728     3          do j = 1, min(m, n) - 1_IK
        729     3              call assert(abs(T(j, j)) + max(tol, tol * abs(T(j, j))) >= &
        730     3                  & abs(T(j + 1, j + 1)), '|R(J, J)| >= |R(J + 1, J + 1)|', srname)
        731     3              call assert(all(T(j, j)**2 + max(tol, tol * T(j, j)**2) >= &
        732     3                  & sum(T(j + 1:n, j:min(m, n))**2, dim=2)), &
        733     3                  & 'R(J, J)^2 >= SUM(R(J : MIN(M, N), J + 1 : N).^2', srname)
        734     3          end do
        735     2      else
        736     2          call assert(all(abs(matprod(Q_loc, transpose(T)) - A) <= max(tol, tol * maxval(abs(A)))), &
        737     2              & 'A == Q*R', srname)
        738     2      end if
        739     1  end if
        740        end subroutine qr
        741        
        742        
        743        function lsqr(A, b, Q, Rdiag) result(x)
        744        !--------------------------------------------------------------------------------------------------!
        745        ! This function solves the linear least squares problem min ||A*x - b||_2 by the QR factorization.
        746        ! This function is used in COBYLA, where,
        747        ! 1. Q is supplied externally (called Z);
        748        ! 2. Rdiag (the diagonal of R) is supplied externally (called ZDOTA);
        749        ! 3. A HAS FULL COLUMN RANK;
        750        ! 4. It seems that b (CGRAD and DNEW) is in the column space of A (not sure yet).
        751        !--------------------------------------------------------------------------------------------------!
        752        use, non_intrinsic :: consts_mod, only : RP, IK, ZERO, EPS, DEBUGGING
        753        use, non_intrinsic :: debug_mod, only : assert
        754        implicit none
        755        
        756        ! Inputs
        757        real(RP), intent(in) :: A(:, :)
        758        real(RP), intent(in) :: b(:)
        759        real(RP), intent(in), optional :: Q(:, :)
        760        real(RP), intent(in), optional :: Rdiag(:)
        761        
        762        ! Outputs
        763        real(RP) :: x(size(A, 2))
        764        
        765        ! Local variables
        766        character(len=*), parameter :: srname = 'LSQR'
        767        logical :: pivote
        768        integer(IK) :: i
        769        integer(IK) :: j
        770        integer(IK) :: m
        771        integer(IK) :: n
        772        integer(IK) :: P(size(A, 2))
        773        integer(IK) :: rank
        774        real(RP) :: Q_loc(size(A, 1), min(size(A, 1), size(A, 2)))
        775        real(RP) :: Rdiag_loc(min(size(A, 1), size(A, 2)))
        776        real(RP) :: tol
        777        real(RP) :: y(size(b))
        778        real(RP) :: yq
        779        real(RP) :: yqa
        780        
        781        ! Sizes
        782        m = int(size(A, 1), kind(m))
        783        n = int(size(A, 2), kind(n))
        784        
        785        ! Preconditions
        786     1  if (DEBUGGING) then
        787     1      call assert(size(b) == m, 'SIZE(B) == M', srname)
        788     2      if (present(Q)) then
        789     2          call assert(size(Q, 1) == m .and. (size(Q, 2) == m .or. size(Q, 2) == min(m, n)), &
        790     2              & 'SIZE(Q) == [M, N] .or. SIZE(Q) == [M, MIN(M, N)]', srname)
        791     2          tol = max(1.0E-10_RP, min(1.0E-1_RP, 1.0E6_RP * EPS * real(max(m, n) + 1_IK, RP)))
        792     2          call assert(isorth(Q, tol), 'The columns of Q are orthogonal', srname)
        793     2      end if
        794     2      if (present(Rdiag)) then
        795     2          call assert(size(Rdiag) == min(m, n), 'SIZE(R) == MIN(M, N)', srname)
        796     2          call assert(present(Q), 'Rdiag is present only if Q is present', srname)
        797     2      end if
        798     1  end if
        799        
        800        !====================!
        801        ! Calculation starts !
        802        !====================!
        803        
        804     1  if (present(Q)) then
        805     1      Q_loc = Q(:, 1:size(Q_loc, 2))
        806     2      if (present(Rdiag)) then
        807     2          Rdiag_loc = Rdiag
        808     2      else
        809     2          Rdiag_loc = [(inprod(Q_loc(:, i), A(:, i)), i=1, min(m, n))]
        810     2      end if
        811     1      rank = min(m, n)
        812     1      pivote = .false.
        813     1  end if
        814        
        815        !if (.not. present(Q) .or. any(abs(Rdiag_loc) <= ZERO)) then  ! This is more reasonable
        816     1  if (.not. present(Q)) then
        817     1      call qr(A, Q=Q_loc, P=P)
        818     1      Rdiag_loc = [(inprod(Q_loc(:, i), A(:, P(i))), i=1, min(m, n))]
        819     1      rank = maxval([0_IK, trueloc(abs(Rdiag_loc) > 0)])
        820     1      pivote = .true.
        821     1  end if
        822        
        823        x = ZERO
        824        y = b  ! Local copy of B; B is INTENT(IN) and should not be modified.
        825        
        826     1  do i = rank, 1, -1
        827     2      if (pivote) then
        828     2          j = P(i)
        829     2      else
        830     2          j = i
        831     2      end if
        832     1      ! The following IF comes from Powell. It forces X(J) = 0 if deviations from this value can be
        833     1      ! attributed to computer rounding errors. This is a favorable choice in the context of COBYLA.
        834     1      yq = inprod(y, Q_loc(:, i))
        835     1      yqa = inprod(abs(y), abs(Q_loc(:, i)))
        836     2      if (isminor(yq, yqa)) then
        837     2          x(j) = ZERO
        838     2      else
        839     2          x(j) = yq / Rdiag_loc(i)
        840     2          y = y - x(j) * A(:, j)
        841     2      end if
        842     1  end do
        843        
        844        !====================!
        845        !  Calculation ends  !
        846        !====================!
        847        
        848        !! Postconditions
        849        !if (DEBUGGING) then
        850        !    ! The following test cannot be passed.
        851        !    !call assert(norm(matprod(b - matprod(A, x), A)) <= max(tol, tol * norm(matprod(b, A))), &
        852        !    !    & 'A*X is the projection of B to the column space of A', srname)
        853        !end if
        854        end function lsqr
        855        
        856        
        857        function diag(A) result(D)
        858        !--------------------------------------------------------------------------------------------------!
        859        ! This function takes the main diagonal of the matrix A.
        860        !--------------------------------------------------------------------------------------------------!
        861        use, non_intrinsic :: consts_mod, only : RP, IK
        862        implicit none
        863        ! Inputs
        864        real(RP), intent(in) :: A(:, :)
        865        ! Outputs
        866        real(RP) :: D(min(size(A, 1), size(A, 2)))
        867        ! Local variables
        868        integer(IK) :: i
        869        D = [(A(i, i), i=1, int(size(D), IK))]
        870        end function diag
        871        
        872        
        873        function istril(A, tol) result(is_tril)
        874        !--------------------------------------------------------------------------------------------------!
        875        ! This function tests whether the matrix A is lower triangular up to the tolerance TOL.
        876        !--------------------------------------------------------------------------------------------------!
        877        use, non_intrinsic :: consts_mod, only : RP, IK, ZERO
        878        implicit none
        879        ! Inputs
        880        real(RP), intent(in) :: A(:, :)
        881        real(RP), intent(in), optional :: tol
        882        
        883        ! Outputs
        884        logical :: is_tril
        885        
        886        ! Local variables
        887        integer(IK) :: i
        888        integer(IK) :: m
        889        integer(IK) :: n
        890        real(RP) :: tol_loc
        891        
        892     1  if (present(tol)) then
        893     1      tol_loc = max(tol, tol * maxval(abs(A)))
        894     1  else
        895     1      tol_loc = ZERO
        896     1  end if
        897        m = int(size(A, 1), kind(m))
        898        n = int(size(A, 2), kind(n))
        899        is_tril = .true.
        900     1  do i = 1, min(m, n)
        901     2      if (any(abs(A(1:i - 1, i)) > tol_loc)) then
        902     2          is_tril = .false.
        903     2          exit
        904     2      end if
        905     1  end do
        906        end function istril
        907        
        908        
        909        function istriu(A, tol) result(is_triu)
        910        !--------------------------------------------------------------------------------------------------!
        911        ! This function tests whether the matrix A is upper triangular up to the tolerance TOL.
        912        !--------------------------------------------------------------------------------------------------!
        913        use, non_intrinsic :: consts_mod, only : RP, IK, ZERO
        914        implicit none
        915        ! Inputs
        916        real(RP), intent(in) :: A(:, :)
        917        real(RP), intent(in), optional :: tol
        918        
        919        ! Outputs
        920        logical :: is_triu
        921        
        922        ! Local variables
        923        integer(IK) :: i
        924        integer(IK) :: m
        925        integer(IK) :: n
        926        real(RP) :: tol_loc
        927        
        928     1  if (present(tol)) then
        929     1      tol_loc = max(tol, tol * maxval(abs(A)))
        930     1  else
        931     1      tol_loc = ZERO
        932     1  end if
        933        m = int(size(A, 1), kind(m))
        934        n = int(size(A, 2), kind(n))
        935        is_triu = .true.
        936     1  do i = 1, min(m, n)
        937     2      if (any(abs(A(i + 1:m, i)) > tol_loc)) then
        938     2          is_triu = .false.
        939     2          exit
        940     2      end if
        941     1  end do
        942        end function istriu
        943        
        944        
        945        function isorth(A, tol) result(is_orth)
        946        !--------------------------------------------------------------------------------------------------!
        947        ! This function tests whether the matrix A has orthonormal columns up to the tolerance TOL.
        948        !--------------------------------------------------------------------------------------------------!
        949        use, non_intrinsic :: consts_mod, only : RP, IK
        950        implicit none
        951        ! Inputs
        952        real(RP), intent(in) :: A(:, :)
        953        real(RP), intent(in), optional :: tol
        954        
        955        ! Outputs
        956        logical :: is_orth
        957        
        958        ! Local variables
        959        integer(IK) :: n
        960        
        961        n = int(size(A, 2), kind(n))
        962        
        963     1  if (n > size(A, 1)) then
        964     1      is_orth = .false.
        965     1  else
        966     2      if (present(tol)) then
        967     2          is_orth = all(abs(matprod(transpose(A), A) - eye(n)) <= max(tol, tol * maxval(abs(A))))
        968     2      else
        969     2          is_orth = all(abs(matprod(transpose(A), A) - eye(n)) <= 0)
        970     2      end if
        971     1  end if
        972        end function isorth
        973        
        974        
        975        function project1(x, v) result(y)
        976        !--------------------------------------------------------------------------------------------------!
        977        ! This function returns the projection of X to SPAN(V).
        978        !--------------------------------------------------------------------------------------------------!
        979        use, non_intrinsic :: consts_mod, only : RP, ONE, ZERO, EPS, DEBUGGING
        980        use, non_intrinsic :: debug_mod, only : assert
        981        use, non_intrinsic :: infnan_mod, only : is_inf, is_finite, is_nan
        982        implicit none
        983        
        984        ! Inputs
        985        real(RP), intent(in) :: x(:)
        986        real(RP), intent(in) :: v(:)
        987        
        988        ! Outputs
        989        real(RP) :: y(size(x))
        990        
        991        ! Local variables
        992        character(len=*), parameter :: srname = 'PROJECT1'
        993        real(RP) :: u(size(v))
        994        real(RP) :: scaling
        995        real(RP) :: tol
        996        
        997        ! Preconditions
        998     1  if (DEBUGGING) then
        999     1      call assert(size(x) == size(v), 'SIZE(X) == SIZE(V)', srname)
       1000     1  end if
       1001        
       1002        !====================!
       1003        ! Calculation starts !
       1004        !====================!
       1005        
       1006     1  if (all(abs(x) <= ZERO) .or. all(abs(v) <= ZERO)) then
       1007     1      y = ZERO
       1008     1  elseif (any(is_nan(x)) .or. any(is_nan(v))) then
       1009     1      y = sum(x) + sum(v)  ! Set Y to NaN
       1010     1  elseif (any(is_inf(v))) then
       1011     1      where (is_inf(v))
       1012     1          u = sign(ONE, v)
       1013     1      elsewhere
       1014     1          u = ZERO
       1015     1      end where
       1016     1      u = u / norm(u)
       1017     1  !    y = inprod(x, u) * u
       1018     1      scaling = maxval(abs(x))  ! The scaling seems to reduce the rounding error.
       1019     1      y = scaling * inprod(x / scaling, u) * u
       1020     1  else
       1021     1      u = v / norm(v)
       1022     1  !    y = inprod(x, u) * u
       1023     1      scaling = maxval(abs(x))  ! The scaling seems to reduce the rounding error.
       1024     1      y = scaling * inprod(x / scaling, u) * u
       1025     1  end if
       1026        
       1027        !====================!
       1028        !  Calculation ends  !
       1029        !====================!
       1030        
       1031        ! Postconditions
       1032     1  if (DEBUGGING) then
       1033     2      if (is_finite(norm(x)) .and. is_finite(norm(v))) then
       1034     2          tol = max(1.0E-10_RP, min(1.0E-1_RP, 1.0E6_RP * EPS))
       1035     2          call assert(norm(y) <= (ONE + tol) * norm(x), 'NORM(Y) <= NORM(X)', srname)
       1036     2          call assert(norm(x - y) <= (ONE + tol) * norm(x), 'NORM(X - Y) <= NORM(X)', srname)
       1037     2          ! The following test may not be passed.
       1038     2          call assert(abs(inprod(x - y, v)) <= max(tol, tol * max(norm(x - y) * norm(v), abs(inprod(x, v)))), &
       1039     2             & 'X - Y is orthogonal to V', srname)
       1040     2      end if
       1041     1  end if
       1042        end function project1
       1043        
       1044        
       1045        function project2(x, V) result(y)
       1046        !--------------------------------------------------------------------------------------------------!
       1047        ! This function returns the projection of X to RANGE(V).
       1048        !--------------------------------------------------------------------------------------------------!
       1049        use, non_intrinsic :: consts_mod, only : RP, ONE, ZERO, EPS, DEBUGGING
       1050        use, non_intrinsic :: debug_mod, only : assert
       1051        use, non_intrinsic :: infnan_mod, only : is_inf, is_finite, is_nan
       1052        implicit none
       1053        
       1054        ! Inputs
       1055        real(RP), intent(in) :: x(:)
       1056        real(RP), intent(in) :: V(:, :)
       1057        
       1058        ! Outputs
       1059        real(RP) :: y(size(x))
       1060        
       1061        ! Local variables
       1062        character(len=*), parameter :: srname = 'PROJECT2'
       1063        real(RP) :: U(size(V, 1), min(size(V, 1), size(V, 2)))
       1064        real(RP) :: V_loc(size(V, 1), size(V, 2))
       1065        real(RP) :: tol
       1066        
       1067        ! Preconditions
       1068     1  if (DEBUGGING) then
       1069     1      call assert(size(x) == size(V, 1), 'SIZE(X) == SIZE(V, 1)', srname)
       1070     1  end if
       1071        
       1072        !====================!
       1073        ! Calculation starts !
       1074        !====================!
       1075        
       1076     1  if (size(V, 2) == 1) then
       1077     1      y = project1(x, V(:, 1))
       1078     1  elseif (all(abs(x) <= ZERO) .or. all(abs(V) <= ZERO)) then
       1079     1      y = ZERO
       1080     1  elseif (any(is_nan(x)) .or. any(is_nan(V))) then
       1081     1      y = sum(x) + sum(V)  ! Set Y to NaN
       1082     1  elseif (any(is_inf(V))) then
       1083     1      where (.not. is_inf(V))
       1084     1          V_loc = ZERO
       1085     1      elsewhere
       1086     1          V_loc = sign(ONE, V)
       1087     1      end where
       1088     1      call qr(V_loc, Q=U)
       1089     1      y = matprod(U, matprod(x, U))
       1090     1  else
       1091     1      call qr(V, Q=U)
       1092     1      y = matprod(U, matprod(x, U))
       1093     1  end if
       1094        
       1095        !====================!
       1096        !  Calculation ends  !
       1097        !====================!
       1098        
       1099        ! Postconditions
       1100     1  if (DEBUGGING) then
       1101     2      if (is_finite(norm(x)) .and. is_finite(sum(V**2))) then
       1102     2          tol = max(1.0E-10_RP, min(1.0E-1_RP, 1.0E6_RP * EPS))
       1103     2          call assert(norm(y) <= (ONE + tol) * norm(x), 'NORM(Y) <= NORM(X)', srname)
       1104     2          call assert(norm(x - y) <= (ONE + tol) * norm(x), 'NORM(X - Y) <= NORM(X)', srname)
       1105     2          ! The following test may not be passed.
       1106     2          call assert(norm(matprod(x - y, V)) <= max(tol, tol * max(norm(x - y) * sqrt(sum(V**2)), &
       1107     2              & norm(matprod(x, V)))), 'X - Y is orthogonal to V', srname)
       1108     2      end if
       1109     1  end if
       1110        end function project2
       1111        
       1112        
       1113        function hypotenuse(x1, x2) result(r)
       1114        ! HYPOTENUSE(X1, X2) returns SQRT(X1^2 + X2^2), handling over/underflow.
       1115        use, non_intrinsic :: consts_mod, only : RP, ONE, ZERO, DEBUGGING
       1116        use, non_intrinsic :: debug_mod, only : assert
       1117        use, non_intrinsic :: infnan_mod, only : is_finite, is_nan
       1118        implicit none
       1119        
       1120        ! Inputs
       1121        real(RP), intent(in) :: x1
       1122        real(RP), intent(in) :: x2
       1123        
       1124        ! Outputs
       1125        real(RP) :: r
       1126        
       1127        ! Local variables
       1128        character(len=*), parameter :: srname = 'HYPOTENUSE'
       1129        real(RP) :: y(2)
       1130        
       1131        !====================!
       1132        ! Calculation starts !
       1133        !====================!
       1134        
       1135     1  if (.not. is_finite(x1)) then
       1136     1      r = abs(x1)
       1137     1  elseif (.not. is_finite(x2)) then
       1138     1      r = abs(x2)
       1139     1  else
       1140     1      y = abs([x1, x2])
       1141     1      y = [minval(y), maxval(y)]
       1142     1      !if (y(1) > sqrt(REALMIN) .and. y(2) < sqrt(HUGENUM / 2.1_RP)) then
       1143     1      !    r = sqrt(sum(y**2))
       1144     1      !elseif (y(2) > 0) then
       1145     1      !    r = y(2) * sqrt((y(1) / y(2))**2 + ONE)
       1146     1      !else
       1147     1      !    r = ZERO
       1148     1      !end if
       1149     1      ! Scaling seems to improve the precision in general.
       1150     2      if (y(2) > 0) then
       1151     2          r = y(2) * sqrt((y(1) / y(2))**2 + ONE)
       1152     2      else
       1153     2          r = ZERO
       1154     2      end if
       1155     1  end if
       1156        
       1157        !====================!
       1158        !  Calculation ends  !
       1159        !====================!
       1160        
       1161        ! Postconditions
       1162     1  if (DEBUGGING) then
       1163     2      if (is_nan(x1) .or. is_nan(x2)) then
       1164     2          call assert(is_nan(r), 'R is NaN if X1 or X2 is NaN', srname)
       1165     2      else
       1166     2          call assert(r >= abs(x1) .and. r >= abs(x2) .and. r <= abs(x1) + abs(x2), &
       1167     2              & 'MAX{ABS(X1), ABS(X2)} <= R <= ABS(X1) + ABS(X2)', srname)
       1168     2      end if
       1169     1  end if
       1170        
       1171        end function hypotenuse
       1172        
       1173        
       1174        function planerot(x) result(G)
       1175        ! As in MATLAB, PLANEROT(X) returns a 2x2 Givens matrix G for X in R^2 so that Y = G*X has Y(2) = 0.
       1176        use, non_intrinsic :: consts_mod, only : RP, ZERO, ONE, REALMIN, EPS, HUGENUM, DEBUGGING
       1177        use, non_intrinsic :: debug_mod, only : assert
       1178        use, non_intrinsic :: infnan_mod, only : is_finite, is_nan, is_inf
       1179        implicit none
       1180        
       1181        ! Inputs
       1182        real(RP), intent(in) :: x(:)
       1183        
       1184        ! Outputs
       1185        real(RP) :: G(2, 2)
       1186        
       1187        ! Local variables
       1188        character(len=*), parameter :: srname = 'PLANEROT'
       1189        real(RP) :: c
       1190        real(RP) :: s
       1191        real(RP) :: r
       1192        real(RP) :: t
       1193        real(RP) :: u
       1194        real(RP) :: tol
       1195        
       1196        ! Preconditions
       1197     1  if (DEBUGGING) then
       1198     1      call assert(size(x) == 2, 'SIZE(X) == 2', srname)
       1199     1  end if
       1200        
       1201        !====================!
       1202        ! Calculation starts !
       1203        !====================!
       1204        
       1205        ! Define C = X(1) / R and S = X(2) / R with R = HYPOT(X(1), X(2)). Handle Inf/NaN, over/underflow.
       1206     1  if (any(is_nan(x))) then
       1207     1      ! In this case, MATLAB sets G to NaN(2, 2). We refrain from doing this to keep G orthogonal.
       1208     1      c = ONE
       1209     1      s = ZERO
       1210     1  elseif (all(is_inf(x))) then
       1211     1      ! In this case, MATLAB sets G to NaN(2, 2). We refrain from doing this to keep G orthogonal.
       1212     1      c = sign(1 / sqrt(2.0_RP), x(1))
       1213     1      s = sign(1 / sqrt(2.0_RP), x(2))
       1214     1  elseif (abs(x(1)) <= 0 .and. abs(x(2)) <= 0) then  ! X(1) == 0 == X(2).
       1215     1      c = ONE
       1216     1      s = ZERO
       1217     1  elseif (abs(x(2)) <= EPS * abs(x(1))) then
       1218     1      ! N.B.:
       1219     1      ! 0. With <= instead of <, this case covers X(1)==0==X(2), which is treated above separately to
       1220     1      ! avoid the confusing SIGN(.,0) (see 1).
       1221     1      ! 1. SIGN(A, 0) = ABS(A) in Fortran but sign(0) = 0 in MATLAB, Python, Julia, and R!!!
       1222     1      ! 2. Taking SIGN(X(1)) into account ensures the continuity of G with respect to X except at 0.
       1223     1      c = sign(ONE, x(1))  ! MATLAB: c = sign(x(1))
       1224     1      s = ZERO
       1225     1  elseif (abs(x(1)) <= EPS * abs(x(2))) then
       1226     1      ! N.B.: SIGN(A, X) = ABS(A) * sign of X /= A * sign of X !!! Therefore, it is WRONG to define G
       1227     1      ! as SIGN(RESHAPE([ZERO, -ONE, ONE, ZERO], [2, 2]), X(2)). ! This mistake was committed on on
       1228     1      ! 20211206, taking a whole day to debug! NEVER use SIGN on arrays unless you are really sure.
       1229     1      c = ZERO
       1230     1      s = sign(ONE, x(2))  ! MATLAB: s = sign(x(2))
       1231     1  else
       1232     1      ! The following is a stable and continuous implementation of the Givens rotation. It follows
       1233     1      ! Bindel, D., Demmel, J., Kahan, W., & Marques, O. (2002). On computing Givens rotations reliably
       1234     1      ! and efficiently. ACM Transactions on Mathematical Software (TOMS), 28(2), 206-238.
       1235     1      ! 1. Modern compilers compute SQRT(REALMIN) and SQRT(HUGENUM/2.1) at compilation time.
       1236     1      ! 2. The direct calculation without involving T and U seems to work better; use it if possible.
       1237     2      if (minval(abs(x)) > sqrt(REALMIN) .and. maxval(abs(x)) < sqrt(HUGENUM / 2.1_RP)) then
       1238     2          ! Do NOT use HYPOTENUSE here; the best implementation for one may not be the best for the other
       1239     2          r = sqrt(sum(x**2))
       1240     2          c = x(1) / r
       1241     2          s = x(2) / r
       1242     2      elseif (abs(x(1)) > abs(x(2))) then
       1243     2          t = x(2) / x(1)
       1244     2          u = sign(sqrt(ONE + t**2), x(1))  ! MATLAB: u = sign(x(1))*sqrt(ONE + t**2)
       1245     2          c = ONE / u
       1246     2          s = t / u
       1247     2      else
       1248     2          t = x(1) / x(2)
       1249     2          u = sign(sqrt(ONE + t**2), x(2))  ! MATLAB: u = sign(x(2))*sqrt(ONE + t**2)
       1250     2          c = t / u
       1251     2          s = ONE / u
       1252     2      end if
       1253     1  end if
       1254        
       1255        G = reshape([c, -s, s, c], [2, 2])
       1256        
       1257        !====================!
       1258        !  Calculation ends  !
       1259        !====================!
       1260        
       1261        ! Postconditions
       1262     1  if (DEBUGGING) then
       1263     1      call assert(size(G, 1) == 2 .and. size(G, 2) == 2, 'SIZE(G) == [2, 2]', srname)
       1264     1      call assert(all(is_finite(G)), 'G is finite', srname)
       1265     1      call assert(abs(G(1, 1) - G(2, 2)) + abs(G(1, 2) + G(2, 1)) <= 0, &
       1266     1          & 'G(1,1) == G(2,2), G(1,2) = -G(2,1)', srname)
       1267     1      tol = max(1.0E-10_RP, min(1.0E-1_RP, 1.0E6_RP * EPS))
       1268     1      call assert(isorth(G, tol), 'G is orthonormal', srname)
       1269     2      if (maxval(abs(x)) < sqrt(HUGENUM / 2.1_RP)) then
       1270     2          r = sqrt(sum(x**2))
       1271     2          call assert(norm(matprod(G, x) - [r, ZERO]) <= max(tol, tol * r), 'G*x = [|x|, 0]', srname)
       1272     2      end if
       1273     1  end if
       1274        
       1275        end function planerot
       1276        
       1277        
       1278        subroutine qradd(c, Q, Rdiag, n)
       1279        !--------------------------------------------------------------------------------------------------!
       1280        ! This subroutine updates the QR factorization of an MxN matrix A of full column rank, attempting to
       1281        ! add a new column C is to this matrix as the LAST column while maintaining the full-rankness.
       1282        ! Case 1. If C is not in range(A) (theoretically, it implies N < M), then the new matrix is [A, C];
       1283        ! Case 2. If C is in range(A), then the new matrix is [A(:, N-1), C].
       1284        ! N.B.:
       1285        ! 0. Instead of R, this subroutine updates Rdiag, which is diag(R), whose size is min(M, N).
       1286        ! 1. With the two cases specified as above, this function does not need A as an input.
       1287        ! 2. Indeed, when C is in range(A), Powell wrote in comments that "set IOUT to the index of the
       1288        ! constraint (here, column of A -- Zaikun) to be deleted, but branch if no suitable index can be
       1289        ! found". The idea is to replace a column of A by C so that the new matrix still has full rank
       1290        ! (such a column must exist unless C = 0). But his code essentially set IOUT = N always. Maybe he
       1291        ! found this works well enough in practice. Meanwhile, Powell's code includes a snippet that can
       1292        ! never be reached, which was probably intended to deal with the case with IOUT =/= N.
       1293        !--------------------------------------------------------------------------------------------------!
       1294        
       1295        use, non_intrinsic :: consts_mod, only : RP, IK, ZERO, EPS, DEBUGGING
       1296        use, non_intrinsic :: debug_mod, only : assert
       1297        use, non_intrinsic :: infnan_mod, only : is_finite
       1298        implicit none
       1299        
       1300        ! Inputs
       1301        real(RP), intent(in) :: c(:)
       1302        
       1303        ! In-outputs
       1304        integer(IK), intent(inout) :: n
       1305        real(RP), intent(inout) :: Q(:, :)
       1306        real(RP), intent(inout) :: Rdiag(:)
       1307        
       1308        ! Local variables
       1309        character(len=*), parameter :: srname = 'QRADD'
       1310        integer(IK) :: k
       1311        integer(IK) :: m
       1312        integer(IK) :: nsav
       1313        real(RP) :: cq(size(Q, 2))
       1314        real(RP) :: cqa(size(Q, 2))
       1315        real(RP) :: G(2, 2)
       1316        real(RP) :: tol
       1317        
       1318        ! Sizes
       1319        m = int(size(Q, 2), kind(m))
       1320        
       1321        ! Preconditions
       1322     1  if (DEBUGGING) then
       1323     1      call assert(n >= 0 .and. n <= m, '0 <= N <= M', srname)
       1324     1      call assert(size(Q, 1) == m .and. size(Q, 2) == m, 'SIZE(Q) == [m, m]', srname)
       1325     1      tol = max(1.0E-10_RP, min(1.0E-1_RP, 1.0E6_RP * EPS * real(m + 1_IK, RP)))
       1326     1      call assert(isorth(Q, tol), 'The columns of Q are orthonormal', srname)  !! Costly!
       1327     1  end if
       1328        
       1329        !====================!
       1330        ! Calculation starts !
       1331        !====================!
       1332        
       1333        nsav = n  ! Needed for debugging.
       1334        
       1335        cq = matprod(c, Q)
       1336        cqa = matprod(abs(c), abs(Q))
       1337        where (isminor(cq, cqa))  ! Code in MATLAB: CQ(ISMINOR(CQ, CQA)) = ZERO
       1338            cq = ZERO
       1339        end where
       1340        
       1341        ! Update Q so that the columns of Q(:, N+2:M) are orthogonal to C. This is done by applying a 2D
       1342        ! Givens rotation to Q(:, [K, K+1]) from the right to zero C'*Q(:, K+1) out for K = N+1, ..., M-1.
       1343        ! Nothing will be done if N >= M-2.
       1344     1  do k = m - 1_IK, n + 1_IK, -1
       1345     2      if (abs(cq(k + 1)) > 0) then
       1346     2          ! Powell wrote CQ(K+1) /= 0 instead of ABS(CQ(K+1)) > 0. The two differ if CQ(K+1) is NaN.
       1347     2          G = planerot(cq([k, k + 1_IK]))
       1348     2          Q(:, [k, k + 1_IK]) = matprod(Q(:, [k, k + 1_IK]), transpose(G))
       1349     2          cq(k) = hypotenuse(cq(k), cq(k + 1))
       1350     2          !cq(k) = sqrt(cq(k)**2 + cq(k + 1)**2)
       1351     2      end if
       1352     1  end do
       1353        
       1354        ! Augment N by 1 if C is not in range(A).
       1355        ! The two IFs cannot be merged as Fortran may evaluate CQ(N+1) even if N>=M, leading to a SEGFAULT.
       1356     1  if (n < m) then
       1357     2      if (abs(cq(n + 1)) > 0) then  ! C is not in range(A).
       1358     2          ! Powell wrote CQ(N+1) /= 0 instead of ABS(CQ(N+1)) > 0. The two differ if CQ(N+1) is NaN.
       1359     2          n = n + 1_IK
       1360     2      end if
       1361     1  end if
       1362        
       1363        ! Update Rdiag so that RDIAG(N) = CQ(N) = INPROD(C, Q(:, N)). Note that N may have been augmented.
       1364     1  if (n >= 1 .and. n <= m) then  ! N > M should not happen unless the input is wrong.
       1365     1      Rdiag(n) = cq(n)  ! Indeed, RDIAG(N) = INPROD(C, Q(:, N))
       1366     1  end if
       1367        
       1368        !====================!
       1369        !  Calculation ends  !
       1370        !====================!
       1371        
       1372        ! Postconditions
       1373     1  if (DEBUGGING) then
       1374     1      call assert(n >= nsav .and. n <= min(nsav + 1_IK, m), 'NSAV <= N <= min(NSAV + 1, M)', srname)
       1375     1      call assert(size(Q, 1) == m .and. size(Q, 2) == m, 'SIZE(Q) == [m, m]', srname)
       1376     1      call assert(isorth(Q, tol), 'The columns of Q are orthonormal', srname)  !! Costly!
       1377     2      if (n < m .and. is_finite(norm(c))) then
       1378     2          call assert(norm(matprod(c, Q(:, n + 1:m))) <= max(tol, tol * norm(c)), 'C^T*Q(:, N+1:M) == 0', srname)
       1379     2      end if
       1380     2      if (n >= 1) then
       1381     2          call assert(abs(inprod(c, Q(:, n)) - Rdiag(n)) <= max(tol, tol * inprod(abs(c), abs(Q(:, n)))) &
       1382     2              & .or. .not. is_finite(Rdiag(n)), 'C^T*Q(:, N) == Rdiag(N)', srname)
       1383     2      end if
       1384     1  end if
       1385        end subroutine qradd
       1386        
       1387        
       1388        subroutine qrexc(A, Q, Rdiag, i)
       1389        !--------------------------------------------------------------------------------------------------!
       1390        ! This subroutine updates the QR factorization of A when its [I, I+1, ..., N] columns are reordered
       1391        ! as [I+1, ..., N, I]. Here, A IS ASSUMED TO HAVE FULL COLUMN RANK.
       1392        ! N.B. Instead of R, this subroutine updates Rdiag, which is diag(R), whose size is min(M, N).
       1393        !--------------------------------------------------------------------------------------------------!
       1394        use, non_intrinsic :: consts_mod, only : RP, IK, EPS, DEBUGGING
       1395        use, non_intrinsic :: debug_mod, only : assert
       1396        implicit none
       1397        
       1398        ! Inputs
       1399        real(RP), intent(in) :: A(:, :)
       1400        
       1401        ! In-outputs
       1402        real(RP), intent(inout) :: Q(:, :)
       1403        real(RP), intent(inout) :: Rdiag(:)
       1404        integer(IK), intent(in) :: i
       1405        
       1406        ! Local variables
       1407        character(len=*), parameter :: srname = 'QREXC'
       1408        integer(IK) :: k
       1409        integer(IK) :: m
       1410        integer(IK) :: n
       1411        real(RP) :: A_test(size(A, 1), size(A, 2))
       1412        real(RP) :: G(2, 2)
       1413        !real(RP) :: hypt
       1414        real(RP) :: QA_test(size(A, 1), size(A, 2))
       1415        real(RP) :: tol
       1416        
       1417        ! Sizes
       1418        m = int(size(A, 1), kind(m))
       1419        n = int(size(A, 2), kind(n))
       1420        
       1421        ! Postconditions
       1422     1  if (DEBUGGING) then
       1423     1      call assert(n >= 0 .and. n <= m, '0 <= N <= M', srname)
       1424     1      call assert(i >= 1 .and. i <= n, '1 <= i <= N', srname)
       1425     1      call assert(size(Q, 1) == m .and. size(Q, 2) == m, 'SIZE(Q) == [m, m]', srname)
       1426     1      tol = max(1.0E-10_RP, min(1.0E-1_RP, 1.0E8_RP * EPS * real(m + 1_IK, RP)))
       1427     1      call assert(isorth(Q, tol), 'The columns of Q are orthonormal', srname)  !! Costly!
       1428     1  end if
       1429        
       1430        !====================!
       1431        ! Calculation starts !
       1432        !====================!
       1433        
       1434     1  if (i <= 0 .or. i >= n) then   ! I <= 0 or I > N should not happen.
       1435     1      return
       1436     1  end if
       1437        
       1438        ! For each K, find a Givens rotation G so that G*Q(:, [K+1, K])^T*A(:, K+1) = [r, 0].
       1439        ! Then update Q(:, [K, K+1]) to Q(:, [K+1, K])*G^T, and A(:, [K, K+1]) to A(:, [K+1, K]). After
       1440        ! this, Q(:, [K, K+1])^T*A(:, [K, K+1]) is upper triangular, the diagonal being Rdiag([K, K+1])
       1441        ! defined below. In this way, we obtain the QR factorization of A when its Kth and (K+1)th columns
       1442        ! are exhanged. After this is done for each K = 1, ..., N-1, we obtain the QR factorization of
       1443        ! A when its [I, I+1, ..., N] columns are reordered as [I+1, ..., N, I].
       1444     1  do k = i, n - 1_IK
       1445     1      !hypt = hypotenuse(Rdiag(k + 1), inprod(Q(:, k), A(:, k + 1)))
       1446     1      !hypt = sqrt(Rdiag(k + 1)**2 + inprod(Q(:, k), A(:, k + 1))**2)
       1447     1      G = planerot([Rdiag(k + 1), inprod(Q(:, k), A(:, k + 1))])
       1448     1      Q(:, [k, k + 1_IK]) = matprod(Q(:, [k + 1_IK, k]), transpose(G))
       1449     1      ! Powell's code updates RDIAG in the following way.
       1450     1      !----------------------------------------------------------------!
       1451     1      !!Rdiag([k, k + 1_IK]) = [hypt, (Rdiag(k + 1) / hypt) * Rdiag(k)]!
       1452     1      !----------------------------------------------------------------!
       1453     1      ! Note that RDIAG(N) inherits all rounding in RDIAG(I:N-1) and Q(:, I:N-1) and hence contain
       1454     1      ! significant errors. Thus we may modify the code as follows, only calculating RDIAG(K) here and
       1455     1      ! calculating RDIAG(N) by an inner product after the loop.
       1456     1      !----------------!
       1457     1      !!Rdiag(k) = hypt!
       1458     1      !----------------!
       1459     1      ! Or we simply calculate RDIAG from scratch as follows.
       1460     1      Rdiag(k) = inprod(Q(:, k), A(:, k + 1))
       1461     1  end do
       1462        
       1463        Rdiag(n) = inprod(Q(:, n), A(:, i))  ! Calculate RDIAG(N) from scratch. See the comments above.
       1464        
       1465        !====================!
       1466        !  Calculation ends  !
       1467        !====================!
       1468        
       1469        ! Postconditions
       1470     1  if (DEBUGGING) then
       1471     1      call assert(size(Q, 1) == m .and. size(Q, 2) == m, 'SIZE(Q) == [m, m]', srname)
       1472     1      call assert(isorth(Q, tol), 'The columns of Q are orthonormal', srname)  !! Costly!
       1473     1      A_test = reshape([A(:, 1:i - 1), A(:, i + 1:n), A(:, i)], shape(A))
       1474     1      QA_test = matprod(transpose(Q), A_test)
       1475     1      call assert(istriu(QA_test, tol), 'QA_test is upper triangular', srname)
       1476     1      ! The following test may fail if RDIAG is not calculated from scratch.
       1477     1      call assert(norm(diag(QA_test) - Rdiag) <= max(tol, tol * norm([(inprod(abs(Q(:, k)), &
       1478     1          & abs(A_test(:, k))), k=1, n)])), 'Rdiag == diag(QA_test)', srname)
       1479     1  end if
       1480        end subroutine qrexc
       1481        
       1482        
       1483        subroutine symmetrize(A)
       1484        ! SYMMETRIZE(A) symmetrizes A.
       1485        ! Here, we assume that A is a matrix that is symmetric in precise arithmetic, and its asymmetry
       1486        ! comes only from rounding errors.
       1487        
       1488        #if __USE_POWELL_ALGEBRA__ == 1
       1489        use, non_intrinsic :: consts_mod, only : RP, IK
       1490        #else
       1491        use, non_intrinsic :: consts_mod, only : RP, HALF
       1492        #endif
       1493        
       1494        #if __DEBUGGING__ == 1
       1495        use, non_intrinsic :: debug_mod, only : errstop, assert
       1496        #endif
       1497        
       1498        implicit none
       1499        real(RP), intent(inout) :: A(:, :)
       1500        
       1501        #if __USE_POWELL_ALGEBRA__ == 1
       1502        integer(IK) :: j
       1503        #endif
       1504        
       1505        #if __DEBUGGING__ == 1
       1506        character(len=*), parameter :: srname = 'SYMMETRIZE'
       1507     1  if (size(A, 1) /= size(A, 2)) then
       1508     1      call errstop(srname, 'A is not square')
       1509     1  end if
       1510        #endif
       1511        
       1512        #if __USE_POWELL_ALGEBRA__ == 1
       1513        ! A is symmetrized by setting A(UPPER_TRI) = A(LOWER_TRI).
       1514     1  do j = 1, int(size(A, 1), kind(j))
       1515     1      A(1:j - 1, j) = A(j, 1:j - 1)
       1516     1  end do
       1517        #else
       1518        A = A + transpose(A)
       1519        A = A * HALF
       1520        #endif
       1521        
       1522        #if __DEBUGGING__ == 1
       1523        call assert(issymmetric(A), 'A is symmetrized', srname)
       1524        #endif
       1525        end subroutine symmetrize
       1526        
       1527        
       1528        function Ax_plus_y(A, x, y) result(z)
       1529        !--------------------------------------------------------------------------------------------------!
       1530        ! z = A*x + y (imagine x, y, and z as columns)
       1531        !--------------------------------------------------------------------------------------------------!
       1532        use, non_intrinsic :: consts_mod, only : RP, IK, DEBUGGING
       1533        use, non_intrinsic :: debug_mod, only : assert
       1534        implicit none
       1535        
       1536        ! Inputs
       1537        real(RP), intent(in) :: A(:, :)
       1538        real(RP), intent(in) :: x(:)
       1539        real(RP), intent(in) :: y(:)
       1540        
       1541        ! Outputs
       1542        real(RP) :: z(size(y))
       1543        
       1544        ! Local variables
       1545        character(len=*), parameter :: srname = 'AX_PLUS_Y'
       1546        integer(IK) :: j
       1547        
       1548        ! Preconditions
       1549     1  if (DEBUGGING) then
       1550     1      call assert(size(x) == size(A, 2) .and. size(y) == size(A, 1), 'SIZE(A) == [SIZE(Y), SIZE(X)]', &
       1551     1          & srname)
       1552     1  end if
       1553        
       1554        !====================!
       1555        ! Calculation starts !
       1556        !====================!
       1557        
       1558        !--------------------------------------------------------------------------------------------------!
       1559        ! In BIGLAG of NEWUOA, the following loop works numerically better than Z = MATPROD(A, X) + Y. Why?
       1560        !--------------------------------------------------------------------------------------------------!
       1561        z = y
       1562     1  do j = 1, int(size(A, 2), kind(j))
       1563     1      z = z + A(:, j) * x(j)
       1564     1  end do
       1565        
       1566        !====================!
       1567        !  Calculation ends  !
       1568        !====================!
       1569        
       1570        end function Ax_plus_y
       1571        
       1572        
       1573        function calquad(d, gq, hq, pq, x, xpt) result(qred)
       1574        !--------------------------------------------------------------------------------------------------!
       1575        ! This function evaluates QRED = Q(X) - Q(X + D) with Q being the quadratic function defined via
       1576        ! (GQ, HQ, PQ) by
       1577        ! Q(Y) = <Y, GQ> + 0.5*<Y, HESSIAN*Y>,
       1578        ! where HESSIAN consists of an explicit part HQ and an implicit part PQ in Powell's way:
       1579        ! HESSIAN = HQ + sum_K=1^NPT PQ(K)*(XPT(:, K)*XPT(:, K)^T) .
       1580        !--------------------------------------------------------------------------------------------------!
       1581        
       1582        use, non_intrinsic :: consts_mod, only : RP, HALF
       1583        
       1584        #if __USE_POWELL_ALGEBRA__ == 1
       1585        use, non_intrinsic :: consts_mod, only : IK, ZERO
       1586        #endif
       1587        
       1588        #if __DEBUGGING__ == 1
       1589        use, non_intrinsic :: consts_mod, only : IK
       1590        use, non_intrinsic :: debug_mod, only : errstop, verisize
       1591        #endif
       1592        
       1593        implicit none
       1594        
       1595        ! Inputs
       1596        real(RP), intent(in) :: d(:)      ! D(N)
       1597        real(RP), intent(in) :: gq(:)     ! GQ(N)
       1598        real(RP), intent(in) :: hq(:, :)  ! HQ(N, N)
       1599        real(RP), intent(in) :: pq(:)     ! PQ(NPT)
       1600        real(RP), intent(in) :: x(:)      ! X(N)
       1601        real(RP), intent(in) :: xpt(:, :) ! XPT(N, NPT)
       1602        
       1603        ! Output
       1604        real(RP) :: qred
       1605        
       1606        ! Local variable
       1607        real(RP) :: s(size(x))
       1608        
       1609        #if __USE_POWELL_ALGEBRA__ == 1
       1610        real(RP) :: w(size(pq)), t
       1611        integer(IK) :: i, ih, j
       1612        #endif
       1613        
       1614        #if __DEBUGGING__ == 1
       1615        integer(IK) :: n, npt
       1616        character(len=*), parameter :: srname = 'CALQUAD'
       1617        n = int(size(xpt, 1), kind(n))
       1618        npt = int(size(xpt, 2), kind(npt))
       1619     1  if (n < 1 .or. npt < n + 2) then
       1620     1      call errstop(srname, 'SIZE(XPT) is invalid')
       1621     1  end if
       1622        call verisize(d, n)
       1623        call verisize(x, n)
       1624        call verisize(gq, n)
       1625        call verisize(hq, n, n)
       1626        call verisize(pq, npt)
       1627        #endif
       1628        
       1629        #if __USE_POWELL_ALGEBRA__ == 1
       1630        s = x + d
       1631        ! First order term and explicit second order term
       1632        qred = ZERO
       1633        ih = 0_IK
       1634     1  do j = 1, int(size(d), kind(j))
       1635     1      qred = qred - d(j) * gq(j)
       1636     2      do i = 1, j
       1637     2          ih = int(ih + 1, kind(ih))
       1638     2          t = d(i) * s(j) + d(j) * x(i)
       1639     3          if (i == j) then
       1640     3              t = HALF * t
       1641     3          end if
       1642     2          qred = qred - t * hq(i, j)
       1643     2      end do
       1644     1  end do
       1645        !-----------------------------------------------------------!
       1646        ! Powell's original code calculates W externally and pass it
       1647        ! as an input to CALQUAD. Here W is calculated internally.
       1648        w = matprod(d, xpt) !---------------------------------------!
       1649        w = w * (HALF * w + matprod(x, xpt)) !----------------------!
       1650        !-----------------------------------------------------------!
       1651        ! Implicit second order term
       1652     1  do i = 1, int(size(pq), kind(i))
       1653     1      qred = qred - pq(i) * w(i)
       1654     1  end do
       1655        #else
       1656        ! The order of calculation seems quite important. The following order seems to work well.
       1657        ! 1st order term
       1658        qred = -inprod(d, gq)
       1659        s = HALF * d + x  ! Different from the above version.
       1660        ! implicit 2nd-order term
       1661        qred = qred - sum(pq * (matprod(s, xpt) * matprod(d, xpt)))
       1662        ! explicit 2nd-order term
       1663        qred = qred - inprod(s, matprod(hq, d))
       1664        ! The following implementations do not work as well as the above one.
       1665        !qred = qred - inprod(d, matprod(hq, s))
       1666        !qred = qred - sum(hq * outprod(s, d))
       1667        !qred = qred - HALF*(inprod(d, matprod(hq, s)) + inprod(s, matprod(hq, d)))
       1668        #endif
       1669        end function calquad
       1670        
       1671        
       1672        function errquad(gq, hq, pq, xpt, fval) result(err)
       1673        !--------------------------------------------------------------------------------------------------!
       1674        ! This function calculates the maximal relative error of Q in interpolating FVAL on XPT.
       1675        ! Here, Q is the quadratic function defined via (GQ, HQ, PQ) by
       1676        ! Q(Y) = <Y, GQ> + 0.5*<Y, HESSIAN*Y>,
       1677        ! where HESSIAN consists of an explicit part HQ and an implicit part PQ in Powell's way:
       1678        ! HESSIAN = HQ + sum_K=1^NPT PQ(K)*(XPT(:, K)*XPT(:, K)^T) .
       1679        !--------------------------------------------------------------------------------------------------!
       1680        use, non_intrinsic :: consts_mod, only : RP, IK, ZERO, HUGENUM, DEBUGGING
       1681        use, non_intrinsic :: debug_mod, only : assert
       1682        use, non_intrinsic :: infnan_mod, only : is_finite, is_nan, is_posinf
       1683        implicit none
       1684        
       1685        ! Inputs
       1686        real(RP), intent(in) :: gq(:)     ! GQ(N)
       1687        real(RP), intent(in) :: hq(:, :)  ! HQ(N, N)
       1688        real(RP), intent(in) :: pq(:)     ! PQ(NPT)
       1689        real(RP), intent(in) :: xpt(:, :) ! XPT(N, NPT)
       1690        real(RP), intent(in) :: fval(:)   ! FVAL(NPT)
       1691        
       1692        ! Outputs
       1693        real(RP) :: err
       1694        
       1695        ! Local variables
       1696        character(len=*), parameter :: srname = 'ERRQUAD'
       1697        integer(IK) :: k
       1698        integer(IK) :: n
       1699        integer(IK) :: npt
       1700        real(RP) :: fmq(size(xpt, 2))
       1701        real(RP) :: qval(size(xpt, 2))
       1702        real(RP) :: zeros(size(xpt, 1))
       1703        
       1704        ! Sizes
       1705        n = int(size(xpt, 1), kind(n))
       1706        npt = int(size(xpt, 2), kind(npt))
       1707        
       1708        ! Preconditions
       1709     1  if (DEBUGGING) then
       1710     1      call assert(n >= 1, 'N >= 1', srname)
       1711     1      call assert(npt >= n + 2, 'NPT >= N + 2', srname)
       1712     1      call assert(size(gq) == n, 'SIZE(GQ) == N', srname)
       1713     1      call assert(size(hq, 1) == n .and. issymmetric(hq), 'HQ is an NxN symmetric matrix', srname)
       1714     1      call assert(size(pq) == npt, 'SIZE(PQ) == NPT', srname)
       1715     1      call assert(all(is_finite(xpt)), 'XPT is finite', srname)
       1716     1      call assert(size(fval) == npt, 'SIZE(FVAL) == NPT', srname)
       1717     1      call assert(.not. any(is_nan(fval) .or. is_posinf(fval)), 'FVAL is not NaN/+Inf', srname)
       1718     1  end if
       1719        
       1720        !====================!
       1721        ! Calculation starts !
       1722        !====================!
       1723        
       1724        zeros = ZERO
       1725        qval = [(-calquad(xpt(:, k), gq, hq, pq, zeros, xpt), k=1, npt)]
       1726     1  if (.not. all(is_finite(qval))) then
       1727     1      err = HUGENUM
       1728     1  else
       1729     1      fmq = fval - qval
       1730     1      err = (maxval(fmq) - minval(fmq)) !/ max(ONE, maxval(abs(fval)))
       1731     1  end if
       1732        
       1733        !====================!
       1734        !  Calculation ends  !
       1735        !====================!
       1736        !
       1737        end function errquad
       1738        
       1739        
       1740        function hess_mul(hq, pq, xpt, x) result(y)
       1741        !--------------------------------------------------------------------------------------------------!
       1742        ! This function calculates HESSIAN*X, where HESSIAN consists of an explicit part HQ and an
       1743        ! implicit part PQ in Powell's way: HESSIAN = HQ + sum_K=1^NPT PQ(K)*(XPT(:, K)*XPT(:, K)^T).
       1744        !--------------------------------------------------------------------------------------------------!
       1745        use, non_intrinsic :: consts_mod, only : RP, IK, DEBUGGING
       1746        use, non_intrinsic :: debug_mod, only : assert
       1747        use, non_intrinsic :: infnan_mod, only : is_finite
       1748        implicit none
       1749        
       1750        ! Inputs
       1751        real(RP), intent(in) :: hq(:, :)  ! HQ(N, N)
       1752        real(RP), intent(in) :: pq(:)     ! PQ(NPT)
       1753        real(RP), intent(in) :: x(:)      ! X(N)
       1754        real(RP), intent(in) :: xpt(:, :) ! XPT(N, NPT)
       1755        
       1756        ! Outputs
       1757        real(RP) :: y(size(hq, 1))
       1758        
       1759        ! Local variables
       1760        character(len=*), parameter :: srname = 'HESSMUL'
       1761        integer(IK) :: j
       1762        integer(IK) :: n
       1763        integer(IK) :: npt
       1764        
       1765        ! Sizes
       1766        n = int(size(xpt, 1), kind(n))
       1767        npt = int(size(xpt, 2), kind(npt))
       1768        
       1769        ! Preconditions
       1770     1  if (DEBUGGING) then
       1771     1      call assert(n >= 1, 'N >= 1', srname)
       1772     1      call assert(npt >= n + 2, 'NPT >= N + 2', srname)
       1773     1      call assert(size(hq, 1) == n .and. issymmetric(hq), 'HQ is an NxN symmetric matrix', srname)
       1774     1      call assert(size(pq) == npt, 'SIZE(PQ) == NPT', srname)
       1775     1      call assert(all(is_finite(xpt)), 'XPT is finite', srname)
       1776     1      call assert(size(x) == n, 'SIZE(Y) == N', srname)
       1777     1  end if
       1778        
       1779        !====================!
       1780        ! Calculation starts !
       1781        !====================!
       1782        
       1783        !--------------------------------------------------------------------------------!
       1784        !----------! y = matprod(hq, x) + matprod(xpt, pq * matprod(x, xpt)) !-----------!
       1785        ! The following loop works numerically better than the last line (but why?).
       1786        !--------------------------------------------------------------------------------!
       1787        y = matprod(xpt, pq * matprod(x, xpt))
       1788     1  do j = 1, n
       1789     1      y = y + hq(:, j) * x(j)
       1790     1  end do
       1791        
       1792        !====================!
       1793        !  Calculation ends  !
       1794        !====================!
       1795        
       1796        end function hess_mul
       1797        
       1798        
       1799        function errh(idz, bmat, zmat, xpt) result(err)
       1800        !--------------------------------------------------------------------------------------------------!
       1801        ! This function calculates the error in H as the inverse of W. See (3.12) of the NEWUOA paper.
       1802        ! N.B.: The (NPT+1)th column (row) of H is not contained in [BMAT, ZMAT]. It is [r; t(1); s] below.
       1803        ! In the complete form, the W and H in (3.12) of the NEWUOA paper are as follows.
       1804        ! W = [A, ONES(NPT, 1), XPT^T; ONES(1, NPT), ZERO, ZEROS(1, N); XPT, ZEROS(N, 1), ZEROS(N, N)]
       1805        ! H = [Omega, r, BMAT(:, 1:NPT)^T; r^T, t(1), s^T, BMAT(:, 1:NPT), s, BMAT(:, NPT+1:NPT+N)]
       1806        !--------------------------------------------------------------------------------------------------!
       1807        use, non_intrinsic :: consts_mod, only : RP, IK, ONE, HALF, DEBUGGING
       1808        use, non_intrinsic :: debug_mod, only : assert
       1809        use, non_intrinsic :: infnan_mod, only : is_finite
       1810        implicit none
       1811        
       1812        ! Inputs
       1813        integer(IK), intent(in) :: idz
       1814        real(RP), intent(in) :: bmat(:, :)
       1815        real(RP), intent(in) :: zmat(:, :)
       1816        real(RP), intent(in) :: xpt(:, :)
       1817        
       1818        ! Outputs
       1819        real(RP) :: err
       1820        
       1821        ! Local variables
       1822        character(len=*), parameter :: srname = 'ERRH'
       1823        integer(IK) :: n
       1824        integer(IK) :: npt
       1825        real(RP) :: A(size(xpt, 2), size(xpt, 2))
       1826        real(RP) :: e(3, 3)
       1827        real(RP) :: maxabs
       1828        real(RP) :: Omega(size(xpt, 2), size(xpt, 2))
       1829        real(RP) :: U(size(xpt, 2), size(xpt, 2))
       1830        real(RP) :: V(size(xpt, 1), size(xpt, 2))
       1831        real(RP) :: r(size(xpt, 2))
       1832        real(RP) :: s(size(xpt, 1))
       1833        real(RP) :: t(size(xpt, 2))
       1834        
       1835        ! Sizes
       1836        n = int(size(xpt, 1), kind(n))
       1837        npt = int(size(xpt, 2), kind(npt))
       1838        
       1839        ! Preconditions
       1840     1  if (DEBUGGING) then
       1841     1      call assert(n >= 1, 'N >= 1', srname)
       1842     1      call assert(npt >= n + 2, 'NPT >= N + 2', srname)
       1843     1      call assert(idz >= 1 .and. idz <= npt - n, '1 <= IDZ <= NPT-N', srname)
       1844     1      call assert(size(bmat, 1) == n .and. size(bmat, 2) == npt + n, 'SIZE(BMAT)==[N, NPT+N]', srname)
       1845     1      call assert(issymmetric(bmat(:, npt + 1:npt + n)), 'BMAT(:, NPT+1:NPT+N) is symmetric', srname)
       1846     1      call assert(size(zmat, 1) == npt .and. size(zmat, 2) == npt - n - 1, &
       1847     1          & 'SIZE(ZMAT) == [NPT, NPT-N-1]', srname)
       1848     1      call assert(all(is_finite(xpt)), 'XPT is finite', srname)
       1849     1  end if
       1850        
       1851        !====================!
       1852        ! Calculation starts !
       1853        !====================!
       1854        
       1855        A = HALF * matprod(transpose(xpt), xpt)**2
       1856        Omega = -matprod(zmat(:, 1:idz - 1), transpose(zmat(:, 1:idz - 1))) + &
       1857            & matprod(zmat(:, idz:npt - n - 1), transpose(zmat(:, idz:npt - n - 1)))
       1858        maxabs = maxval([ONE, maxval(abs(A)), maxval(abs(Omega)), maxval(abs(bmat))])
       1859        U = eye(npt) - matprod(A, Omega) - matprod(transpose(xpt), bmat(:, 1:npt))
       1860        V = -matprod(bmat(:, 1:npt), A) - matprod(bmat(:, npt + 1:npt + n), xpt)
       1861        r = sum(U, dim=1) / real(npt, RP)
       1862        s = sum(V, dim=2) / real(npt, RP)
       1863        t = -matprod(A, r) - matprod(s, xpt)
       1864        e(1, 1) = maxval(maxval(U, dim=1) - minval(U, dim=1))
       1865        e(1, 2) = maxval(t) - minval(t)
       1866        e(1, 3) = maxval(maxval(V, dim=2) - minval(V, dim=2))
       1867        e(2, 1) = maxval(abs(sum(Omega, dim=1)))
       1868        e(2, 2) = abs(sum(r) - ONE)
       1869        e(2, 3) = maxval(abs(sum(bmat(:, 1:npt), dim=2)))
       1870        e(3, 1) = maxval(abs(matprod(xpt, Omega)))
       1871        e(3, 2) = maxval(abs(matprod(xpt, r)))
       1872        e(3, 3) = maxval(abs(matprod(xpt, transpose(bmat(:, 1:npt))) - eye(n)))
       1873        err = maxval(e) / (maxabs * real(n + npt, RP))
       1874        
       1875        !====================!
       1876        !  Calculation ends  !
       1877        !====================!
       1878        
       1879        end function errh
       1880        
       1881        
       1882        function omega_col(idz, zmat, k) result(y)
       1883        !--------------------------------------------------------------------------------------------------!
       1884        ! This function calculates Y = column K of OMEGA, where, as Powell did in NEWUOA, BOBYQA, and LINCOA,
       1885        ! OMEGA = sum_{i=1}^{K} S_i*ZMAT(:, i)*ZMAT(:, i)^T if S_i = -1 when i < IDZ and S_i = 1 if i >= IDZ
       1886        !--------------------------------------------------------------------------------------------------!
       1887        use, non_intrinsic :: consts_mod, only : RP, IK, DEBUGGING
       1888        use, non_intrinsic :: debug_mod, only : assert
       1889        implicit none
       1890        
       1891        ! Inputs
       1892        integer(IK), intent(in) :: idz
       1893        integer(IK), intent(in) :: k
       1894        real(RP), intent(in) :: zmat(:, :)
       1895        
       1896        ! Outputs
       1897        real(RP) :: y(size(zmat, 1))
       1898        
       1899        ! Local variables
       1900        character(len=*), parameter :: srname = 'OMEGA_COL'
       1901        real(RP) :: zk(size(zmat, 2))
       1902        
       1903        ! Preconditions
       1904     1  if (DEBUGGING) then
       1905     1      call assert(idz >= 1 .and. idz <= size(zmat, 2) + 1, '1 <= IDZ <= SIZE(ZMAT, 2) + 1', srname)
       1906     1      call assert(k >= 1 .and. idz <= size(zmat, 1), '1 <= K <= SIZE(ZMAT, 1)', srname)
       1907     1  end if
       1908        
       1909        !====================!
       1910        ! Calculation starts !
       1911        !====================!
       1912        
       1913        zk = zmat(k, :)
       1914        zk(1:idz - 1) = -zk(1:idz - 1)
       1915        y = matprod(zmat, zk)
       1916        
       1917        !====================!
       1918        !  Calculation ends  !
       1919        !====================!
       1920        
       1921        end function omega_col
       1922        
       1923        
       1924        function omega_mul(idz, zmat, x) result(y)
       1925        !--------------------------------------------------------------------------------------------------!
       1926        ! This function calculates Y = OMEGA*X, where, as Powell did in NEWUOA, BOBYQA, and LINCOA,
       1927        ! OMEGA = sum_{i=1}^{K} S_i*ZMAT(:, i)*ZMAT(:, i)^T if S_i = -1 when i < IDZ and S_i = 1 if i >= IDZ
       1928        !--------------------------------------------------------------------------------------------------!
       1929        use, non_intrinsic :: consts_mod, only : RP, IK, DEBUGGING
       1930        use, non_intrinsic :: debug_mod, only : assert
       1931        implicit none
       1932        
       1933        ! Inputs
       1934        integer(IK), intent(in) :: idz
       1935        real(RP), intent(in) :: zmat(:, :)
       1936        real(RP), intent(in) :: x(:)
       1937        
       1938        ! Outputs
       1939        real(RP) :: y(size(zmat, 1))
       1940        
       1941        ! Local variables
       1942        character(len=*), parameter :: srname = 'OMEGA_MUL'
       1943        real(RP) :: xz(size(zmat, 2))
       1944        
       1945        ! Preconditions
       1946     1  if (DEBUGGING) then
       1947     1      call assert(idz >= 1 .and. idz <= size(zmat, 2) + 1, '1 <= IDZ <= SIZE(ZMAT, 2) + 1', srname)
       1948     1      call assert(size(x) == size(zmat, 1), 'SIZE(X) == SIZE(ZMAT, 1)', srname)
       1949     1  end if
       1950        
       1951        !====================!
       1952        ! Calculation starts !
       1953        !====================!
       1954        
       1955        xz = matprod(x, zmat)
       1956        xz(1:idz - 1) = -xz(1:idz - 1)
       1957        y = matprod(zmat, xz)
       1958        
       1959        !====================!
       1960        !  Calculation ends  !
       1961        !====================!
       1962        
       1963        end function omega_mul
       1964        
       1965        
       1966        function omega_inprod(idz, zmat, x, y) result(p)
       1967        !--------------------------------------------------------------------------------------------------!
       1968        ! This function calculates P = X^T*OMEGA*Y, where, as Powell did in NEWUOA, BOBYQA, and LINCOA,
       1969        ! OMEGA = sum_{i=1}^{K} S_i*ZMAT(:, i)*ZMAT(:, i)^T if S_i = -1 when i < IDZ and S_i = 1 if i >= IDZ
       1970        !--------------------------------------------------------------------------------------------------!
       1971        use, non_intrinsic :: consts_mod, only : RP, IK, DEBUGGING
       1972        use, non_intrinsic :: debug_mod, only : assert
       1973        implicit none
       1974        
       1975        ! Inputs
       1976        integer(IK), intent(in) :: idz
       1977        real(RP), intent(in) :: zmat(:, :)
       1978        real(RP), intent(in) :: x(:)
       1979        real(RP), intent(in) :: y(:)
       1980        
       1981        ! Outputs
       1982        real(RP) :: p
       1983        
       1984        ! Local variables
       1985        character(len=*), parameter :: srname = 'OMEGA_INPROD'
       1986        real(RP) :: xz(size(zmat, 2))
       1987        real(RP) :: yz(size(zmat, 2))
       1988        
       1989        ! Preconditions
       1990     1  if (DEBUGGING) then
       1991     1      call assert(idz >= 1 .and. idz <= size(zmat, 2) + 1, '1 <= IDZ <= SIZE(ZMAT, 2) + 1', srname)
       1992     1      call assert(size(x) == size(zmat, 1), 'SIZE(X) == SIZE(ZMAT, 1)', srname)
       1993     1      call assert(size(y) == size(zmat, 1), 'SIZE(Y) == SIZE(ZMAT, 1)', srname)
       1994     1  end if
       1995        
       1996        !====================!
       1997        ! Calculation starts !
       1998        !====================!
       1999        
       2000        xz = matprod(x, zmat)
       2001        xz(1:idz - 1) = -xz(1:idz - 1)
       2002        yz = matprod(y, zmat)
       2003        p = inprod(xz, yz)
       2004        
       2005        !====================!
       2006        !  Calculation ends  !
       2007        !====================!
       2008        
       2009        end function omega_inprod
       2010        
       2011        
       2012        pure function isminor0(x, ref) result(is_minor)
       2013        ! This function tests whether X is minor compared to REF. It is used by Powell, e.g., in COBYLA.
       2014        ! In precise arithmetic, ISMINOR(X, REF) is TRUE if and only if X == 0; in floating-point
       2015        ! arithmetic, ISMINOR(X, REF) is true if X is zero or its nonzero value can be attributed to
       2016        ! computer rounding errors according to REF.
       2017        ! Larger SENSITIVITY means the function is more strict/precise.
       2018        use, non_intrinsic :: consts_mod, only : RP, TENTH, TWO
       2019        implicit none
       2020        
       2021        real(RP), intent(in) :: x
       2022        real(RP), intent(in) :: ref
       2023        logical :: is_minor
       2024        real(RP), parameter :: sensitivity = TENTH
       2025        real(RP) :: refa
       2026        real(RP) :: refb
       2027        
       2028        refa = abs(ref) + sensitivity * abs(x)
       2029        refb = abs(ref) + TWO * sensitivity * abs(x)
       2030        is_minor = (abs(ref) >= refa .or. refa >= refb)
       2031        end function isminor0
       2032        
       2033        
       2034        function isminor1(x, ref) result(is_minor)
       2035        ! This function tests whether X is minor compared to REF. It is used by Powell, e.g., in COBYLA.
       2036        use, non_intrinsic :: consts_mod, only : IK, RP
       2037        #if __DEBUGGING__ == 1
       2038        use, non_intrinsic :: debug_mod, only : errstop
       2039        #endif
       2040        implicit none
       2041        
       2042        real(RP), intent(in) :: x(:)
       2043        real(RP), intent(in) :: ref(:)
       2044        logical :: is_minor(size(x))
       2045        integer(IK) :: i
       2046        
       2047        #if __DEBUGGING__ == 1
       2048        character(len=*), parameter :: srname = 'ISMINOR1'
       2049     1  if (size(x) /= size(ref)) then
       2050     1      call errstop(srname, 'SIZE(X) /= SIZE(REF)')
       2051     1  end if
       2052        #endif
       2053        
       2054        is_minor = [(isminor0(x(i), ref(i)), i=1, int(size(x), IK))]
       2055        end function isminor1
       2056        
       2057        pure function issymmetric(A, tol) result(is_symmetric)
       2058        ! This function tests whether A is symmetric up to TOL.
       2059        use, non_intrinsic :: consts_mod, only : RP, ONE, ZERO
       2060        use, non_intrinsic :: infnan_mod, only : is_nan
       2061        implicit none
       2062        
       2063        ! Inputs
       2064        real(RP), intent(in) :: A(:, :)
       2065        real(RP), intent(in), optional :: tol
       2066        
       2067        ! Outputs
       2068        logical :: is_symmetric
       2069        
       2070        is_symmetric = .true.
       2071     1  if (size(A, 1) /= size(A, 2)) then
       2072     1      is_symmetric = .false.
       2073     1  elseif (.not. all(is_nan(A) .eqv. is_nan(transpose(A)))) then
       2074     1      is_symmetric = .false.
       2075     1  elseif (.not. present(tol) .and. any(abs(A - transpose(A)) > ZERO)) then
       2076     1      is_symmetric = .false.
       2077     1  elseif (present(tol)) then
       2078     1      ! Do not merge the next line with the last, as Fortran may not evaluate the logical expression
       2079     1      ! in the short-circuit way.
       2080     2      if (any(abs(A - transpose(A)) > abs(tol) * max(maxval(abs(A)), ONE))) then
       2081     2          is_symmetric = .false.
       2082     2      end if
       2083     1  end if
       2084        end function issymmetric
       2085        
       2086        
       2087        function norm(x, p) result(y)
       2088        !--------------------------------------------------------------------------------------------------!
       2089        ! This function calculates the P-norm of a vector X.
       2090        !--------------------------------------------------------------------------------------------------!
       2091        use, non_intrinsic :: consts_mod, only : RP, ONE, TWO, ZERO
       2092        use, non_intrinsic :: debug_mod, only : assert
       2093        use, non_intrinsic :: infnan_mod, only : is_finite, is_posinf
       2094        implicit none
       2095        
       2096        ! Inputs
       2097        real(RP), intent(in) :: x(:)
       2098        real(RP), intent(in), optional :: p
       2099        
       2100        ! Outputs
       2101        real(RP) :: y
       2102        
       2103        ! Local variables
       2104        character(len=*), parameter :: srname = 'NORM'
       2105        real(RP) :: scaling
       2106        real(RP) :: p_loc
       2107        
       2108     1  if (present(p)) then
       2109     1      p_loc = p
       2110     1      call assert(p >= 0, 'P >= 0', srname)
       2111     1  else
       2112     1      p_loc = TWO
       2113     1  end if
       2114        
       2115     1  if (size(x) == 0) then
       2116     1      y = ZERO
       2117     1  elseif (p_loc <= 0) then
       2118     1      y = real(count(abs(x) > 0), kind(y))
       2119     1  elseif (.not. all(is_finite(x))) then
       2120     1      ! If X contains NaN, then Y is NaN. Otherwise, Y is Inf when X contains +/-Inf.
       2121     1      y = sum(abs(x))
       2122     1  elseif (.not. any(abs(x) > ZERO)) then
       2123     1      ! The following is incorrect without checking the last case, as X may be all NaN.
       2124     1      y = ZERO
       2125     1  else
       2126     2      if (is_posinf(p_loc)) then
       2127     2          y = maxval(abs(x))
       2128     2      elseif (.not. present(p) .or. abs(p_loc - TWO) <= 0) then
       2129     2          !y = sqrt(sum(x**2))
       2130     2          scaling = maxval(abs(x))  ! The scaling seems to reduce the rounding error.
       2131     2          y = scaling * sqrt(sum((x / scaling)**2))
       2132     2      else
       2133     2          !scaling = max(REALMIN, sqrt(maxval(abs(x)) * minval(abs(x), mask=(abs(x) > ZERO))))
       2134     2          scaling = maxval(abs(x))  ! The scaling seems to reduce the rounding error.
       2135     2          y = scaling * sum(abs(x / scaling)**p_loc)**(ONE / p_loc)
       2136     2      end if
       2137     1  end if
       2138        
       2139        end function norm
       2140        
       2141        function sort_i1(x, direction) result(y)
       2142        ! This function sorts X according to DIRECTION, which should be 'ascend' (default) or 'descend'.
       2143        use, non_intrinsic :: consts_mod, only : IK
       2144        #if __DEBUGGING__ == 1
       2145        use, non_intrinsic :: debug_mod, only : assert
       2146        #endif
       2147        implicit none
       2148        
       2149        ! Inputs
       2150        integer(IK), intent(in) :: x(:)
       2151        character(len=*), intent(in), optional :: direction
       2152        
       2153        ! Outputs
       2154        integer(IK) :: y(size(x))
       2155        
       2156        ! Local variables
       2157        #if __DEBUGGING__ == 1
       2158        character(len=*), parameter :: srname = 'SORT_I1'
       2159        #endif
       2160        integer(IK) :: i
       2161        integer(IK) :: n
       2162        integer(IK) :: newn
       2163        logical :: ascending
       2164        
       2165        !====================!
       2166        ! Calculation starts !
       2167        !====================!
       2168        
       2169        ascending = .true.
       2170     1  if (present(direction)) then
       2171     2      if (direction == 'descend' .or. direction == 'DESCEND') then
       2172     2          ascending = .false.
       2173     2      end if
       2174     1  end if
       2175        
       2176        y = x
       2177        n = int(size(y), kind(n))
       2178     1  do while (n > 1)  ! Bubble sort.
       2179     1      newn = 0
       2180     2      do i = 2, n
       2181     3          if ((y(i - 1) > y(i) .and. ascending) .or. (y(i - 1) < y(i) .and. .not. ascending)) then
       2182     3              y([i - 1_IK, i]) = y([i, i - 1_IK])
       2183     3              newn = i
       2184     3          end if
       2185     2      end do
       2186     1      n = newn
       2187     1  end do
       2188        
       2189        !====================!
       2190        !  Calculation ends  !
       2191        !====================!
       2192        
       2193        ! Postconditions
       2194        #if __DEBUGGING__ == 1
       2195     1  if (ascending) then
       2196     1      call assert(all(y(1:n - 1) <= y(2:n)), 'Y is ascending', srname)
       2197     1  else
       2198     1      call assert(all(y(1:n - 1) >= y(2:n)), 'Y is descending', srname)
       2199     1  end if
       2200        #endif
       2201        end function sort_i1
       2202        
       2203        function sort_i2(x, dim, direction) result(y)
       2204        ! This function sorts a matrix X according to DIM (1 or 2) and DIRECTION ('ascend' or 'descend').
       2205        #if __DEBUGGING__ == 1
       2206        use, non_intrinsic :: debug_mod, only : assert
       2207        #endif
       2208        use, non_intrinsic :: consts_mod, only : IK
       2209        implicit none
       2210        
       2211        ! Inputs
       2212        integer(IK), intent(in) :: x(:, :)
       2213        integer, intent(in), optional :: dim
       2214        character(len=*), intent(in), optional :: direction
       2215        
       2216        ! Outputs
       2217        integer(IK) :: y(size(x, 1), size(x, 2))
       2218        
       2219        ! Local variables
       2220        #if __DEBUGGING__ == 1
       2221        character(len=*), parameter :: srname = 'SORT_I2'
       2222        integer(IK) :: n
       2223        #endif
       2224        character(len=100) :: direction_loc
       2225        integer :: dim_loc
       2226        integer(IK) :: i
       2227        
       2228        !====================!
       2229        ! Calculation starts !
       2230        !====================!
       2231        
       2232        dim_loc = 1
       2233     1  if (present(dim)) then
       2234     1      dim_loc = dim
       2235     1  end if
       2236        
       2237        direction_loc = 'ascend'
       2238     1  if (present(direction)) then
       2239     1      direction_loc = direction
       2240     1  end if
       2241        
       2242        y = x
       2243     1  if (dim_loc == 1) then
       2244     2      do i = 1, int(size(x, 2), IK)
       2245     2          y(:, i) = sort_i1(y(:, i), trim(direction_loc))
       2246     2      end do
       2247     1  else
       2248     2      do i = 1, int(size(x, 1), IK)
       2249     2          y(i, :) = sort_i1(y(i, :), trim(direction_loc))
       2250     2      end do
       2251     1  end if
       2252        
       2253        !====================!
       2254        !  Calculation ends  !
       2255        !====================!
       2256        
       2257        ! Postconditions
       2258        #if __DEBUGGING__ == 1
       2259     1  if (dim_loc == 1) then
       2260     1      n = int(size(y, 1), kind(n))
       2261     2      if (trim(direction_loc) == 'ascend' .or. trim(direction_loc) == 'ASCEND') then
       2262     2          call assert(all(y(1:n - 1, :) <= y(2:n, :)), 'Y is ascending along dimension 1', srname)
       2263     2      else
       2264     2          call assert(all(y(1:n - 1, :) >= y(2:n, :)), 'Y is descending along dimension 1', srname)
       2265     2      end if
       2266     1  else
       2267     1      n = int(size(y, 2), kind(n))
       2268     2      if (trim(direction_loc) == 'ascend' .or. trim(direction_loc) == 'ASCEND') then
       2269     2          call assert(all(y(:, 1:n - 1) <= y(:, 2:n)), 'Y is ascending along dimension 2', srname)
       2270     2      else
       2271     2          call assert(all(y(:, 1:n - 1) >= y(:, 2:n)), 'Y is descending along dimension 2', srname)
       2272     2      end if
       2273     1  end if
       2274        #endif
       2275        end function sort_i2
       2276        
       2277        
       2278        pure elemental function logical_to_int(x) result(y)
       2279        !--------------------------------------------------------------------------------------------------!
       2280        ! LOGICAL_TO_INT(.TRUE.) = 1, LOGICAL_TO_INT(.FALSE.) = 0
       2281        !--------------------------------------------------------------------------------------------------!
       2282        use, non_intrinsic :: consts_mod, only : IK
       2283        implicit none
       2284        logical, intent(in) :: x
       2285        integer(IK) :: y
       2286        y = merge(tsource=1_IK, fsource=0_IK, mask=x)
       2287        end function logical_to_int
       2288        
       2289        
       2290        function trueloc(x) result(loc)
       2291        !--------------------------------------------------------------------------------------------------!
       2292        ! Similar to the `find` function in MATLAB, TRUELOC returns the indices where X is true.
       2293        !--------------------------------------------------------------------------------------------------!
       2294        use, non_intrinsic :: consts_mod, only : IK
       2295        use, non_intrinsic :: memory_mod, only : safealloc
       2296        implicit none
       2297        logical, intent(in) :: x(:)
       2298        integer(IK), allocatable :: loc(:)  ! INTEGER(IK) :: LOC(COUNT(X)) does not work with Absoft 22.0
       2299        integer(IK) :: i
       2300        call safealloc(loc, int(count(x), IK))  ! Removable in F03.
       2301        loc = pack([(i, i=1_IK, int(size(x), IK))], mask=x)
       2302        end function trueloc
       2303        
       2304        
       2305        function falseloc(x) result(loc)
       2306        !--------------------------------------------------------------------------------------------------!
       2307        ! FALSELOC = TRUELOC(.NOT. X)
       2308        !--------------------------------------------------------------------------------------------------!
       2309        use, non_intrinsic :: consts_mod, only : IK
       2310        use, non_intrinsic :: memory_mod, only : safealloc
       2311        implicit none
       2312        logical, intent(in) :: x(:)
       2313        integer(IK), allocatable :: loc(:)  ! INTEGER(IK) :: LOC(COUNT(.NOT.X)) does not work with Absoft 22.0
       2314        call safealloc(loc, int(count(.not. x), IK))  ! Removable in F03.
       2315        loc = trueloc(.not. x)
       2316        end function falseloc
       2317        
       2318        
       2319        function minimum(x) result(y)
       2320        !--------------------------------------------------------------------------------------------------!
       2321        ! This function returns NaN if X contains NaN; otherwise, it returns MINVAL(X).
       2322        ! F2018 does not specify MINVAL(X) when X contain NaN, which motivates this function.
       2323        ! Regarding NaN, the behavior of MINIMUM is the same as the following functions in various languages:
       2324        ! MATLAB: min(x, [], 'includenan')
       2325        ! Python: numpy.min(x)
       2326        ! Julia: minimum(x)
       2327        ! R: min(x)
       2328        !--------------------------------------------------------------------------------------------------!
       2329        use, non_intrinsic :: consts_mod, only : RP
       2330        use, non_intrinsic :: infnan_mod, only : is_nan
       2331        implicit none
       2332        real(RP), intent(in) :: x(:)
       2333        real(RP) :: y
       2334        y = merge(tsource=sum(x), fsource=minval(x), mask=any(is_nan(x)))
       2335        end function minimum
       2336        
       2337        
       2338        function maximum(x) result(y)
       2339        !--------------------------------------------------------------------------------------------------!
       2340        ! This function returns NaN if X contains NaN; otherwise, it returns MAXVAL(X).
       2341        ! F2018 does not specify MAXVAL(X) when X contain NaN, which motivates this function.
       2342        ! Regarding NaN, the behavior of MAXIMUM is the same as the following functions in various languages:
       2343        ! MATLAB: max(x, [], 'includenan')
       2344        ! Python: numpy.max(x)
       2345        ! Julia: maximum(x)
       2346        ! R: max(x)
       2347        !--------------------------------------------------------------------------------------------------!
       2348        use, non_intrinsic :: consts_mod, only : RP
       2349        use, non_intrinsic :: infnan_mod, only : is_nan
       2350        implicit none
       2351        real(RP), intent(in) :: x(:)
       2352        real(RP) :: y
       2353        y = merge(tsource=sum(x), fsource=maxval(x), mask=any(is_nan(x)))
       2354        end function maximum
       2355        
       2356        
       2357        end module linalg_mod

 Diagnostic messages: program name(linalg_mod)
  Module subprogram name(r1_sym)
   1333-S: "../../common/linalg.F90", line 99, column 4: Name expected.
   1333-S: "../../common/linalg.F90", line 102, column 4: Name expected.
   1333-S: "../../common/linalg.F90", line 106, column 4: Name expected.
   1185-S: "../../common/linalg.F90", line 110: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/linalg.F90", line 110, column 6: Type specification or length specification invalid.
   1185-S: "../../common/linalg.F90", line 111: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/linalg.F90", line 111, column 6: Type specification or length specification invalid.
   1185-S: "../../common/linalg.F90", line 112: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/linalg.F90", line 112, column 6: Type specification or length specification invalid.
   1185-S: "../../common/linalg.F90", line 115: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/linalg.F90", line 115, column 9: Type specification or length specification invalid.
   1619-S: "../../common/linalg.F90", line 132, column 5: 'A' not an array name or invalid array reference.
  Module subprogram name(r1)
   1333-S: "../../common/linalg.F90", line 157, column 4: Name expected.
   1333-S: "../../common/linalg.F90", line 160, column 4: Name expected.
   1185-S: "../../common/linalg.F90", line 164: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/linalg.F90", line 164, column 6: Type specification or length specification invalid.
   1185-S: "../../common/linalg.F90", line 165: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/linalg.F90", line 165, column 6: Type specification or length specification invalid.
   1185-S: "../../common/linalg.F90", line 166: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/linalg.F90", line 166, column 6: Type specification or length specification invalid.
   1185-S: "../../common/linalg.F90", line 167: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/linalg.F90", line 167, column 6: Type specification or length specification invalid.
  Module subprogram name(r2_sym)
   1333-S: "../../common/linalg.F90", line 188, column 4: Name expected.
   1333-S: "../../common/linalg.F90", line 191, column 4: Name expected.
   1333-S: "../../common/linalg.F90", line 195, column 4: Name expected.
   1185-S: "../../common/linalg.F90", line 199: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/linalg.F90", line 199, column 6: Type specification or length specification invalid.
   1185-S: "../../common/linalg.F90", line 200: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/linalg.F90", line 200, column 6: Type specification or length specification invalid.
   1185-S: "../../common/linalg.F90", line 201: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/linalg.F90", line 201, column 6: Type specification or length specification invalid.
   1185-S: "../../common/linalg.F90", line 202: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/linalg.F90", line 202, column 6: Type specification or length specification invalid.
   1185-S: "../../common/linalg.F90", line 205: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/linalg.F90", line 205, column 9: Type specification or length specification invalid.
   1619-S: "../../common/linalg.F90", line 222, column 5: 'A' not an array name or invalid array reference.
  Module subprogram name(r2)
   1333-S: "../../common/linalg.F90", line 246, column 4: Name expected.
   1333-S: "../../common/linalg.F90", line 249, column 4: Name expected.
   1185-S: "../../common/linalg.F90", line 253: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/linalg.F90", line 253, column 6: Type specification or length specification invalid.
   1185-S: "../../common/linalg.F90", line 254: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/linalg.F90", line 254, column 6: Type specification or length specification invalid.
   1185-S: "../../common/linalg.F90", line 255: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/linalg.F90", line 255, column 6: Type specification or length specification invalid.
   1185-S: "../../common/linalg.F90", line 256: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/linalg.F90", line 256, column 6: Type specification or length specification invalid.
   1185-S: "../../common/linalg.F90", line 257: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/linalg.F90", line 257, column 6: Type specification or length specification invalid.
   1185-S: "../../common/linalg.F90", line 258: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/linalg.F90", line 258, column 6: Type specification or length specification invalid.

 Procedure information
   Lines      : 2625
   Statements : 1282

 Total information
   Procedures       : 1
   Total lines      : 2625
   Total statements : 1282


 Lahey/Fujitsu Fortran 95 Compiler Release L8.10b  Sat Feb 12 17:36:58 2022
 Copyright (C) 1994-2008 Lahey Computer Systems.  All rights reserved.
 Copyright (C) 1998-2008 FUJITSU LIMITED. All rights reserved.

 Compilation information
   Current directory : /home/zaikunzhang/Bureau/neupdfo/fsrc/classical/uobyqa
   Source file       : ../../common/pintrf.f90
   Compiler options  : --ap --nblock -c --chk aefosux --chkglobal --nco 
                     : --nconcc --dal --ndbl --nf95 --nfast -g --in --info 
                     : --ninline --li --lst --nlong --maxfatals 50 --nml 
                     : --nmldefault --o0 --no --nocl --nopenmp --nparallel 
                     : --nprefetch --npca --nprivate --nquad --quiet --sav 
                     : --nshared --sse2 --nstaticlink --nswm --nthreadheap 
                     : --nthreads --trace --ntrap --nunroll --nvarheap 
                     : --nvarstack --nversion --warn --nwide --nwisk --wo --zfm 
                     : --xref

 Module "pintrf_mod"
  (line-no.)(nest)
          1        module pintrf_mod
          2        !--------------------------------------------------------------------------------------------------!
          3        ! This is a module specifying the abstract interfaces OBJ and OBJCON. OBJ evaluates the objective
          4        ! function for unconstrained, bound constrained, and linearly constrained problems; OBJCON evaluates
          5        ! the objective and constraint functions for nonlinearly constrained problems.
          6        !
          7        ! Coded by Zaikun ZHANG (www.zhangzk.net).
          8        !
          9        ! Started: July 2020.
         10        !
         11        ! Last Modified: Monday, February 07, 2022 AM12:28:54
         12        !--------------------------------------------------------------------------------------------------!
         13        
         14        !!!!!! Users must provide the implementation of OBJ or OBJCON. !!!!!!
         15        
         16        implicit none
         17        private
         18        public :: OBJ, OBJCON
         19        
         20        
         21        abstract interface
         22        
         23            subroutine OBJ(x, f)
         24            use consts_mod, only : RP
         25            implicit none
         26            real(RP), intent(in) :: x(:)
         27            real(RP), intent(out) :: f
         28            end subroutine OBJ

 Diagnostic messages: program name(pintrf_mod)
   2018-S: "../../common/pintrf.f90", line 18: When IMPLICIT NONE is specified, 'OBJCON' must be declared in a type declaration statement.
   2018-S: "../../common/pintrf.f90", line 18: When IMPLICIT NONE is specified, 'OBJ' must be declared in a type declaration statement.
   1302-S: "../../common/pintrf.f90", line 21: Not a valid Fortran statement.
   1130-S: "../../common/pintrf.f90", line 23, column 5: SUBROUTINE statement appears in invalid position.
   1130-S: "../../common/pintrf.f90", line 24, column 5: USE statement appears in invalid position.
   1603-W: "../../common/pintrf.f90", line 25, column 5: IMPLICIT statement cannot appear after a derived type definition, interface block, type declaration statement or specification statement.
   1353-S: "../../common/pintrf.f90", line 25, column 5: IMPLICIT NONE and other IMPLICIT statements cannot be specified together in the same scoping unit.
   1185-S: "../../common/pintrf.f90", line 26: In an initialization or specification expression, 'RP' must be a named constant.
   2018-S: "../../common/pintrf.f90", line 26: When IMPLICIT NONE is specified, 'RP' must be declared in a type declaration statement.
   1326-S: "../../common/pintrf.f90", line 26, column 10: Type specification or length specification invalid.
   1185-S: "../../common/pintrf.f90", line 27: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/pintrf.f90", line 27, column 10: Type specification or length specification invalid.
   1072-S: "../../common/pintrf.f90", line 28, column 5: Invalid END MODULE statement.

 Procedure information
   Lines      : 28
   Statements : 11

 Scoping unit of module : pintrf_mod
   Attribute and Cross reference of name
     OBJ
      |(Class and Type) : variable name, none
      |(Attributes)     : PUBLIC
      |(Declaration)    : 18
      |(Definition)     : 
      |(Reference)      : 
     OBJCON
      |(Class and Type) : variable name, none
      |(Attributes)     : PUBLIC
      |(Declaration)    : 18
      |(Definition)     : 
      |(Reference)      : 
     pintrf_mod
      |(Class and Type) : module name
      |(Attributes)     : PRIVATE
      |(Declaration)    : 1
      |(Definition)     : 
      |(Reference)      : 

 External subroutine subprogram "OBJCON"
  (line-no.)(nest)
         29        
         30        
         31            subroutine OBJCON(x, f, constr)
         32            use consts_mod, only : RP
         33            implicit none
         34            real(RP), intent(in) :: x(:)
         35            real(RP), intent(out) :: f
         36            real(RP), intent(out) :: constr(:)
         37            end subroutine OBJCON

 Diagnostic messages: program name(OBJCON)
   2008-I: "../../common/pintrf.f90", line 31: Dummy argument 'f' not used in this subprogram.
   2008-I: "../../common/pintrf.f90", line 34: Dummy argument 'x' not used in this subprogram.
   2008-I: "../../common/pintrf.f90", line 36: Dummy argument 'constr' not used in this subprogram.

 Procedure information
   Lines      : 9
   Statements : 7

 Scoping unit of external sub-program : OBJCON
   Attribute and Cross reference of name
     constr
      |(Class and Type) : variable name, REAL(8)
      |(Attributes)     : DIMENSION, INTENT(OUT), dummy-argument
      |(Declaration)    : 31  36
      |(Definition)     : 
      |(Reference)      : 
     consts_mod
      |(Class and Type) : module name
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 
      |(Reference)      : 32
     f
      |(Class and Type) : variable name, REAL(8)
      |(Attributes)     : INTENT(OUT), dummy-argument
      |(Declaration)    : 31  35
      |(Definition)     : 
      |(Reference)      : 
     OBJCON
      |(Class and Type) : external subroutine name
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 31
      |(Reference)      : 37
     RP
      |(Class and Type) : named constant, INTEGER(4)
      |(Attributes)     : use-associated
      |(Declaration)    : 
      |(Definition)     : 
      |(Reference)      : 32  34  35  36
     x
      |(Class and Type) : variable name, REAL(8)
      |(Attributes)     : DIMENSION, INTENT(IN), dummy-argument
      |(Declaration)    : 31  34
      |(Definition)     : 
      |(Reference)      : 

 Main program "main"
  (line-no.)(nest)
         38        
         39        end interface
         40        
         41        
         42        end module pintrf_mod

 Diagnostic messages: program name(main)
   1130-S: "../../common/pintrf.f90", line 39, column 1: END INTERFACE statement appears in invalid position.
   1075-S: "../../common/pintrf.f90", line 42, column 1: Invalid END PROGRAM statement.

 Procedure information
   Lines      : 5
   Statements : 2

 Scoping unit of program : main

 Total information
   Procedures       : 3
   Total lines      : 42
   Total statements : 20


 Lahey/Fujitsu Fortran 95 Compiler Release L8.10b  Sat Feb 12 17:36:58 2022
 Copyright (C) 1994-2008 Lahey Computer Systems.  All rights reserved.
 Copyright (C) 1998-2008 FUJITSU LIMITED. All rights reserved.

 Compilation information
   Current directory : /home/zaikunzhang/Bureau/neupdfo/fsrc/classical/uobyqa
   Source file       : ../../common/evaluate.f90
   Compiler options  : --ap --nblock -c --chk aefosux --chkglobal --nco 
                     : --nconcc --dal --ndbl --nf95 --nfast -g --in --info 
                     : --ninline --li --lst --nlong --maxfatals 50 --nml 
                     : --nmldefault --o0 --no --nocl --nopenmp --nparallel 
                     : --nprefetch --npca --nprivate --nquad --quiet --sav 
                     : --nshared --sse2 --nstaticlink --nswm --nthreadheap 
                     : --nthreads --trace --ntrap --nunroll --nvarheap 
                     : --nvarstack --nversion --warn --nwide --nwisk --wo --zfm 
                     : --xref

 Module "evaluate_mod"
  (line-no.)(nest)
          1        module evaluate_mod
          2        !--------------------------------------------------------------------------------------------------!
          3        ! This is a module evaluating the objective/constraint function with Nan/Inf handling.
          4        !
          5        ! Coded by Zaikun ZHANG (www.zhangzk.net).
          6        !
          7        ! Started: August 2021
          8        !
          9        ! Last Modified: Tuesday, February 08, 2022 PM09:59:49
         10        !--------------------------------------------------------------------------------------------------!
         11        
         12        implicit none
         13        private
         14        public :: moderatex
         15        public :: moderatef
         16        public :: moderatec
         17        public :: evaluate
         18        
         19        interface evaluate
         20            module procedure evaluatef, evaluatefc
         21        end interface evaluate
         22        
         23        
         24        contains
         25        
         26        
         27        pure elemental function moderatex(x) result(y)
         28        !--------------------------------------------------------------------------------------------------!
         29        ! This function moderates a decision variable. It replaces NaN by 0 and Inf/-Inf by HUGENUM/-HUGENUM.
         30        !--------------------------------------------------------------------------------------------------!
         31        use, non_intrinsic :: consts_mod, only : RP, ZERO, HUGENUM
         32        use, non_intrinsic :: infnan_mod, only : is_nan
         33        implicit none
         34        
         35        ! Inputs
         36        real(RP), intent(in) :: x
         37        ! Outputs
         38        real(RP) :: y
         39        
         40     1  if (is_nan(x)) then
         41     1      y = ZERO
         42     1  else
         43     1      y = x
         44     1  end if
         45        y = max(-HUGENUM, min(HUGENUM, y))
         46        end function moderatex
         47        
         48        
         49        pure elemental function moderatef(x) result(y)
         50        !--------------------------------------------------------------------------------------------------!
         51        ! This function moderates the function value of a minimization problem. It replaces NaN and any
         52        ! value above HUGEFUN by HUGEFUN.
         53        !--------------------------------------------------------------------------------------------------!
         54        use, non_intrinsic :: consts_mod, only : RP, HUGEFUN
         55        use, non_intrinsic :: infnan_mod, only : is_nan
         56        implicit none
         57        
         58        ! Inputs
         59        real(RP), intent(in) :: x
         60        ! Outputs
         61        real(RP) :: y
         62        
         63     1  if (is_nan(x)) then
         64     1      y = HUGEFUN
         65     1  else
         66     1      y = x
         67     1  end if
         68        y = min(HUGEFUN, y)
         69        !! We may moderate huge negative function values, but we decide not to.
         70        !!y = max(-HUGEFUN, min(HUGEFUN, y))
         71        end function moderatef
         72        
         73        
         74        pure elemental function moderatec(x) result(y)
         75        !--------------------------------------------------------------------------------------------------!
         76        ! This function moderates the constraint value, the constraint demanding this value to be nonnegative.
         77        ! It replaces NaN and any value below -HUGECON by -HUGECON, and any value above HUGECON by HUGECON.
         78        !--------------------------------------------------------------------------------------------------!
         79        use, non_intrinsic :: consts_mod, only : RP, HUGECON
         80        use, non_intrinsic :: infnan_mod, only : is_nan
         81        implicit none
         82        
         83        ! Inputs
         84        real(RP), intent(in) :: x
         85        ! Outputs
         86        real(RP) :: y
         87        
         88     1  if (is_nan(x)) then
         89     1      y = -HUGECON
         90     1  else
         91     1      y = x
         92     1  end if
         93        y = max(-HUGECON, min(HUGECON, y))
         94        end function moderatec
         95        
         96        
         97        subroutine evaluatef(calfun, x, f)
         98        !--------------------------------------------------------------------------------------------------!
         99        ! This function evaluates CALFUN at X, setting F to the objective function value. Nan/Inf are
        100        ! handled by a moderated extreme barrier.
        101        !--------------------------------------------------------------------------------------------------!
        102        ! Generic modules
        103        use, non_intrinsic :: consts_mod, only : RP, DEBUGGING
        104        use, non_intrinsic :: debug_mod, only : assert
        105        use, non_intrinsic :: infnan_mod, only : is_nan, is_posinf
        106        use, non_intrinsic :: pintrf_mod, only : OBJ
        107        implicit none
        108        
        109        ! Inputs
        110        procedure(OBJ) :: calfun
        111        real(RP), intent(in) :: x(:)
        112        
        113        ! Output
        114        real(RP), intent(out) :: f
        115        
        116        ! Local variables
        117        character(len=*), parameter :: srname = 'EVALF'
        118        
        119        ! Preconditions
        120     1  if (DEBUGGING) then
        121     1      ! X should not contain NaN if the initial X does not contain NaN and the subroutines generating
        122     1      ! trust-region/geometry steps work properly so that they never produce a step containing NaN/Inf.
        123     1      call assert(.not. any(is_nan(x)), 'X does not contain NaN', srname)
        124     1  end if
        125        
        126        !====================!
        127        ! Calculation starts !
        128        !====================!
        129        
        130     1  if (any(is_nan(x))) then
        131     1      ! Although this should not happen unless there is a bug, we include this case for security.
        132     1      f = sum(x)  ! Set F to NaN
        133     1  else
        134     1      call calfun(moderatex(x), f)  ! Evaluate F; We moderate X before doing so.
        135     1  
        136     1      ! Moderated extreme barrier: replace NaN/huge objective or constraint values with a large but
        137     1      ! finite value. This is naive. Better approaches surely exist.
        138     1      f = moderatef(f)
        139     1  
        140     1      !! We may moderate huge negative values of F (NOT an extreme barrier), but we decide not to.
        141     1      !!f = max(-HUGEFUN, f)
        142     1  end if
        143        
        144        
        145        !====================!
        146        !  Calculation ends  !
        147        !====================!
        148        
        149        ! Postconditions
        150     1  if (DEBUGGING) then
        151     1      ! With X not containing NaN, and with the moderated extreme barrier, F cannot be NaN/+Inf.
        152     1      call assert(.not. (is_nan(f) .or. is_posinf(f)), 'F is not NaN/+Inf', srname)
        153     1  end if
        154        
        155        end subroutine evaluatef
        156        
        157        
        158        subroutine evaluatefc(calcfc, x, f, constr, cstrv)
        159        !--------------------------------------------------------------------------------------------------!
        160        ! This function evaluates CALCFC at X, setting F to the objective function value, CONSTR to the
        161        ! constraint value, and CSTRV to the constraint violation. Nan/Inf are handled by a moderated
        162        ! extreme barrier.
        163        !--------------------------------------------------------------------------------------------------!
        164        ! Generic modules
        165        use, non_intrinsic :: consts_mod, only : RP, ZERO, DEBUGGING
        166        use, non_intrinsic :: debug_mod, only : assert
        167        use, non_intrinsic :: infnan_mod, only : is_nan, is_posinf, is_neginf
        168        use, non_intrinsic :: pintrf_mod, only : OBJCON
        169        implicit none
        170        
        171        ! Inputs
        172        procedure(OBJCON) :: calcfc
        173        real(RP), intent(in) :: x(:)
        174        
        175        ! Outputs
        176        real(RP), intent(out) :: f
        177        real(RP), intent(out) :: constr(:)
        178        real(RP), intent(out) :: cstrv
        179        
        180        ! Local variables
        181        character(len=*), parameter :: srname = 'EVALFC'
        182        
        183        ! Preconditions
        184     1  if (DEBUGGING) then
        185     1      ! X should not contain NaN if the initial X does not contain NaN and the subroutines generating
        186     1      ! trust-region/geometry steps work properly so that they never produce a step containing NaN/Inf.
        187     1      call assert(.not. any(is_nan(x)), 'X does not contain NaN', srname)
        188     1  end if
        189        
        190        !====================!
        191        ! Calculation starts !
        192        !====================!
        193        
        194     1  if (any(is_nan(x))) then
        195     1      ! Although this should not happen unless there is a bug, we include this case for security.
        196     1      ! Set F, CONSTR, and CSTRV to NaN.
        197     1      f = sum(x)
        198     1      constr = f
        199     1      cstrv = f
        200     1  else
        201     1      call calcfc(moderatex(x), f, constr)  ! Evaluate F and CONSTR; We moderate X before doing so.
        202     1  
        203     1      ! Moderated extreme barrier: replace NaN/huge objective or constraint values with a large but
        204     1      ! finite value. This is naive, and better approaches surely exist.
        205     1      f = moderatef(f)
        206     1      constr = moderatec(constr)
        207     1      !! We may moderate huge negative values of F (NOT an extreme barrier), but we decide not to.
        208     1      !!f = max(-HUGEFUN, f)
        209     1  
        210     1      ! Evaluate the constraint violation for constraints CONSTR(X) >= 0.
        211     1      cstrv = maxval([-constr, ZERO])
        212     1  end if
        213        
        214        !====================!
        215        !  Calculation ends  !
        216        !====================!
        217        
        218        ! Postconditions
        219     1  if (DEBUGGING) then
        220     1      ! With X not containing NaN, and with the moderated extreme barrier, F cannot be NaN/+Inf, and
        221     1      ! CONSTR cannot be NaN/-Inf.
        222     1      call assert(.not. (is_nan(f) .or. is_posinf(f)), 'F is not NaN/+Inf', srname)
        223     1      call assert(.not. any(is_nan(constr) .or. is_neginf(constr)), &
        224     1          & 'CONSTR does not containt NaN/-Inf', srname)
        225     1      call assert(.not. (cstrv < ZERO .or. is_nan(cstrv) .or. is_posinf(cstrv)), &
        226     1          & 'CSTRV is nonnegative and not NaN/+Inf', srname)
        227     1  end if
        228        
        229        end subroutine evaluatefc
        230        
        231        
        232        end module evaluate_mod

 Diagnostic messages: program name(evaluate_mod)
  Module subprogram name(moderatex)
   1090-S: "../../common/evaluate.f90", line 27: Dummy argument of pure function 'x' must have the INTENT(IN) attribute unless it is a procedure argument or an argument with the POINTER attribute.
   2018-S: "../../common/evaluate.f90", line 27: When IMPLICIT NONE is specified, 'y' must be declared in a type declaration statement.
   1333-S: "../../common/evaluate.f90", line 31, column 4: Name expected.
   1333-S: "../../common/evaluate.f90", line 32, column 4: Name expected.
   1185-S: "../../common/evaluate.f90", line 36: In an initialization or specification expression, 'RP' must be a named constant.
   2018-S: "../../common/evaluate.f90", line 36: When IMPLICIT NONE is specified, 'RP' must be declared in a type declaration statement.
   1326-S: "../../common/evaluate.f90", line 36, column 6: Type specification or length specification invalid.
   1185-S: "../../common/evaluate.f90", line 38: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/evaluate.f90", line 38, column 6: Type specification or length specification invalid.
   2018-S: "../../common/evaluate.f90", line 41: When IMPLICIT NONE is specified, 'ZERO' must be declared in a type declaration statement.
   2018-S: "../../common/evaluate.f90", line 45: When IMPLICIT NONE is specified, 'HUGENUM' must be declared in a type declaration statement.
  Module subprogram name(moderatef)
   1090-S: "../../common/evaluate.f90", line 49: Dummy argument of pure function 'x' must have the INTENT(IN) attribute unless it is a procedure argument or an argument with the POINTER attribute.
   1333-S: "../../common/evaluate.f90", line 54, column 4: Name expected.
   1333-S: "../../common/evaluate.f90", line 55, column 4: Name expected.
   1185-S: "../../common/evaluate.f90", line 59: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/evaluate.f90", line 59, column 6: Type specification or length specification invalid.
   1185-S: "../../common/evaluate.f90", line 61: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/evaluate.f90", line 61, column 6: Type specification or length specification invalid.
  Module subprogram name(moderatec)
   1090-S: "../../common/evaluate.f90", line 74: Dummy argument of pure function 'x' must have the INTENT(IN) attribute unless it is a procedure argument or an argument with the POINTER attribute.
   1333-S: "../../common/evaluate.f90", line 79, column 4: Name expected.
   1333-S: "../../common/evaluate.f90", line 80, column 4: Name expected.
   1185-S: "../../common/evaluate.f90", line 84: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/evaluate.f90", line 84, column 6: Type specification or length specification invalid.
   1185-S: "../../common/evaluate.f90", line 86: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/evaluate.f90", line 86, column 6: Type specification or length specification invalid.
  Module subprogram name(evaluatef)
   1333-S: "../../common/evaluate.f90", line 103, column 4: Name expected.
   1333-S: "../../common/evaluate.f90", line 104, column 4: Name expected.
   1333-S: "../../common/evaluate.f90", line 105, column 4: Name expected.
   1333-S: "../../common/evaluate.f90", line 106, column 4: Name expected.
   1302-S: "../../common/evaluate.f90", line 110: Not a valid Fortran statement.
   1185-S: "../../common/evaluate.f90", line 111: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/evaluate.f90", line 111, column 6: Type specification or length specification invalid.
   1185-S: "../../common/evaluate.f90", line 114: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/evaluate.f90", line 114, column 6: Type specification or length specification invalid.
  Module subprogram name(evaluatefc)
   1333-S: "../../common/evaluate.f90", line 165, column 4: Name expected.
   1333-S: "../../common/evaluate.f90", line 166, column 4: Name expected.
   1333-S: "../../common/evaluate.f90", line 167, column 4: Name expected.
   1333-S: "../../common/evaluate.f90", line 168, column 4: Name expected.
   1302-S: "../../common/evaluate.f90", line 172: Not a valid Fortran statement.
   1185-S: "../../common/evaluate.f90", line 173: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/evaluate.f90", line 173, column 6: Type specification or length specification invalid.
   1185-S: "../../common/evaluate.f90", line 176: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/evaluate.f90", line 176, column 6: Type specification or length specification invalid.
   1185-S: "../../common/evaluate.f90", line 177: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/evaluate.f90", line 177, column 6: Type specification or length specification invalid.
   1185-S: "../../common/evaluate.f90", line 178: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/evaluate.f90", line 178, column 6: Type specification or length specification invalid.
   1006-S: "../../common/evaluate.f90", line 211, column 20: Character not allowed by syntax rules or not a valid Fortran character.
   1035-S: "../../common/evaluate.f90", line 211, column 20: Invalid operator.
   1439-S: "../../common/evaluate.f90", line 211, column 21: Invalid correspondence between operator and operand.

 Procedure information
   Lines      : 232
   Statements : 105

 Total information
   Procedures       : 1
   Total lines      : 232
   Total statements : 105


 Lahey/Fujitsu Fortran 95 Compiler Release L8.10b  Sat Feb 12 17:36:58 2022
 Copyright (C) 1994-2008 Lahey Computer Systems.  All rights reserved.
 Copyright (C) 1998-2008 FUJITSU LIMITED. All rights reserved.

 Compilation information
   Current directory : /home/zaikunzhang/Bureau/neupdfo/fsrc/classical/uobyqa
   Source file       : ../../common/history.f90
   Compiler options  : --ap --nblock -c --chk aefosux --chkglobal --nco 
                     : --nconcc --dal --ndbl --nf95 --nfast -g --in --info 
                     : --ninline --li --lst --nlong --maxfatals 50 --nml 
                     : --nmldefault --o0 --no --nocl --nopenmp --nparallel 
                     : --nprefetch --npca --nprivate --nquad --quiet --sav 
                     : --nshared --sse2 --nstaticlink --nswm --nthreadheap 
                     : --nthreads --trace --ntrap --nunroll --nvarheap 
                     : --nvarstack --nversion --warn --nwide --nwisk --wo --zfm 
                     : --xref

 Module "history_mod"
  (line-no.)(nest)
          1        module history_mod
          2        !--------------------------------------------------------------------------------------------------!
          3        ! This module provides subroutines that handle the X/F/C histories of the solver, taking into
          4        ! account that MAXHIST may be smaller than NF.
          5        !
          6        ! Coded by Zaikun ZHANG (www.zhangzk.net).
          7        !
          8        ! Started: July 2020
          9        !
         10        ! Last Modified: Wednesday, February 09, 2022 AM12:32:57
         11        !--------------------------------------------------------------------------------------------------!
         12        
         13        implicit none
         14        private
         15        public :: prehist
         16        public :: savehist
         17        public :: rangehist
         18        
         19        
         20        contains
         21        
         22        
         23        subroutine prehist(maxhist, n, output_xhist, xhist, output_fhist, fhist, output_chist, chist, m, output_conhist, conhist)
         24        !--------------------------------------------------------------------------------------------------!
         25        ! This subroutine revises MAXHIST according to MAXMEMORY, and allocates memory for the history.
         26        ! In MATLAB/Python/Julia/R implementation, we should simply set MAXHIST = MAXFUN and initialize
         27        ! XHIST = NaN(N, MAXFUN), FHIST = NaN(1, MAXFUN), CHIST = NaN(1, MAXFUN), CONHIST = NaN(M, MAXFUN),
         28        ! if they are requested; replace MAXFUN with 0 for the history that is not requested.
         29        !--------------------------------------------------------------------------------------------------!
         30        use, non_intrinsic :: consts_mod, only : RP, IK, MAXMEMORY, DEBUGGING
         31        use, non_intrinsic :: debug_mod, only : assert
         32        use, non_intrinsic :: linalg_mod, only : int
         33        use, non_intrinsic :: memory_mod, only : safealloc, cstyle_sizeof
         34        implicit none
         35        
         36        ! Inputs
         37        integer(IK), intent(in) :: n
         38        integer(IK), intent(in), optional :: m
         39        logical, intent(in) :: output_fhist
         40        logical, intent(in) :: output_xhist
         41        logical, intent(in), optional :: output_chist
         42        logical, intent(in), optional :: output_conhist
         43        
         44        ! In-outputs
         45        integer(IK), intent(inout) :: maxhist
         46        
         47        ! Outputs
         48        real(RP), intent(out), allocatable :: fhist(:)
         49        real(RP), intent(out), allocatable :: xhist(:, :)
         50        real(RP), intent(out), optional, allocatable :: chist(:)
         51        real(RP), intent(out), optional, allocatable :: conhist(:, :)
         52        
         53        ! Local variables
         54        character(len=*), parameter :: srname = 'PREHIST'
         55        integer(IK) :: maxhist_in
         56        integer(IK) :: unit_memo
         57        
         58        ! Preconditions
         59     1  if (DEBUGGING) then
         60     1      call assert(maxhist >= 0, 'MAXHIST >= 0', srname)
         61     1      call assert(n >= 1, 'N >= 1', srname)
         62     2      if (present(m)) then
         63     2          call assert(m >= 0, 'M >= 0', srname)
         64     2      end if
         65     1      call assert(present(output_chist) .eqv. present(chist), &
         66     1          & 'OUTPUT_CHIST and CHIST are both present or both absent', srname)
         67     1      call assert((present(m) .eqv. present(conhist)) .and. (present(output_conhist) .eqv. present(conhist)), &
         68     1          & 'M, OUTPUT_CONHIST, and CONHIST are all present or all absent', srname)
         69     1  end if
         70        
         71        !====================!
         72        ! Calculation starts !
         73        !====================!
         74        
         75        ! Save the input value of MAXHIST for debugging.
         76        maxhist_in = maxhist
         77        
         78        ! Revise MAXHIST according to MAXMEMORY, i.e., the maximal memory allowed for the history.
         79        unit_memo = int(output_xhist) * n + int(output_fhist)
         80     1  if (present(output_chist) .and. present(chist)) then
         81     1      unit_memo = unit_memo + int(output_chist)
         82     1  end if
         83     1  if (present(m) .and. present(output_conhist) .and. present(conhist)) then
         84     1      unit_memo = unit_memo + int(output_conhist) * m
         85     1  end if
         86        unit_memo = unit_memo * cstyle_sizeof(0.0_RP)
         87     1  if (unit_memo <= 0) then  ! No output of history is requested
         88     1      maxhist = 0_IK
         89     1  elseif (maxhist > MAXMEMORY / unit_memo) then
         90     1      maxhist = int(MAXMEMORY / unit_memo, kind(maxhist))
         91     1      ! We cannot simply set MAXHIST = MIN(MAXHIST, MAXMEMORY/UNIT_MEMO), as they may not have
         92     1      ! the same kind, and compilers may complain. We may convert them, but overflow may occur.
         93     1  end if
         94        
         95        call safealloc(xhist, n, maxhist * int(output_xhist))
         96        call safealloc(fhist, maxhist * int(output_fhist))
         97        ! Even if OUTPUT_CHIST is FALSE, CHIST still needs to be allocated.
         98     1  if (present(output_chist) .and. present(chist)) then
         99     1      call safealloc(chist, maxhist * int(output_chist))
        100     1  end if
        101        ! Even if OUTPUT_CONHIST is FALSE, CONHIST still needs to be allocated.
        102     1  if (present(m) .and. present(output_conhist) .and. present(conhist)) then
        103     1      call safealloc(conhist, m, maxhist * int(output_conhist))
        104     1  end if
        105        
        106        !====================!
        107        !  Calculation ends  !
        108        !====================!
        109        
        110        ! Postconditions
        111     1  if (DEBUGGING) then
        112     1      call assert(maxhist >= 0 .and. maxhist <= maxhist_in, '0 <= MAXHIST <= MAXHIST_IN', srname)
        113     1      call assert(int(maxhist, kind(MAXMEMORY)) * int(unit_memo, kind(MAXMEMORY)) <= MAXMEMORY, &
        114     1          & 'The history will not take more memory than MAXMEMORY', srname)
        115     1      call assert(allocated(xhist), 'XHIST is allocated', srname)
        116     1      call assert(size(xhist, 1) == n .and. size(xhist, 2) == maxhist * int(output_xhist), &
        117     1          & 'if XHIST is requested, then SIZE(XHIST) == [N, MAXHIST]; otherwise, SIZE(XHIST) == [N, 0]', srname)
        118     1      call assert(allocated(fhist), 'FHIST is allocated', srname)
        119     1      call assert(size(fhist) == maxhist * int(output_fhist), &
        120     1          & 'if FHIST is requested, then SIZE(FHIST) == MAXHIST; otherwise, SIZE(FHIST) == 0', srname)
        121     2      if (present(output_chist) .and. present(chist)) then
        122     2          call assert(allocated(chist), 'CHIST is allocated', srname)
        123     2          call assert(size(chist) == maxhist * int(output_chist), &
        124     2              & 'if CHIST is requested, then SIZE(CHIST) == MAXHIST; otherwise, SIZE(CHIST) == 0', srname)
        125     2      end if
        126     2      if (present(m) .and. present(output_conhist) .and. present(conhist)) then
        127     2          call assert(allocated(conhist), 'CONHIST is allocated', srname)
        128     2          call assert(size(conhist, 1) == m .and. size(conhist, 2) == maxhist * int(output_conhist), &
        129     2              & 'if CONHIST is requested, then SIZE(CONHIST) == [M, MAXHIST]; otherwise, SIZE(CONHIST) == [M, 0]', srname)
        130     2      end if
        131     1  end if
        132        end subroutine prehist
        133        
        134        
        135        subroutine savehist(nf, x, xhist, f, fhist, cstrv, chist, constr, conhist)
        136        !--------------------------------------------------------------------------------------------------!
        137        ! This subroutine saves X, F, CSTRV, and CONSTR into XHIST, FHIST, CHIST, and CONHIST respectively.
        138        !--------------------------------------------------------------------------------------------------!
        139        use, non_intrinsic :: consts_mod, only : RP, IK, DEBUGGING
        140        use, non_intrinsic :: debug_mod, only : assert
        141        use, non_intrinsic :: infnan_mod, only : is_nan, is_finite, is_posinf, is_neginf
        142        implicit none
        143        
        144        ! Inputs
        145        integer(IK), intent(in) :: nf
        146        real(RP), intent(in) :: f
        147        real(RP), intent(in) :: x(:)
        148        real(RP), intent(in), optional :: constr(:)
        149        real(RP), intent(in), optional :: cstrv
        150        
        151        ! In-outputs
        152        real(RP), intent(inout) :: fhist(:)
        153        real(RP), intent(inout) :: xhist(:, :)
        154        real(RP), intent(inout), optional :: chist(:)
        155        real(RP), intent(inout), optional :: conhist(:, :)
        156        
        157        ! Local variables
        158        integer(IK) :: maxchist
        159        integer(IK) :: maxconhist
        160        integer(IK) :: maxfhist
        161        integer(IK) :: maxhist
        162        integer(IK) :: maxxhist
        163        character(len=*), parameter :: srname = 'SAVEHIST'
        164        
        165        ! Sizes
        166        maxxhist = int(size(xhist, 2), kind(maxxhist))
        167        maxfhist = int(size(fhist), kind(maxfhist))
        168     1  if (present(chist) .and. present(cstrv)) then
        169     1      maxchist = int(size(chist), kind(maxchist))
        170     1  else
        171     1      maxchist = 0_IK
        172     1  end if
        173     1  if (present(conhist) .and. present(constr)) then
        174     1      maxconhist = int(size(conhist, 2), kind(maxconhist))
        175     1  else
        176     1      maxconhist = 0_IK
        177     1  end if
        178        maxhist = max(maxxhist, maxfhist, maxchist, maxconhist)
        179        
        180        ! Preconditions
        181     1  if (DEBUGGING) then  ! Called after each function evaluation when debugging; can be expensive.
        182     1      ! Check the presence of CSTRV, CHIST, CONSTR, CONHIST.
        183     1      call assert(present(cstrv) .eqv. present(chist), 'CSTRV and CHIST are both present or both absent', srname)
        184     1      call assert(present(constr) .eqv. present(conhist), 'CONSTR and CONHIST are both present or both absent', srname)
        185     1      ! Check the size of X.
        186     1      call assert(size(x) >= 1, 'SIZE(X) >= 1', srname)
        187     1      ! Check the sizes of XHIST, FHIST, CONHIST, CHIST.
        188     1      call assert(size(xhist, 1) == size(x) .and. maxxhist * (maxxhist - maxhist) == 0, &
        189     1          & 'SIZE(XHIST, 1) == SIZE(X), SIZE(XHIST, 2) == 0 or MAXHIST', srname)
        190     1      call assert(maxfhist * (maxfhist - maxhist) == 0, 'SIZE(FHIST) == 0 or MAXHIST', srname)
        191     1      call assert(maxchist * (maxchist - maxhist) == 0, 'SIZE(CHIST) == 0 or MAXHIST', srname)
        192     2      if (present(constr) .and. present(conhist)) then
        193     2          call assert(size(conhist, 1) == size(constr) .and. maxconhist * (maxconhist - maxhist) == 0, &
        194     2              & 'SIZE(CONHIST, 1) == SIZE(CONSTR), SIZE(CONHIST, 2) == 0 or MAXNHIST', srname)
        195     2      end if
        196     1      ! Check the values of XHIST, FHIST, CHIST, CONHIST, up to the (NF - 1)th position.
        197     1      ! As long as this subroutine is called, XHIST contains only finite values.
        198     1      call assert(all(is_finite(xhist(:, 1:min(nf - 1_IK, maxxhist)))), 'XHIST is finite', srname)
        199     1      call assert(.not. any(is_nan(fhist(1:min(nf - 1_IK, maxfhist))) .or. &
        200     1          & is_posinf(fhist(1:min(nf - 1_IK, maxfhist)))), 'FHIST does not contain NaN/+Inf', srname)
        201     1      !----------------------------------------------------------------------------------------------!
        202     1      ! The following test is not applicable to LINCOA.
        203     1      !!if (present(chist)) then
        204     1      !!    call assert(.not. any(chist(1:min(nf - 1_IK, maxchist)) < 0 .or. &
        205     1      !!        & is_nan(chist(1:min(nf - 1_IK, maxchist))) .or. is_posinf(chist(1:min(nf - 1_IK, maxchist)))), &
        206     1      !!        & 'CHIST does not contain nonnegative values or NaN/+Inf', srname)
        207     1      !!end if
        208     1      !----------------------------------------------------------------------------------------------!
        209     2      if (present(conhist)) then
        210     2          call assert(.not. any(is_nan(conhist(:, 1:min(nf - 1_IK, maxconhist))) .or. &
        211     2              & is_neginf(conhist(:, 1:min(nf - 1_IK, maxconhist)))), 'CONHIST does not contain NaN/-Inf', srname)
        212     2      end if
        213     1      ! Check the values of X, F, CSTRV, CONSTR.
        214     1      ! X does not contain NaN if X0 does not and the trust-region/geometry steps are proper.
        215     1      call assert(.not. any(is_nan(x)), 'X does not contain NaN', srname)
        216     1      ! F cannot be NaN/+Inf due to the moderated extreme barrier.
        217     1      call assert(.not. (is_nan(f) .or. is_posinf(f)), 'F is not NaN/+Inf', srname)
        218     1      !----------------------------------------------------------------------------------------------!
        219     1      ! The following test is not applicable to LINCOA.
        220     1      !!if (present(cstrv)) then
        221     1      !!    ! CSTRV cannot be NaN/+Inf due to the moderated extreme barrier.
        222     1      !!    call assert(.not. (cstrv < 0 .or. is_nan(cstrv) .or. is_posinf(cstrv)), &
        223     1      !!        & 'CSTRV is nonnegative and not NaN/+Inf', srname)
        224     1      !!end if
        225     1      !----------------------------------------------------------------------------------------------!
        226     2      if (present(constr)) then
        227     2          ! CONSTR cannot contain NaN/-Inf due to the moderated extreme barrier.
        228     2          call assert(.not. any(is_nan(constr) .or. is_neginf(constr)), 'CONSTR does not contain NaN/-Inf', srname)
        229     2      end if
        230     1  end if
        231        
        232        !====================!
        233        ! Calculation starts !
        234        !====================!
        235        
        236        ! Save the history. Note that NF may exceed the maximal amount of history to save. We save X and F
        237        ! at the position indexed by MODULO(NF - 1, MAXHIST) + 1. When the solver terminates, the history
        238        ! will be reordered so that the information is in the chronological order. Similar for CONSTR, CSTRV.
        239     1  if (maxxhist > 0) then
        240     1      ! We could replace MODULO(NF - 1_IK, MAXXHIST) + 1_IK) with MODULO(NF - 1_IK, MAXHIST) + 1_IK)
        241     1      ! based on the assumption that MAXXHIST == 0 or MAXHIST. For robustness, we do not do that.
        242     1      xhist(:, modulo(nf - 1_IK, maxxhist) + 1_IK) = x
        243     1  end if
        244     1  if (maxfhist > 0) then
        245     1      fhist(modulo(nf - 1_IK, maxfhist) + 1_IK) = f
        246     1  end if
        247     1  if (maxchist > 0) then  ! MAXCHIST > 0 implies PRESENT(CHIST) and PRESENT(CSTRV)
        248     1      chist(modulo(nf - 1_IK, maxchist) + 1_IK) = cstrv
        249     1  end if
        250     1  if (maxconhist > 0) then  ! MAXCONHIST > 0 implies PRESENT(CONHIST) and PRESENT (CONSTR)
        251     1      conhist(:, modulo(nf - 1_IK, maxconhist) + 1_IK) = constr
        252     1  end if
        253        
        254        !====================!
        255        !  Calculation ends  !
        256        !====================!
        257        
        258        ! Postconditions
        259     1  if (DEBUGGING) then  ! Called after each function evaluation when debugging; can be expensive.
        260     1      call assert(size(xhist, 1) == size(x) .and. size(xhist, 2) == maxxhist, 'SIZE(XHIST) == [SIZE(X), MAXXHIST]', srname)
        261     1      call assert(.not. any(is_nan(xhist(:, 1:min(nf, maxxhist)))), 'XHIST does not contain NaN', srname)
        262     1      ! The last calculated X can be Inf (finite + finite can be Inf numerically).
        263     1      call assert(size(fhist) == maxfhist, 'SIZE(FHIST) == MAXFHIST', srname)
        264     1      call assert(.not. any(is_nan(fhist(1:min(nf, maxfhist))) .or. is_posinf(fhist(1:min(nf, maxfhist)))), &
        265     1          & 'FHIST does not contain NaN/+Inf', srname)
        266     1      !----------------------------------------------------------------------------------------------!
        267     1      ! The following test is not applicable to LINCOA.
        268     1      !!if (present(chist)) then
        269     1      !!    call assert(size(chist) == maxchist, 'SIZE(CHIST) == MAXCHIST', srname)
        270     1      !!    call assert(.not. any(chist(1:min(nf, maxchist)) < 0 .or. is_nan(chist(1:min(nf, maxchist))) .or. &
        271     1      !!        & is_posinf(chist(1:min(nf, maxchist)))), 'CHIST does not contain nonnegative values or NaN/+Inf', srname)
        272     1      !!end if
        273     1      !----------------------------------------------------------------------------------------------!
        274     2      if (present(conhist) .and. present(constr)) then
        275     2          call assert(size(conhist, 1) == size(constr) .and. size(conhist, 2) == maxconhist, &
        276     2              & 'SIZE(CONHIST) == [SIZE(CONSTR), MAXCONHIST]', srname)
        277     2          call assert(.not. any(is_nan(conhist(:, 1:min(nf, maxconhist))) .or. &
        278     2              & is_neginf(conhist(:, 1:min(nf, maxconhist)))), 'CONHIST does not contain NaN/-Inf', srname)
        279     2      end if
        280     1  end if
        281        
        282        end subroutine savehist
        283        
        284        
        285        subroutine rangehist(nf, xhist, fhist, chist, conhist)
        286        !--------------------------------------------------------------------------------------------------!
        287        ! This subroutine arranges FHIST, XHIST, CHIST, and CONHIST in the chronological order.
        288        !--------------------------------------------------------------------------------------------------!
        289        use, non_intrinsic :: consts_mod, only : RP, IK, DEBUGGING
        290        use, non_intrinsic :: infnan_mod, only : is_nan, is_posinf, is_neginf
        291        use, non_intrinsic :: debug_mod, only : assert
        292        implicit none
        293        
        294        ! Inputs
        295        integer(IK), intent(in) :: nf
        296        
        297        ! In-outputs
        298        real(RP), intent(inout) :: fhist(:)
        299        real(RP), intent(inout) :: xhist(:, :)
        300        real(RP), intent(inout), optional :: chist(:)
        301        real(RP), intent(inout), optional :: conhist(:, :)
        302        
        303        ! Local variables
        304        integer(IK) :: khist
        305        integer(IK) :: maxchist
        306        integer(IK) :: maxconhist
        307        integer(IK) :: maxfhist
        308        integer(IK) :: maxhist
        309        integer(IK) :: maxxhist
        310        integer(IK) :: m
        311        integer(IK) :: n
        312        character(len=*), parameter :: srname = 'RANGEHIST'
        313        
        314        ! Sizes
        315        n = int(size(xhist, 1), kind(n))
        316        maxxhist = int(size(xhist, 2), kind(maxxhist))
        317        maxfhist = int(size(fhist), kind(maxfhist))
        318     1  if (present(chist)) then
        319     1      maxchist = int(size(chist), kind(maxchist))
        320     1  else
        321     1      maxchist = 0_IK
        322     1  end if
        323     1  if (present(conhist)) then
        324     1      m = int(size(conhist, 1), kind(m))
        325     1      maxconhist = int(size(conhist, 2), kind(maxconhist))
        326     1  else
        327     1      m = 0_IK
        328     1      maxconhist = 0_IK
        329     1  end if
        330        maxhist = max(maxxhist, maxfhist, maxconhist, maxchist)
        331        
        332        ! Preconditions
        333     1  if (DEBUGGING) then
        334     1      ! Check the sizes of XHIST, FHIST, CHIST, CONHIST.
        335     1      call assert(n >= 1, 'SIZE(XHIST, 1) >= 1', srname)
        336     1      call assert(maxxhist * (maxxhist - maxhist) == 0, 'SIZE(XHIST, 2) == 0 or MAXHIST', srname)
        337     1      call assert(maxfhist * (maxfhist - maxhist) == 0, 'SIZE(FHIST) == 0 or MAXHIST', srname)
        338     1      call assert(maxchist * (maxchist - maxhist) == 0, 'SIZE(CHIST) == 0 or MAXHIST', srname)
        339     1      call assert(maxconhist * (maxconhist - maxhist) == 0, 'SIZE(CONHIST, 2) == 0 or MAXHIST', srname)
        340     1      ! Check the values of XHIST, FHIST, CHIST, CONHIST.
        341     1      call assert(.not. any(is_nan(xhist(:, 1:min(nf, maxxhist)))), 'XHIST does not contain NaN', srname)
        342     1      ! The last calculated X can be Inf (finite + finite can be Inf numerically).
        343     1      call assert(.not. any(is_nan(fhist(1:min(nf, maxfhist))) .or. &
        344     1          & is_posinf(fhist(1:min(nf, maxfhist)))), 'FHIST does not contain NaN/+Inf', srname)
        345     1      !----------------------------------------------------------------------------------------------!
        346     1      ! The following test is not applicable to LINCOA
        347     1      !!if (present(chist)) then
        348     1      !!call assert(.not. any(chist(1:min(nf, maxchist)) < 0 .or. is_nan(chist(1:min(nf, maxchist))) .or. &
        349     1      !!    & is_posinf(chist(1:min(nf, maxchist)))), 'CHIST does not contain nonnegative values or NaN/+Inf', srname)
        350     1      !!end if
        351     1      !----------------------------------------------------------------------------------------------!
        352     2      if (present(conhist)) then
        353     2          call assert(.not. any(is_nan(conhist(:, 1:min(nf, maxconhist))) .or. &
        354     2              & is_neginf(conhist(:, 1:min(nf, maxconhist)))), 'CONHIST does not contain NaN/-Inf', srname)
        355     2      end if
        356     1  end if
        357        
        358        !====================!
        359        ! Calculation starts !
        360        !====================!
        361        
        362        ! The ranging should be done only if 0 < MAXXHIST < NF. Otherwise, it leads to errors/wrong results.
        363     1  if (maxxhist > 0 .and. maxxhist < nf) then
        364     1      ! We could replace MODULO(NF - 1_IK, MAXXHIST) + 1_IK) with MODULO(NF - 1_IK, MAXHIST) + 1_IK)
        365     1      ! based on the assumption that MAXXHIST == 0 or MAXHIST. For robustness, we do not do that.
        366     1      khist = modulo(nf - 1_IK, maxxhist) + 1_IK
        367     1      xhist = reshape([xhist(:, khist + 1:maxxhist), xhist(:, 1:khist)], shape(xhist))
        368     1      ! N.B.:
        369     1      ! 1. The result of the array constructor is always a rank-1 array (e.g., vector), no matter what
        370     1      ! elements are used for the construction.
        371     1      ! 2. The above combination of SHAPE and RESHAPE fulfills our desire thanks to the COLUMN-MAJOR
        372     1      ! order of Fortran arrays.
        373     1      ! 3. In MATLAB, `xhist = [xhist(:, khist + 1:maxxhist), xhist(:, 1:khist)]` does the same thing.
        374     1  end if
        375        ! The ranging should be done only if 0 < MAXFHIST < NF. Otherwise, it leads to errors/wrong results.
        376     1  if (maxfhist > 0 .and. maxfhist < nf) then
        377     1      khist = modulo(nf - 1_IK, maxfhist) + 1_IK
        378     1      fhist = [fhist(khist + 1:maxfhist), fhist(1:khist)]
        379     1  end if
        380        ! The ranging should be done only if 0 < MAXCONHIST < NF. Otherwise, it leads to errors/wrong results.
        381     1  if (maxconhist > 0 .and. maxconhist < nf) then
        382     1      khist = modulo(nf - 1_IK, maxconhist) + 1_IK
        383     1      conhist = reshape([conhist(:, khist + 1:maxconhist), conhist(:, 1:khist)], shape(conhist))
        384     1  end if
        385        ! The ranging should be done only if 0 < MAXCHIST < NF. Otherwise, it leads to errors/wrong results.
        386     1  if (maxchist > 0 .and. maxchist < nf) then
        387     1      khist = modulo(nf - 1_IK, maxchist) + 1_IK
        388     1      chist = [chist(khist + 1:maxchist), chist(1:khist)]
        389     1  end if
        390        
        391        !====================!
        392        !  Calculation ends  !
        393        !====================!
        394        
        395        ! Postconditions
        396     1  if (DEBUGGING) then
        397     1      call assert(size(xhist, 1) == n .and. size(xhist, 2) == maxxhist, 'SIZE(XHIST) == [N, MAXXHIST]', srname)
        398     1      call assert(.not. any(is_nan(xhist(:, 1:min(nf, maxxhist)))), 'XHIST does not contain NaN', srname)
        399     1      ! The last calculated X can be Inf (finite + finite can be Inf numerically).
        400     1      call assert(size(fhist) == maxfhist, 'SIZE(FHIST) == MAXFHIST', srname)
        401     1      call assert(.not. any(is_nan(fhist(1:min(nf, maxfhist))) .or. is_posinf(fhist(1:min(nf, maxfhist)))), &
        402     1          & 'FHIST does not contain NaN/+Inf', srname)
        403     2      if (present(chist)) then
        404     2          call assert(size(chist) == maxchist, 'SIZE(CHIST) == MAXCHIST', srname)
        405     2          !------------------------------------------------------------------------------------------!
        406     2          ! The following test is not applicable to LINCOA
        407     2          !!call assert(.not. any(chist(1:min(nf, maxchist)) < 0 .or. is_nan(chist(1:min(nf, maxchist))) .or. &
        408     2          !!    & is_posinf(chist(1:min(nf, maxchist)))), 'CHIST does not contain nonnegative values or NaN/+Inf', srname)
        409     2          !------------------------------------------------------------------------------------------!
        410     2      end if
        411     2      if (present(conhist)) then
        412     2          call assert(size(conhist, 1) == m .and. size(conhist, 2) == maxconhist, &
        413     2              & 'SIZE(CONHIST) == [M, MAXCONHIST]', srname)
        414     2          call assert(.not. any(is_nan(conhist(:, 1:min(nf, maxconhist))) .or. &
        415     2              & is_neginf(conhist(:, 1:min(nf, maxconhist)))), 'CONHIST does not contain NaN/-Inf', srname)
        416     2      end if
        417     1  end if
        418        
        419        end subroutine rangehist
        420        
        421        
        422        end module history_mod

 Diagnostic messages: program name(history_mod)
  Module subprogram name(prehist)
   1333-S: "../../common/history.f90", line 30, column 4: Name expected.
   1333-S: "../../common/history.f90", line 31, column 4: Name expected.
   1333-S: "../../common/history.f90", line 32, column 4: Name expected.
   1333-S: "../../common/history.f90", line 33, column 4: Name expected.
   1185-S: "../../common/history.f90", line 37: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/history.f90", line 37, column 9: Type specification or length specification invalid.
   1185-S: "../../common/history.f90", line 38: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/history.f90", line 38, column 9: Type specification or length specification invalid.
   1185-S: "../../common/history.f90", line 45: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/history.f90", line 45, column 9: Type specification or length specification invalid.
   1185-S: "../../common/history.f90", line 48: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/history.f90", line 48, column 6: Type specification or length specification invalid.
   1185-S: "../../common/history.f90", line 49: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/history.f90", line 49, column 6: Type specification or length specification invalid.
   1185-S: "../../common/history.f90", line 50: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/history.f90", line 50, column 6: Type specification or length specification invalid.
   1185-S: "../../common/history.f90", line 51: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/history.f90", line 51, column 6: Type specification or length specification invalid.
   1185-S: "../../common/history.f90", line 55: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/history.f90", line 55, column 9: Type specification or length specification invalid.
   1185-S: "../../common/history.f90", line 56: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/history.f90", line 56, column 9: Type specification or length specification invalid.
   1380-S: "../../common/history.f90", line 86, column 39: Invalid kind parameter in literal constant.
   1380-S: "../../common/history.f90", line 88, column 15: Invalid kind parameter in literal constant.
  Module subprogram name(savehist)
   1333-S: "../../common/history.f90", line 139, column 4: Name expected.
   1333-S: "../../common/history.f90", line 140, column 4: Name expected.
   1333-S: "../../common/history.f90", line 141, column 4: Name expected.
   1185-S: "../../common/history.f90", line 145: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/history.f90", line 145, column 9: Type specification or length specification invalid.
   1185-S: "../../common/history.f90", line 146: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/history.f90", line 146, column 6: Type specification or length specification invalid.
   1185-S: "../../common/history.f90", line 147: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/history.f90", line 147, column 6: Type specification or length specification invalid.
   1185-S: "../../common/history.f90", line 148: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/history.f90", line 148, column 6: Type specification or length specification invalid.
   1185-S: "../../common/history.f90", line 149: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/history.f90", line 149, column 6: Type specification or length specification invalid.
   1185-S: "../../common/history.f90", line 152: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/history.f90", line 152, column 6: Type specification or length specification invalid.
   1185-S: "../../common/history.f90", line 153: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/history.f90", line 153, column 6: Type specification or length specification invalid.
   1185-S: "../../common/history.f90", line 154: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/history.f90", line 154, column 6: Type specification or length specification invalid.
   1185-S: "../../common/history.f90", line 155: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/history.f90", line 155, column 6: Type specification or length specification invalid.
   1185-S: "../../common/history.f90", line 158: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/history.f90", line 158, column 9: Type specification or length specification invalid.
   1185-S: "../../common/history.f90", line 159: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/history.f90", line 159, column 9: Type specification or length specification invalid.
   1185-S: "../../common/history.f90", line 160: In an initialization or specification expression, 'IK' must be a named constant.

 Procedure information
   Lines      : 422
   Statements : 230

 Total information
   Procedures       : 1
   Total lines      : 422
   Total statements : 230


 Lahey/Fujitsu Fortran 95 Compiler Release L8.10b  Sat Feb 12 17:36:58 2022
 Copyright (C) 1994-2008 Lahey Computer Systems.  All rights reserved.
 Copyright (C) 1998-2008 FUJITSU LIMITED. All rights reserved.

 Compilation information
   Current directory : /home/zaikunzhang/Bureau/neupdfo/fsrc/classical/uobyqa
   Source file       : ../../common/preproc.f90
   Compiler options  : --ap --nblock -c --chk aefosux --chkglobal --nco 
                     : --nconcc --dal --ndbl --nf95 --nfast -g --in --info 
                     : --ninline --li --lst --nlong --maxfatals 50 --nml 
                     : --nmldefault --o0 --no --nocl --nopenmp --nparallel 
                     : --nprefetch --npca --nprivate --nquad --quiet --sav 
                     : --nshared --sse2 --nstaticlink --nswm --nthreadheap 
                     : --nthreads --trace --ntrap --nunroll --nvarheap 
                     : --nvarstack --nversion --warn --nwide --nwisk --wo --zfm 
                     : --xref

 Module "preproc_mod"
  (line-no.)(nest)
          1        module preproc_mod
          2        !--------------------------------------------------------------------------------------------------!
          3        ! PREPROC_MOD is a module that preprocesses the inputs.
          4        !
          5        ! Coded by Zaikun ZHANG (www.zhangzk.net) based on Powell's Fortran 77 code and papers.
          6        !
          7        ! Started: July 2020
          8        !
          9        ! Last Modified: Thursday, February 03, 2022 PM11:01:08
         10        !--------------------------------------------------------------------------------------------------!
         11        
         12        ! N.B.: If all the inputs are valid, then PREPROC should do nothing.
         13        
         14        implicit none
         15        private
         16        public :: preproc
         17        
         18        
         19        contains
         20        
         21        
         22        subroutine preproc(solver, n, iprint, maxfun, maxhist, ftarget, rhobeg, rhoend, m, npt, maxfilt, &
         23                & ctol, cweight, eta1, eta2, gamma1, gamma2, is_constrained)
         24        !--------------------------------------------------------------------------------------------------!
         25        ! This subroutine preprocesses the inputs. It does nothing to the inputs that are valid.
         26        !--------------------------------------------------------------------------------------------------!
         27        use, non_intrinsic :: consts_mod, only : RP, IK, ONE, TWO, TEN, TENTH, EPS, MAXMEMORY, MSGLEN, DEBUGGING
         28        use, non_intrinsic :: consts_mod, only : RHOBEG_DFT, RHOEND_DFT, ETA1_DFT, ETA2_DFT, GAMMA1_DFT, GAMMA2_DFT
         29        use, non_intrinsic :: consts_mod, only : CTOL_DFT, CWEIGHT_DFT, FTARGET_DFT, IPRINT_DFT, MIN_MAXFILT, MAXFILT_DFT
         30        use, non_intrinsic :: debug_mod, only : assert, warning
         31        use, non_intrinsic :: infnan_mod, only : is_nan, is_inf, is_finite
         32        use, non_intrinsic :: memory_mod, only : cstyle_sizeof
         33        use, non_intrinsic :: string_mod, only : lower, trimstr
         34        implicit none
         35        
         36        ! Compulsory inputs
         37        character(len=*), intent(in) :: solver
         38        integer(IK), intent(in) :: n
         39        
         40        ! Optional inputs
         41        integer(IK), intent(in), optional :: m
         42        
         43        ! Compulsory in-outputs
         44        integer(IK), intent(inout) :: iprint
         45        integer(IK), intent(inout) :: maxfun
         46        integer(IK), intent(inout) :: maxhist
         47        real(RP), intent(inout) :: ftarget
         48        real(RP), intent(inout) :: rhobeg
         49        real(RP), intent(inout) :: rhoend
         50        
         51        ! Optional in-outputs
         52        integer(IK), intent(inout), optional :: npt
         53        integer(IK), intent(inout), optional :: maxfilt
         54        logical, intent(in), optional :: is_constrained
         55        real(RP), intent(inout), optional :: ctol
         56        real(RP), intent(inout), optional :: cweight
         57        real(RP), intent(inout), optional :: eta1
         58        real(RP), intent(inout), optional :: eta2
         59        real(RP), intent(inout), optional :: gamma1
         60        real(RP), intent(inout), optional :: gamma2
         61        
         62        ! Local variables
         63        character(len=*), parameter :: ifmt = '(I0)'  ! Format of integers; use the minimum number of digits
         64        character(len=*), parameter :: rfmt = '(1PD15.6)'  ! Format of reals
         65        character(len=*), parameter :: srname = 'PREPROC'
         66        character(len=MSGLEN) :: min_maxfun_str
         67        character(len=MSGLEN) :: wmsg
         68        integer(IK) :: m_loc
         69        integer(IK) :: maxfilt_in
         70        integer(IK) :: min_maxfun
         71        integer(IK) :: unit_memo
         72        logical :: is_constrained_loc
         73        real(RP) :: eta1_loc
         74        real(RP) :: eta2_loc
         75        
         76        ! Preconditions
         77     1  if (DEBUGGING) then
         78     1      call assert(n >= 1, 'N >= 1', srname)
         79     2      if (present(m)) then
         80     2          call assert(m >= 0, 'M >= 0', srname)
         81     2          call assert(m == 0 .or. lower(solver) == 'cobyla', 'M == 0 unless the solver is COBYLA', srname)
         82     2      end if
         83     2      if (lower(solver) == 'cobyla' .and. present(m) .and. present(is_constrained)) then
         84     2          call assert(m == 0 .or. is_constrained, 'For COBYLA, M == 0 unless the problem is constrained', srname)
         85     2      end if
         86     1  end if
         87        
         88        !====================!
         89        ! Calculation starts !
         90        !====================!
         91        
         92        ! Read M, if necessary
         93     1  if (lower(solver) == 'cobyla' .and. present(m)) then
         94     1      m_loc = m
         95     1  else
         96     1      m_loc = 0_IK
         97     1  end if
         98        
         99        ! Decide whether the problem is truly constrained
        100     1  if (present(is_constrained)) then
        101     1      is_constrained_loc = is_constrained
        102     1  else
        103     1      is_constrained_loc = (m_loc > 0)
        104     1  end if
        105        
        106        
        107        ! Validate IPRINT
        108     1  if (abs(iprint) > 3) then
        109     1      iprint = IPRINT_DFT
        110     1      write (wmsg, ifmt) iprint
        111     1      call warning(solver, 'Invalid IPRINT; it should be 0, 1, -1, 2, -2, 3, or -3; it is set to '//trimstr(wmsg))
        112     1  end if
        113        
        114        ! Validate MAXFUN
        115     1  select case (lower(solver))
        116     1  case ('uobyqa')
        117     1      min_maxfun = (n + 1_IK) * (n + 2_IK) / 2_IK + 1_IK
        118     1      min_maxfun_str = '(N+1)(N+2)/2 + 1'
        119     1  case ('cobyla')
        120     1      min_maxfun = n + 2_IK
        121     1      min_maxfun_str = 'N + 2'
        122     1  case default  ! CASE ('NEWUOA', 'BOBYQA', 'LINCOA')
        123     1      min_maxfun = n + 3_IK
        124     1      min_maxfun_str = 'N + 3'
        125     1  end select
        126     1  if (maxfun < min_maxfun) then
        127     1      maxfun = min_maxfun
        128     1      write (wmsg, ifmt) maxfun
        129     1      call warning(solver, 'Invalid MAXFUN; it should be at least '//trimstr(min_maxfun_str)//'; it is set to '//trimstr(wmsg))
        130     1  end if
        131        
        132        ! Validate MAXHIST
        133     1  if (maxhist < 0) then
        134     1      maxhist = maxfun
        135     1      write (wmsg, ifmt) maxhist
        136     1      call warning(solver, 'Invalid MAXHIST; it should be a nonnegative integer; it is set to '//trimstr(wmsg))
        137     1  end if
        138        maxhist = min(maxhist, maxfun)  ! MAXHIST > MAXFUN is never needed.
        139        
        140        ! Validate FTARGET
        141     1  if (is_nan(ftarget)) then
        142     1      ftarget = FTARGET_DFT
        143     1      write (wmsg, rfmt) ftarget
        144     1      call warning(solver, 'Invalid FTARGET; it should be a real number; it is set to '//trimstr(wmsg))
        145     1  end if
        146        
        147        ! Validate NPT
        148     1  if ((lower(solver) == 'newuoa' .or. lower(solver) == 'bobyqa' .or. lower(solver) == 'lincoa') &
        149     1      & .and. present(npt)) then
        150     2      if (npt < n + 2 .or. npt > min(maxfun - 1, ((n + 2) * (n + 1)) / 2)) then
        151     2          npt = int(min(maxfun - 1, 2 * n + 1), kind(npt))
        152     2          write (wmsg, ifmt) npt
        153     2          call warning(solver, 'Invalid NPT; it should be an integer in the interval [N+2, (N+1)(N+2)/2], '// &
        154     2              & 'and it should be less than MAXFUN; it is set to '//trimstr(wmsg))
        155     2      end if
        156     1  end if
        157        
        158        ! Validate MAXFILT
        159     1  if (present(maxfilt) .and. (lower(solver) == 'lincoa' .or. lower(solver) == 'cobyla')) then
        160     1      maxfilt_in = maxfilt
        161     2      if (maxfilt < 1) then
        162     2          maxfilt = MAXFILT_DFT  ! The inputted MAXFILT is obviously wrong.
        163     2      else
        164     2          maxfilt = max(MIN_MAXFILT, maxfilt)  ! The inputted MAXFILT is too small.
        165     2      end if
        166     1      ! Further revise MAXFILT according to MAXMEMORY.
        167     2      select case (lower(solver))
        168     2      case ('lincoa')
        169     2          unit_memo = (n + 2_IK) * cstyle_sizeof(0.0_RP)
        170     2      case ('cobyla')
        171     2          unit_memo = (m_loc + n + 2_IK) * cstyle_sizeof(0.0_RP)
        172     2      case default
        173     2          unit_memo = 1_IK
        174     2      end select
        175     1      ! We cannot simply set MAXFILT = MIN(MAXFILT, MAXMEMORY/...), as they may not have
        176     1      ! the same kind, and compilers may complain. We may convert them, but overflow may occur.
        177     2      if (maxfilt > MAXMEMORY / unit_memo) then
        178     2          maxfilt = int(MAXMEMORY / unit_memo, kind(maxfilt))
        179     2      end if
        180     1      maxfilt = min(maxfun, max(MIN_MAXFILT, maxfilt))
        181     2      if (is_constrained_loc) then
        182     2          write (wmsg, ifmt) maxfilt
        183     3          if (maxfilt_in < 1) then
        184     3              call warning(solver, 'Invalid MAXFILT; it should be a positive integer; it is set to ' &
        185     3                  & //trimstr(wmsg))
        186     3          elseif (maxfilt_in < min(maxfun, MIN_MAXFILT)) then
        187     3              call warning(solver, 'MAXFILT is too small; it is set to '//trimstr(wmsg))
        188     3          elseif (maxfilt < min(maxfilt_in, maxfun)) then
        189     3              call warning(solver, 'MAXFILT is set to '//trimstr(wmsg)//' due to memory limit.')
        190     3          end if
        191     2      end if
        192     1  end if
        193        
        194        ! Validate ETA1 and ETA2
        195     1  if (present(eta1)) then
        196     1      eta1_loc = eta1
        197     1  else
        198     1      eta1_loc = ETA1_DFT
        199     1  end if
        200     1  if (present(eta2)) then
        201     1      eta2_loc = eta2
        202     1  else
        203     1      eta2_loc = ETA2_DFT
        204     1  end if
        205        
        206        ! When the difference between ETA1 and ETA2 is tiny, we force them to equal.
        207        ! See the explanation around RHOBEG and RHOEND for the reason.
        208     1  if (present(eta1) .and. present(eta2)) then
        209     2      if (abs(eta1 - eta2) < 1.0E2_RP * EPS * max(abs(eta1), ONE)) then
        210     2          eta2 = eta1
        211     2      end if
        212     1  end if
        213        
        214     1  if (present(eta1)) then
        215     2      if (is_nan(eta1)) then
        216     2          ! In this case, we take the value hard coded in Powell's original code
        217     2          ! without any warning. It is useful when interfacing with MATLAB/Python.
        218     2          eta1 = ETA1_DFT
        219     2      elseif (eta1 < 0 .or. eta1 >= 1) then
        220     2          ! Take ETA2 into account if it has a valid value.
        221     3          if (present(eta2) .and. eta2_loc > 0 .and. eta2_loc <= 1) then
        222     3              eta1 = max(EPS, eta2 / 7.0_RP)
        223     3          else
        224     3              eta1 = ETA1_DFT
        225     3          end if
        226     2          write (wmsg, rfmt) eta1
        227     2          call warning(solver, 'Invalid ETA1; it should be in the interval [0, 1) and not more than ETA2;'// &
        228     2              & ' it is set to '//trimstr(wmsg))
        229     2      end if
        230     1  end if
        231        
        232     1  if (present(eta2)) then
        233     2      if (is_nan(eta2)) then
        234     2          ! In this case, we take the value hard coded in Powell's original code
        235     2          ! without any warning. It is useful when interfacing with MATLAB/Python.
        236     2          eta2 = ETA2_DFT
        237     2      elseif (present(eta1) .and. (eta2 < eta1_loc .or. eta2 > 1)) then
        238     2          eta2 = (eta1 + TWO) / 3.0_RP
        239     2          write (wmsg, rfmt) eta2
        240     2          call warning(solver, 'Invalid ETA2; it should be in the interval [0, 1) and not less than ETA1;'// &
        241     2              & ' it is set to '//trimstr(wmsg))
        242     2      end if
        243     1  end if
        244        
        245        ! Validate GAMMA1 and GAMMA2
        246     1  if (present(gamma1)) then
        247     2      if (is_nan(gamma1)) then
        248     2          ! In this case, we take the value hard coded in Powell's original code
        249     2          ! without any warning. It is useful when interfacing with MATLAB/Python.
        250     2          gamma1 = GAMMA1_DFT
        251     2      elseif (gamma1 <= 0 .or. gamma1 >= 1) then
        252     2          gamma1 = GAMMA1_DFT
        253     2          write (wmsg, rfmt) gamma1
        254     2          call warning(solver, 'Invalid GAMMA1; it should in the interval (0, 1); it is set to '//trimstr(wmsg))
        255     2      end if
        256     1  end if
        257        
        258     1  if (present(gamma2)) then
        259     2      if (is_nan(gamma2)) then
        260     2          ! In this case, we take the value hard coded in Powell's original code
        261     2          ! without any warning. It is useful when interfacing with MATLAB/Python.
        262     2          gamma2 = GAMMA2_DFT
        263     2      elseif (gamma2 < 1 .or. is_inf(gamma2)) then
        264     2          gamma2 = GAMMA2_DFT
        265     2          write (wmsg, rfmt) gamma2
        266     2          call warning(solver, 'Invalid GAMMA2; it should be a real number not less than 1; it is set to '//trimstr(wmsg))
        267     2      end if
        268     1  end if
        269        
        270        ! Validate RHOBEG and RHOEND
        271     1  if (abs(rhobeg - rhoend) < 1.0E2_RP * EPS * max(abs(rhobeg), ONE)) then
        272     1      ! When the data is passed from the interfaces (e.g., MEX) to the Fortran code, RHOBEG, and RHOEND
        273     1      ! may change a bit. It was observed in a MATLAB test that MEX passed 1 to Fortran as
        274     1      ! 0.99999999999999978. Therefore, if we set RHOEND = RHOBEG in the interfaces, then it may happen
        275     1      ! that RHOEND > RHOBEG, which is considered as an invalid input. To avoid this situation, we
        276     1      ! force RHOBEG and RHOEND to equal when the difference is tiny.
        277     1      rhoend = rhobeg
        278     1  end if
        279        
        280     1  if (rhobeg <= 0 .or. is_nan(rhobeg) .or. is_inf(rhobeg)) then
        281     1      ! Take RHOEND into account if it has a valid value.
        282     2      if (is_finite(rhoend) .and. rhoend > 0) then
        283     2          rhobeg = max(TEN * rhoend, RHOBEG_DFT)
        284     2      else
        285     2          rhobeg = RHOBEG_DFT
        286     2      end if
        287     1      write (wmsg, rfmt) rhobeg
        288     1      call warning(solver, 'Invalid RHOBEG; it should be a positive number; it is set to '//trimstr(wmsg))
        289     1  end if
        290        
        291     1  if (rhoend <= 0 .or. rhobeg < rhoend .or. is_nan(rhoend) .or. is_inf(rhoend)) then
        292     1      rhoend = max(EPS, min(TENTH * rhobeg, RHOEND_DFT))
        293     1      write (wmsg, rfmt) rhoend
        294     1      call warning(solver, 'Invalid RHOEND; it should be a positive number and RHOEND <= RHOBEG; '// &
        295     1          & 'it is set to '//trimstr(wmsg))
        296     1  end if
        297        
        298        ! Validate CTOL (it can be 0)
        299     1  if (present(ctol)) then
        300     2      if (is_nan(ctol) .or. ctol < 0) then
        301     2          ctol = CTOL_DFT
        302     3          if (is_constrained_loc) then
        303     3              write (wmsg, rfmt) ctol
        304     3              call warning(solver, 'Invalid CTOL; it should be a nonnegative number; it is set to '//trimstr(wmsg))
        305     3          end if
        306     2      end if
        307     1  end if
        308        
        309        ! Validate CWEIGHT (it can be +Inf)
        310     1  if (present(cweight)) then
        311     2      if (is_nan(cweight) .or. cweight < 0) then
        312     2          cweight = CWEIGHT_DFT
        313     3          if (is_constrained_loc) then
        314     3              write (wmsg, rfmt) cweight
        315     3              call warning(solver, 'Invalid CWEIGHT; it should be a nonnegative number; it is set to '//trimstr(wmsg))
        316     3          end if
        317     2      end if
        318     1  end if
        319        
        320        !====================!
        321        !  Calculation ends  !
        322        !====================!
        323        
        324        ! Postconditions
        325     1  if (DEBUGGING) then
        326     1      call assert(abs(iprint) <= 3, 'IPRINT is 0, 1, -1, 2, -2, 3, or -3', solver)
        327     1      call assert(maxhist >= 0 .and. maxhist <= maxfun, '0 <= MAXHIST <= MAXFUN', solver)
        328     2      if (present(npt)) then
        329     2          call assert(maxfun >= npt + 1, 'MAXFUN >= NPT + 1', solver)
        330     2          call assert(npt >= 3, 'NPT >= 3', solver)
        331     2      end if
        332     2      if (present(maxfilt)) then
        333     2          call assert(maxfilt >= min(MIN_MAXFILT, maxfun) .and. maxfilt <= maxfun, &
        334     2              & 'MIN(MIN_MAXFILT, MAXFUN) <= MAXFILT <= MAXFUN', solver)
        335     2      end if
        336     2      if (present(eta1) .and. present(eta2)) then
        337     2          call assert(eta1 >= 0 .and. eta1 <= eta2 .and. eta2 < 1, '0 <= ETA1 <= ETA2 < 1', solver)
        338     2      end if
        339     2      if (present(gamma1) .and. present(gamma2)) then
        340     2          call assert(gamma1 > 0 .and. gamma1 < 1 .and. gamma2 > 1, '0 < GAMMA1 < 1 < GAMMA2', solver)
        341     2      end if
        342     1      call assert(rhobeg >= rhoend .and. rhoend > 0, 'RHOBEG >= RHOEND > 0', solver)
        343     2      if (present(ctol)) then
        344     2          call assert(ctol >= 0, 'CTOL >= 0', solver)
        345     2      end if
        346     1  end if
        347        
        348        end subroutine preproc
        349        
        350        
        351        end module preproc_mod

 Diagnostic messages: program name(preproc_mod)
  Module subprogram name(preproc)
   1333-S: "../../common/preproc.f90", line 27, column 4: Name expected.
   1333-S: "../../common/preproc.f90", line 28, column 4: Name expected.
   1333-S: "../../common/preproc.f90", line 29, column 4: Name expected.
   1333-S: "../../common/preproc.f90", line 30, column 4: Name expected.
   1333-S: "../../common/preproc.f90", line 31, column 4: Name expected.
   1333-S: "../../common/preproc.f90", line 32, column 4: Name expected.
   1333-S: "../../common/preproc.f90", line 33, column 4: Name expected.
   1185-S: "../../common/preproc.f90", line 38: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/preproc.f90", line 38, column 9: Type specification or length specification invalid.
   1185-S: "../../common/preproc.f90", line 41: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/preproc.f90", line 41, column 9: Type specification or length specification invalid.
   1185-S: "../../common/preproc.f90", line 44: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/preproc.f90", line 44, column 9: Type specification or length specification invalid.
   1185-S: "../../common/preproc.f90", line 45: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/preproc.f90", line 45, column 9: Type specification or length specification invalid.
   1185-S: "../../common/preproc.f90", line 46: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/preproc.f90", line 46, column 9: Type specification or length specification invalid.
   1185-S: "../../common/preproc.f90", line 47: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/preproc.f90", line 47, column 6: Type specification or length specification invalid.
   1185-S: "../../common/preproc.f90", line 48: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/preproc.f90", line 48, column 6: Type specification or length specification invalid.
   1185-S: "../../common/preproc.f90", line 49: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/preproc.f90", line 49, column 6: Type specification or length specification invalid.
   1185-S: "../../common/preproc.f90", line 52: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/preproc.f90", line 52, column 9: Type specification or length specification invalid.
   1185-S: "../../common/preproc.f90", line 53: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/preproc.f90", line 53, column 9: Type specification or length specification invalid.
   1185-S: "../../common/preproc.f90", line 55: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/preproc.f90", line 55, column 6: Type specification or length specification invalid.
   1185-S: "../../common/preproc.f90", line 56: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/preproc.f90", line 56, column 6: Type specification or length specification invalid.
   1185-S: "../../common/preproc.f90", line 57: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/preproc.f90", line 57, column 6: Type specification or length specification invalid.
   1185-S: "../../common/preproc.f90", line 58: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/preproc.f90", line 58, column 6: Type specification or length specification invalid.
   1185-S: "../../common/preproc.f90", line 59: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/preproc.f90", line 59, column 6: Type specification or length specification invalid.
   1185-S: "../../common/preproc.f90", line 60: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/preproc.f90", line 60, column 6: Type specification or length specification invalid.
   1185-S: "../../common/preproc.f90", line 68: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/preproc.f90", line 68, column 9: Type specification or length specification invalid.
   1185-S: "../../common/preproc.f90", line 69: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/preproc.f90", line 69, column 9: Type specification or length specification invalid.
   1185-S: "../../common/preproc.f90", line 70: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/preproc.f90", line 70, column 9: Type specification or length specification invalid.
   1185-S: "../../common/preproc.f90", line 71: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "../../common/preproc.f90", line 71, column 9: Type specification or length specification invalid.
   1185-S: "../../common/preproc.f90", line 73: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "../../common/preproc.f90", line 73, column 6: Type specification or length specification invalid.
   1185-S: "../../common/preproc.f90", line 74: In an initialization or specification expression, 'RP' must be a named constant.

 Procedure information
   Lines      : 351
   Statements : 246

 Total information
   Procedures       : 1
   Total lines      : 351
   Total statements : 246


 Lahey/Fujitsu Fortran 95 Compiler Release L8.10b  Sat Feb 12 17:36:58 2022
 Copyright (C) 1994-2008 Lahey Computer Systems.  All rights reserved.
 Copyright (C) 1998-2008 FUJITSU LIMITED. All rights reserved.

 Compilation information
   Current directory : /home/zaikunzhang/Bureau/neupdfo/fsrc/classical/uobyqa
   Source file       : lagmax.f
   Compiler options  : --ap --nblock -c --chk aefosux --chkglobal --nco 
                     : --nconcc --dal --ndbl --nf95 --nfast -g --in --info 
                     : --ninline --li --lst --nlong --maxfatals 50 --nml 
                     : --nmldefault --o0 --no --nocl --nopenmp --nparallel 
                     : --nprefetch --npca --nprivate --nquad --quiet --sav 
                     : --nshared --sse2 --nstaticlink --nswm --nthreadheap 
                     : --nthreads --trace --ntrap --nunroll --nvarheap 
                     : --nvarstack --nversion --warn --nwide --nwisk --wo --zfm 
                     : --xref

 External subroutine subprogram "LAGMAX"
  (line-no.)(nest)
          1              SUBROUTINE LAGMAX (N,G,H,RHO,D,V,VMAX)
          2        CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
          3        C      IMPLICIT REAL*8 (A-H,O-Z)
          4              IMPLICIT REAL(KIND(0.0D0)) (A-H,O-Z)
          5              IMPLICIT INTEGER (I-N)
          6        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
          7              DIMENSION G(*),H(N,*),D(*),V(*)
          8        C
          9        C     N is the number of variables of a quadratic objective function, Q say.
         10        C     G is the gradient of Q at the origin.
         11        C     H is the symmetric Hessian matrix of Q. Only the upper triangular and
         12        C       diagonal parts need be set.
         13        C     RHO is the trust region radius, and has to be positive.
         14        C     D will be set to the calculated vector of variables.
         15        C     The array V will be used for working space.
         16        C     VMAX will be set to |Q(0)-Q(D)|.
         17        C
         18        C     Calculating the D that maximizes |Q(0)-Q(D)| subject to ||D|| .LEQ. RHO
         19        C     requires of order N**3 operations, but sometimes it is adequate if
         20        C     |Q(0)-Q(D)| is within about 0.9 of its greatest possible value. This
         21        C     subroutine provides such a solution in only of order N**2 operations,
         22        C     where the claim of accuracy has been tested by numerical experiments.
         23        C
         24        C     Preliminary calculations.
         25        C
         26              HALF=0.5D0
         27              HALFRT=DSQRT(HALF)
         28              ONE=1.0D0
         29              ZERO=0.0D0
         30        C
         31        C     Pick V such that ||HV|| / ||V|| is large.
         32        C
         33              HMAX=ZERO
         34     1        DO I=1,N
         35     1            SUM=ZERO
         36     2            DO J=1,N
         37     2                H(J,I)=H(I,J)
         38     2                SUM=SUM+H(I,J)**2
         39     2            END DO
         40     2            IF (SUM > HMAX) THEN
         41     2                HMAX=SUM
         42     2                K=I
         43     2            END IF
         44     1        END DO
         45     1        DO J=1,N
         46     1            V(J)=H(K,J)
         47     1        END DO
         48        C
         49        C     Set D to a vector in the subspace spanned by V and HV that maximizes
         50        C     |(D,HD)|/(D,D), except that we set D=HV if V and HV are nearly parallel.
         51        C     The vector that has the name D at label 60 used to be the vector W.
         52        C
         53              VSQ=ZERO
         54              VHV=ZERO
         55              DSQ=ZERO
         56     1        DO I=1,N
         57     1            VSQ=VSQ+V(I)**2
         58     1            D(I)=ZERO
         59     2            DO J=1,N
         60     2                D(I)=D(I)+H(I,J)*V(J)
         61     2            END DO
         62     1            VHV=VHV+V(I)*D(I)
         63     1            DSQ=DSQ+D(I)**2
         64     1        END DO
         65     1        IF (VHV*VHV <= 0.9999D0*DSQ*VSQ) THEN
         66     1            TEMP=VHV/VSQ
         67     1            WSQ=ZERO
         68     2            DO I=1,N
         69     2                D(I)=D(I)-TEMP*V(I)
         70     2                WSQ=WSQ+D(I)**2
         71     2            END DO
         72     1            WHW=ZERO
         73     1            RATIO=DSQRT(WSQ/VSQ)
         74     2            DO I=1,N
         75     2                TEMP=ZERO
         76     3                DO J=1,N
         77     3                    TEMP=TEMP+H(I,J)*D(J)
         78     3                END DO
         79     2                WHW=WHW+TEMP*D(I)
         80     2                V(I)=RATIO*V(I)
         81     2            END DO
         82     1            VHV=RATIO*RATIO*VHV
         83     1            VHW=RATIO*WSQ
         84     1            TEMP=HALF*(WHW-VHV)
         85     1            TEMP=TEMP+DSIGN(DSQRT(TEMP**2+VHW**2),WHW+VHV)
         86     2            DO I=1,N
         87     2                D(I)=VHW*V(I)+TEMP*D(I)
         88     2            END DO
         89     1        END IF
         90        C
         91        C     We now turn our attention to the subspace spanned by G and D. A multiple
         92        C     of the current D is returned if that choice seems to be adequate.
         93        C
         94              GG=ZERO
         95              GD=ZERO
         96              DD=ZERO
         97              DHD=ZERO
         98     1        DO I=1,N
         99     1            GG=GG+G(I)**2
        100     1            GD=GD+G(I)*D(I)
        101     1            DD=DD+D(I)**2
        102     1            SUM=ZERO
        103     2            DO J=1,N
        104     2                SUM=SUM+H(I,J)*D(J)
        105     2            END DO
        106     1            DHD=DHD+SUM*D(I)
        107     1        END DO
        108              TEMP=GD/GG
        109              VV=ZERO
        110              SCALE=DSIGN(RHO/DSQRT(DD),GD*DHD)
        111     1        DO I=1,N
        112     1            V(I)=D(I)-TEMP*G(I)
        113     1            VV=VV+V(I)**2
        114     1            D(I)=SCALE*D(I)
        115     1        END DO
        116              GNORM=DSQRT(GG)
        117     1        IF (GNORM*DD <= 0.5D-2*RHO*DABS(DHD) .OR.
        118     1       1  VV/DD <= 1.0D-4) THEN
        119     1            VMAX=DABS(SCALE*(GD+HALF*SCALE*DHD))
        120     1            GOTO 170
        121     1        END IF
        122        C
        123        C     G and V are now orthogonal in the subspace spanned by G and D. Hence
        124        C     we generate an orthonormal basis of this subspace such that (D,HV) is
        125        C     negligible or zero, where D and V will be the basis vectors.
        126        C
        127              GHG=ZERO
        128              VHG=ZERO
        129              VHV=ZERO
        130     1        DO I=1,N
        131     1            SUM=ZERO
        132     1            SUMV=ZERO
        133     2            DO J=1,N
        134     2                SUM=SUM+H(I,J)*G(J)
        135     2                SUMV=SUMV+H(I,J)*V(J)
        136     2            END DO
        137     1            GHG=GHG+SUM*G(I)
        138     1            VHG=VHG+SUMV*G(I)
        139     1            VHV=VHV+SUMV*V(I)
        140     1        END DO
        141              VNORM=DSQRT(VV)
        142              GHG=GHG/GG
        143              VHG=VHG/(VNORM*GNORM)
        144              VHV=VHV/VV
        145     1        IF (DABS(VHG) <= 0.01D0*DMAX1(DABS(GHG),DABS(VHV))) THEN
        146     1            VMU=GHG-VHV
        147     1            WCOS=ONE
        148     1            WSIN=ZERO
        149     1        ELSE
        150     1            TEMP=HALF*(GHG-VHV)
        151     1            VMU=TEMP+DSIGN(DSQRT(TEMP**2+VHG**2),TEMP)
        152     1            TEMP=DSQRT(VMU**2+VHG**2)
        153     1            WCOS=VMU/TEMP
        154     1            WSIN=VHG/TEMP
        155     1        END IF
        156              TEMPA=WCOS/GNORM
        157              TEMPB=WSIN/VNORM
        158              TEMPC=WCOS/VNORM
        159              TEMPD=WSIN/GNORM
        160     1        DO I=1,N
        161     1            D(I)=TEMPA*G(I)+TEMPB*V(I)
        162     1            V(I)=TEMPC*V(I)-TEMPD*G(I)
        163     1        END DO
        164        C
        165        C     The final D is a multiple of the current D, V, D+V or D-V. We make the
        166        C     choice from these possibilities that is optimal.
        167        C
        168              DLIN=WCOS*GNORM/RHO
        169              VLIN=-WSIN*GNORM/RHO
        170              TEMPA=DABS(DLIN)+HALF*DABS(VMU+VHV)
        171              TEMPB=DABS(VLIN)+HALF*DABS(GHG-VMU)
        172              TEMPC=HALFRT*(DABS(DLIN)+DABS(VLIN))+0.25D0*DABS(GHG+VHV)
        173     1        IF (TEMPA >= TEMPB .AND. TEMPA >= TEMPC) THEN
        174     1            TEMPD=DSIGN(RHO,DLIN*(VMU+VHV))
        175     1            TEMPV=ZERO
        176     1        ELSE IF (TEMPB >= TEMPC) THEN
        177     1            TEMPD=ZERO
        178     1            TEMPV=DSIGN(RHO,VLIN*(GHG-VMU))
        179     1        ELSE
        180     1            TEMPD=DSIGN(HALFRT*RHO,DLIN*(GHG+VHV))
        181     1            TEMPV=DSIGN(HALFRT*RHO,VLIN*(GHG+VHV))
        182     1        END IF
        183     1        DO I=1,N
        184     1            D(I)=TEMPD*D(I)+TEMPV*V(I)
        185     1        END DO
        186              VMAX=RHO*RHO*DMAX1(TEMPA,TEMPB,TEMPC)
        187          170 RETURN
        188              END

 Diagnostic messages: program name(LAGMAX)
   3909-W: "lagmax.f", line 2: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 3: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 8: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 9: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 10: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 11: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 12: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 13: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 14: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 15: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 16: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 17: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 18: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 19: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 20: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 21: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 22: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 23: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 24: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 25: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 30: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 31: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 32: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 48: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 49: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 50: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 51: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 52: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 90: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 91: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 92: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 93: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 118: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 122: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 123: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 124: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 125: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 126: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 164: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 165: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 166: Fixed form source is an obsolescent feature.
   3909-W: "lagmax.f", line 167: Fixed form source is an obsolescent feature.

 Procedure information
   Lines      : 188
   Statements : 145

 Scoping unit of external sub-program : LAGMAX
   Attribute and Cross reference of name
     D
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : DIMENSION, dummy-argument
      |(Declaration)    : 1  7
      |(Definition)     : 58  60  69  87  114  161  184
      |(Reference)      : 60  62  63  69  70  77  79  87  100  101  104  106  112  114  184
     DABS
      |(Class and Type) : intrinsic function name, REAL(8)
      |(Attributes)     : PURE, ELEMENTAL
      |(Declaration)    : 
      |(Definition)     : 
      |(Reference)      : 117  119  145  145  145  170  170  171  171  172  172  172
     DD
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 96  101
      |(Reference)      : 101  110  117  117
     DHD
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 97  106
      |(Reference)      : 106  110  117  119
     DLIN
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 168
      |(Reference)      : 170  172  174  180
     DMAX1
      |(Class and Type) : intrinsic function name, REAL(8)
      |(Attributes)     : PURE, ELEMENTAL
      |(Declaration)    : 
      |(Definition)     : 
      |(Reference)      : 145  186
     DSIGN
      |(Class and Type) : intrinsic function name, REAL(8)
      |(Attributes)     : PURE, ELEMENTAL
      |(Declaration)    : 
      |(Definition)     : 
      |(Reference)      : 85  110  151  174  178  180  181
     DSQ
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 55  63
      |(Reference)      : 63  65
     DSQRT
      |(Class and Type) : intrinsic function name, REAL(8)
      |(Attributes)     : PURE, ELEMENTAL
      |(Declaration)    : 
      |(Definition)     : 
      |(Reference)      : 27  73  85  110  116  141  151  152
     G
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : DIMENSION, dummy-argument
      |(Declaration)    : 1  7
      |(Definition)     : 
      |(Reference)      : 99  100  112  134  137  138  161  162
     GD
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 95  100
      |(Reference)      : 100  108  110  119
     GG
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 94  99
      |(Reference)      : 99  108  116  142
     GHG
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 127  137  142
      |(Reference)      : 137  142  145  146  150  171  172  178  180  181
     GNORM
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 116
      |(Reference)      : 117  143  156  159  168  169
     H
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : DIMENSION, dummy-argument
      |(Declaration)    : 1  7
      |(Definition)     : 37
      |(Reference)      : 37  38  46  60  77  104  134  135
     HALF
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 26
      |(Reference)      : 27  84  119  150  170  171
     HALFRT
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 27
      |(Reference)      : 172  180  181
     HMAX
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 33  41
      |(Reference)      : 40
     I
      |(Class and Type) : variable name, INTEGER(4)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 34  56  68  74  86  98  111  130  160  183
      |(Reference)      : 37  37  38  42  57  58  60  60  60  62  62  63  69  69  69  70  77  79  80  80  87  87  87  99  100  100  101  104  106  112  112  112  113  114  114  134  135  137  138  139  161  161  161  162  162  162  184  184  184
     J
      |(Class and Type) : variable name, INTEGER(4)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 36  45  59  76  103  133
      |(Reference)      : 37  37  38  46  46  60  60  77  77  104  104  134  134  135  135
     K
      |(Class and Type) : variable name, INTEGER(4)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 42
      |(Reference)      : 46
     KIND
      |(Class and Type) : intrinsic function name, none
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 
      |(Reference)      : 4
     LAGMAX
      |(Class and Type) : external subroutine name
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 1
      |(Reference)      : 
     N
      |(Class and Type) : variable name, INTEGER(4)-implicited
      |(Attributes)     : dummy-argument
      |(Declaration)    : 1
      |(Definition)     : 
      |(Reference)      : 7  34  36  45  56  59  68  74  76  86  98  103  111  130  133  160  183
     ONE
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 28
      |(Reference)      : 147
     RATIO
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 73
      |(Reference)      : 80  82  82  83
     RHO
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : dummy-argument
      |(Declaration)    : 1
      |(Definition)     : 
      |(Reference)      : 110  117  168  169  174  178  180  181  186  186
     SCALE
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 110
      |(Reference)      : 114  119  119
     SUM
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 35  38  102  104  131  134
      |(Reference)      : 38  40  41  104  106  134  137
     SUMV
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 132  135
      |(Reference)      : 135  138  139
     TEMP
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 66  75  77  84  85  108  150  152
      |(Reference)      : 69  77  79  85  85  87  112  151  151  151  153  154
     TEMPA
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 156  170
      |(Reference)      : 161  173  173  186
     TEMPB
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 157  171
      |(Reference)      : 161  173  176  186
     TEMPC
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 158  172
      |(Reference)      : 162  173  176  186
     TEMPD
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 159  174  177  180
      |(Reference)      : 162  184
     TEMPV
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 175  178  181
      |(Reference)      : 184
     V
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : DIMENSION, dummy-argument
      |(Declaration)    : 1  7
      |(Definition)     : 46  80  112  162
      |(Reference)      : 57  60  62  69  80  87  113  135  139  161  162  184
     VHG
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 128  138  143
      |(Reference)      : 138  143  145  151  152  154
     VHV
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 54  62  82  129  139  144
      |(Reference)      : 62  65  65  66  82  84  85  139  144  145  146  150  170  172  174  180  181
     VHW
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 83
      |(Reference)      : 85  87
     VLIN
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 169
      |(Reference)      : 171  172  178  181
     VMAX
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : dummy-argument
      |(Declaration)    : 1
      |(Definition)     : 119  186
      |(Reference)      : 
     VMU
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 146  151
      |(Reference)      : 152  153  170  171  174  178
     VNORM
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 141
      |(Reference)      : 143  157  158
     VSQ
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 53  57
      |(Reference)      : 57  65  66  73
     VV
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 109  113
      |(Reference)      : 113  117  141  144
     WCOS
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 147  153
      |(Reference)      : 156  158  168
     WHW
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 72  79
      |(Reference)      : 79  84  85
     WSIN
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 148  154
      |(Reference)      : 157  159  169
     WSQ
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 67  70
      |(Reference)      : 70  73  83
     ZERO
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 29
      |(Reference)      : 33  35  53  54  55  58  67  72  75  94  95  96  97  102  109  127  128  129  131  132  148  175  177
   Cross reference of label
     (Label) (label-kind)               (line-no.)
     ------- ------------- ------------ ----------
        170  execution     (Definition) 187  
                           (Reference)  120

 Total information
   Procedures       : 1
   Total lines      : 188
   Total statements : 145


 Lahey/Fujitsu Fortran 95 Compiler Release L8.10b  Sat Feb 12 17:36:58 2022
 Copyright (C) 1994-2008 Lahey Computer Systems.  All rights reserved.
 Copyright (C) 1998-2008 FUJITSU LIMITED. All rights reserved.

 Compilation information
   Current directory : /home/zaikunzhang/Bureau/neupdfo/fsrc/classical/uobyqa
   Source file       : trstep.f
   Compiler options  : --ap --nblock -c --chk aefosux --chkglobal --nco 
                     : --nconcc --dal --ndbl --nf95 --nfast -g --in --info 
                     : --ninline --li --lst --nlong --maxfatals 50 --nml 
                     : --nmldefault --o0 --no --nocl --nopenmp --nparallel 
                     : --nprefetch --npca --nprivate --nquad --quiet --sav 
                     : --nshared --sse2 --nstaticlink --nswm --nthreadheap 
                     : --nthreads --trace --ntrap --nunroll --nvarheap 
                     : --nvarstack --nversion --warn --nwide --nwisk --wo --zfm 
                     : --xref

 External subroutine subprogram "TRSTEP"
  (line-no.)(nest)
          1              SUBROUTINE TRSTEP (N,G,H,DELTA,TOL,D,GG,TD,TN,W,PIV,Z,EVALUE)
          2        CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
          3        C      IMPLICIT REAL*8 (A-H,O-Z)
          4              IMPLICIT REAL(KIND(0.0D0)) (A-H,O-Z)
          5              IMPLICIT INTEGER (I-N)
          6        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
          7              DIMENSION G(*),H(N,*),D(*),GG(*),TD(*),TN(*),W(*),PIV(*),Z(*)
          8        C
          9        C     N is the number of variables of a quadratic objective function, Q say.
         10        C     G is the gradient of Q at the origin.
         11        C     H is the Hessian matrix of Q. Only the upper triangular and diagonal
         12        C       parts need be set. The lower triangular part is used to store the
         13        C       elements of a Householder similarity transformation.
         14        C     DELTA is the trust region radius, and has to be positive.
         15        C     TOL is the value of a tolerance from the open interval (0,1).
         16        C     D will be set to the calculated vector of variables.
         17        C     The arrays GG, TD, TN, W, PIV and Z will be used for working space.
         18        C     EVALUE will be set to the least eigenvalue of H if and only if D is a
         19        C     Newton-Raphson step. Then EVALUE will be positive, but otherwise it
         20        C     will be set to zero.
         21        C
         22        C     Let MAXRED be the maximum of Q(0)-Q(D) subject to ||D|| .LEQ. DELTA,
         23        C     and let ACTRED be the value of Q(0)-Q(D) that is actually calculated.
         24        C     We take the view that any D is acceptable if it has the properties
         25        C
         26        C             ||D|| .LEQ. DELTA  and  ACTRED .LEQ. (1-TOL)*MAXRED.
         27        C
         28        C     The calculation of D is done by the method of Section 2 of the paper
         29        C     by MJDP in the 1997 Dundee Numerical Analysis Conference Proceedings,
         30        C     after transforming H to tridiagonal form.
         31        C
         32        C     Initialization.
         33        C
         34              ONE=1.0D0
         35              TWO=2.0D0
         36              ZERO=0.0D0
         37              DELSQ=DELTA*DELTA
         38              EVALUE=ZERO
         39              NM=N-1
         40     1        DO I=1,N
         41     1            D(I)=ZERO
         42     1            TD(I)=H(I,I)
         43     2            DO J=1,I
         44     2                H(I,J)=H(J,I)
         45     2            END DO
         46     1        END DO
         47        C
         48        C     Apply Householder transformations to obtain a tridiagonal matrix that
         49        C     is similar to H, and put the elements of the Householder vectors in
         50        C     the lower triangular part of H. Further, TD and TN will contain the
         51        C     diagonal and other nonzero elements of the tridiagonal matrix.
         52        C
         53     1        DO K=1,NM
         54     1            KP=K+1
         55     1            SUM=ZERO
         56     2            IF (KP < N) THEN
         57     2                KPP=KP+1
         58     3                DO I=KPP,N
         59     3                    SUM=SUM+H(I,K)**2
         60     3                END DO
         61     2            END IF
         62     2            IF (SUM == ZERO) THEN
         63     2                TN(K)=H(KP,K)
         64     2                H(KP,K)=ZERO
         65     2            ELSE
         66     2                TEMP=H(KP,K)
         67     2                TN(K)=DSIGN(DSQRT(SUM+TEMP*TEMP),TEMP)
         68     2                H(KP,K)=-SUM/(TEMP+TN(K))
         69     2                TEMP=DSQRT(TWO/(SUM+H(KP,K)**2))
         70     3                DO I=KP,N
         71     3                    W(I)=TEMP*H(I,K)
         72     3                    H(I,K)=W(I)
         73     3                    Z(I)=TD(I)*W(I)
         74     3                END DO
         75     2                WZ=ZERO
         76     3                DO J=KP,NM
         77     3                    JP=J+1
         78     4                    DO I=JP,N
         79     4                        Z(I)=Z(I)+H(I,J)*W(J)
         80     4                        Z(J)=Z(J)+H(I,J)*W(I)
         81     4                    END DO
         82     3                    WZ=WZ+W(J)*Z(J)
         83     3                END DO
         84     2                WZ=WZ+W(N)*Z(N)
         85     3                DO J=KP,N
         86     3                    TD(J)=TD(J)+W(J)*(WZ*W(J)-TWO*Z(J))
         87     4                    IF (J < N) THEN
         88     4                        JP=J+1
         89     5                        DO I=JP,N
         90     5                            H(I,J)=H(I,J)-W(I)*Z(J)-W(J)*(Z(I)-WZ*W(I))
         91     5                        END DO
         92     4                    END IF
         93     3                END DO
         94     2            END IF
         95     1        END DO
         96        C
         97        C     Form GG by applying the similarity transformation to G.
         98        C
         99              GSQ=ZERO
        100     1        DO I=1,N
        101     1            GG(I)=G(I)
        102     1            GSQ=GSQ+G(I)**2
        103     1        END DO
        104              GNORM=DSQRT(GSQ)
        105     1        DO K=1,NM
        106     1            KP=K+1
        107     1            SUM=ZERO
        108     2            DO I=KP,N
        109     2                SUM=SUM+GG(I)*H(I,K)
        110     2            END DO
        111     2            DO I=KP,N
        112     2                GG(I)=GG(I)-SUM*H(I,K)
        113     2            END DO
        114     1        END DO
        115        C
        116        C     Begin the trust region calculation with a tridiagonal matrix by
        117        C     calculating the norm of H. Then treat the case when H is zero.
        118        C
        119              HNORM=DABS(TD(1))+DABS(TN(1))
        120              TDMIN=TD(1)
        121              TN(N)=ZERO
        122     1        DO I=2,N
        123     1            TEMP=DABS(TN(I-1))+DABS(TD(I))+DABS(TN(I))
        124     1            HNORM=DMAX1(HNORM,TEMP)
        125     1            TDMIN=DMIN1(TDMIN,TD(I))
        126     1        END DO
        127     1        IF (HNORM == ZERO) THEN
        128     1            IF (GNORM == ZERO) GOTO 400
        129     1            SCALE=DELTA/GNORM
        130     2            DO I=1,N
        131     2                D(I)=-SCALE*GG(I)
        132     2            END DO
        133     1            GOTO 370
        134     1        END IF
        135        C
        136        C     Set the initial values of PAR and its bounds.
        137        C
        138              PARL=DMAX1(ZERO,-TDMIN,GNORM/DELTA-HNORM)
        139              PARLEST=PARL
        140              PAR=PARL
        141              PARU=ZERO
        142              PARUEST=ZERO
        143              POSDEF=ZERO
        144              ITERC=0
        145        C
        146        C     Calculate the pivots of the Cholesky factorization of (H+PAR*I).
        147        C
        148          140 ITERC=ITERC+1
        149              KSAV=0
        150              PIV(1)=TD(1)+PAR
        151              K=1
        152     1    150 IF (PIV(K) > ZERO) THEN
        153     1            PIV(K+1)=TD(K+1)+PAR-TN(K)**2/PIV(K)
        154     1        ELSE
        155     1            IF (PIV(K) < ZERO .OR. TN(K) /= ZERO) GOTO 160
        156     1            KSAV=K
        157     1            PIV(K+1)=TD(K+1)+PAR
        158     1        END IF
        159              K=K+1
        160              IF (K < N) GOTO 150
        161              IF (PIV(K) < ZERO) GOTO 160
        162              IF (PIV(K) == ZERO) KSAV=K
        163        C
        164        C     Branch if all the pivots are positive, allowing for the case when
        165        C     G is zero.
        166        C
        167              IF (KSAV == 0 .AND. GSQ > ZERO) GOTO 230
        168     1        IF (GSQ == ZERO) THEN
        169     1            IF (PAR == ZERO) GOTO 370
        170     1            PARU=PAR
        171     1            PARUEST=PAR
        172     1            IF (KSAV == 0) GOTO 190
        173     1        END IF
        174              K=KSAV
        175        C
        176        C     Set D to a direction of nonpositive curvature of the given tridiagonal
        177        C     matrix, and thus revise PARLEST.
        178        C
        179          160 D(K)=ONE
        180     1        IF (DABS(TN(K)) <= DABS(PIV(K))) THEN
        181     1            DSQ=ONE
        182     1            DHD=PIV(K)
        183     1        ELSE
        184     1            TEMP=TD(K+1)+PAR
        185     2            IF (TEMP <= DABS(PIV(K))) THEN
        186     2                D(K+1)=DSIGN(ONE,-TN(K))
        187     2                DHD=PIV(K)+TEMP-TWO*DABS(TN(K))
        188     2            ELSE
        189     2                D(K+1)=-TN(K)/TEMP
        190     2                DHD=PIV(K)+TN(K)*D(K+1)
        191     2            END IF
        192     1            DSQ=ONE+D(K+1)**2
        193     1        END IF
        194     1    170 IF (K > 1) THEN
        195     1            K=K-1
        196     2            IF (TN(K) /= ZERO) THEN
        197     2                D(K)=-TN(K)*D(K+1)/PIV(K)
        198     2                DSQ=DSQ+D(K)**2
        199     2                GOTO 170
        200     2            END IF
        201     2            DO I=1,K
        202     2                D(I)=ZERO
        203     2            END DO
        204     1        END IF
        205              PARL=PAR
        206              PARLEST=PAR-DHD/DSQ
        207        C
        208        C     Terminate with D set to a multiple of the current D if the following
        209        C     test suggests that it suitable to do so.
        210        C
        211          190 TEMP=PARUEST
        212              IF (GSQ == ZERO) TEMP=TEMP*(ONE-TOL)
        213     1        IF (PARUEST > ZERO .AND. PARLEST >= TEMP) THEN
        214     1            DTG=ZERO
        215     2            DO I=1,N
        216     2                DTG=DTG+D(I)*GG(I)
        217     2            END DO
        218     1            SCALE=-DSIGN(DELTA/DSQRT(DSQ),DTG)
        219     2            DO I=1,N
        220     2                D(I)=SCALE*D(I)
        221     2            END DO
        222     1            GOTO 370
        223     1        END IF
        224        C
        225        C     Pick the value of PAR for the next iteration.
        226        C
        227     1    220 IF (PARU == ZERO) THEN
        228     1            PAR=TWO*PARLEST+GNORM/DELTA
        229     1        ELSE
        230     1            PAR=0.5D0*(PARL+PARU)
        231     1            PAR=DMAX1(PAR,PARLEST)
        232     1        END IF
        233              IF (PARUEST > ZERO) PAR=DMIN1(PAR,PARUEST)
        234              GOTO 140
        235        C
        236        C     Calculate D for the current PAR in the positive definite case.
        237        C
        238          230 W(1)=-GG(1)/PIV(1)
        239     1        DO I=2,N
        240     1            W(I)=(-GG(I)-TN(I-1)*W(I-1))/PIV(I)
        241     1        END DO
        242              D(N)=W(N)
        243     1        DO I=NM,1,-1
        244     1            D(I)=W(I)-TN(I)*D(I+1)/PIV(I)
        245     1        END DO
        246        C
        247        C     Branch if a Newton-Raphson step is acceptable.
        248        C
        249              DSQ=ZERO
        250              WSQ=ZERO
        251     1        DO I=1,N
        252     1            DSQ=DSQ+D(I)**2
        253     1            WSQ=WSQ+PIV(I)*W(I)**2
        254     1        END DO
        255              IF (PAR == ZERO .AND. DSQ <= DELSQ) GOTO 320
        256        C
        257        C     Make the usual test for acceptability of a full trust region step.
        258        C
        259              DNORM=DSQRT(DSQ)
        260              PHI=ONE/DNORM-ONE/DELTA
        261              TEMP=TOL*(ONE+PAR*DSQ/WSQ)-DSQ*PHI*PHI
        262     1        IF (TEMP >= ZERO) THEN
        263     1            SCALE=DELTA/DNORM
        264     2            DO I=1,N
        265     2                D(I)=SCALE*D(I)
        266     2            END DO
        267     1            GOTO 370
        268     1        END IF
        269              IF (ITERC >= 2 .AND. PAR <= PARL) GOTO 370
        270              IF (PARU > ZERO .AND. PAR >= PARU) GOTO 370
        271        C
        272        C     Complete the iteration when PHI is negative.
        273        C
        274     1        IF (PHI < ZERO) THEN
        275     1            PARLEST=PAR
        276     2            IF (POSDEF. EQ. ONE) THEN
        277     2                IF (PHI <= PHIL) GOTO 370
        278     2                SLOPE=(PHI-PHIL)/(PAR-PARL)
        279     2                PARLEST=PAR-PHI/SLOPE
        280     2            END IF
        281     1            SLOPE=ONE/GNORM
        282     1            IF (PARU > ZERO) SLOPE=(PHIU-PHI)/(PARU-PAR)
        283     1            TEMP=PAR-PHI/SLOPE
        284     1            IF (PARUEST > ZERO) TEMP=DMIN1(TEMP,PARUEST)
        285     1            PARUEST=TEMP
        286     1            POSDEF=ONE
        287     1            PARL=PAR
        288     1            PHIL=PHI
        289     1            GOTO 220
        290     1        END IF
        291        C
        292        C     If required, calculate Z for the alternative test for convergence.
        293        C
        294     1        IF (POSDEF == ZERO) THEN
        295     1            W(1)=ONE/PIV(1)
        296     2            DO I=2,N
        297     2                TEMP=-TN(I-1)*W(I-1)
        298     2                W(I)=(DSIGN(ONE,TEMP)+TEMP)/PIV(I)
        299     2            END DO
        300     1            Z(N)=W(N)
        301     2            DO I=NM,1,-1
        302     2                Z(I)=W(I)-TN(I)*Z(I+1)/PIV(I)
        303     2            END DO
        304     1            WWSQ=ZERO
        305     1            ZSQ=ZERO
        306     1            DTZ=ZERO
        307     2            DO I=1,N
        308     2                WWSQ=WWSQ+PIV(I)*W(I)**2
        309     2                ZSQ=ZSQ+Z(I)**2
        310     2                DTZ=DTZ+D(I)*Z(I)
        311     2            END DO
        312     1  C
        313     1  C     Apply the alternative test for convergence.
        314     1  C
        315     1            TEMPA=DABS(DELSQ-DSQ)
        316     1            TEMPB=DSQRT(DTZ*DTZ+TEMPA*ZSQ)
        317     1            GAM=TEMPA/(DSIGN(TEMPB,DTZ)+DTZ)
        318     1            TEMP=TOL*(WSQ+PAR*DELSQ)-GAM*GAM*WWSQ
        319     2            IF (TEMP >= ZERO) THEN
        320     3                DO I=1,N
        321     3                    D(I)=D(I)+GAM*Z(I)
        322     3                END DO
        323     2                GOTO 370
        324     2            END IF
        325     1            PARLEST=DMAX1(PARLEST,PAR-WWSQ/ZSQ)
        326     1        END IF
        327        C
        328        C     Complete the iteration when PHI is positive.
        329        C
        330              SLOPE=ONE/GNORM
        331     1        IF (PARU > ZERO) THEN
        332     1            IF (PHI >= PHIU) GOTO 370
        333     1            SLOPE=(PHIU-PHI)/(PARU-PAR)
        334     1        END IF
        335              PARLEST=DMAX1(PARLEST,PAR-PHI/SLOPE)
        336              PARUEST=PAR
        337     1        IF (POSDEF == ONE) THEN
        338     1            SLOPE=(PHI-PHIL)/(PAR-PARL)
        339     1            PARUEST=PAR-PHI/SLOPE
        340     1        END IF
        341              PARU=PAR
        342              PHIU=PHI
        343              GOTO 220
        344        C
        345        C     Set EVALUE to the least eigenvalue of the second derivative matrix if
        346        C     D is a Newton-Raphson step. SHFMAX will be an upper bound on EVALUE.
        347        C
        348          320 SHFMIN=ZERO
        349              PIVOT=TD(1)
        350              SHFMAX=PIVOT
        351     1        DO K=2,N
        352     1            PIVOT=TD(K)-TN(K-1)**2/PIVOT
        353     1            SHFMAX=DMIN1(SHFMAX,PIVOT)
        354     1        END DO
        355        C
        356        C     Find EVALUE by a bisection method, but occasionally SHFMAX may be
        357        C     adjusted by the rule of false position.
        358        C
        359              KSAVE=0
        360          340 SHIFT=0.5D0*(SHFMIN+SHFMAX)
        361              K=1
        362              TEMP=TD(1)-SHIFT
        363     1    350 IF (TEMP > ZERO) THEN
        364     1            PIV(K)=TEMP
        365     2            IF (K < N) THEN
        366     2                TEMP=TD(K+1)-SHIFT-TN(K)**2/TEMP
        367     2                K=K+1
        368     2                GOTO 350
        369     2            END IF
        370     1            SHFMIN=SHIFT
        371     1        ELSE
        372     1            IF (K < KSAVE) GOTO 360
        373     2            IF (K == KSAVE) THEN
        374     2                IF (PIVKSV == ZERO) GOTO 360
        375     3                IF (PIV(K)-TEMP < TEMP-PIVKSV) THEN
        376     3                    PIVKSV=TEMP
        377     3                    SHFMAX=SHIFT
        378     3                ELSE
        379     3                    PIVKSV=ZERO
        380     3                    SHFMAX=(SHIFT*PIV(K)-SHFMIN*TEMP)/(PIV(K)-TEMP)
        381     3                END IF
        382     2            ELSE
        383     2                KSAVE=K
        384     2                PIVKSV=TEMP
        385     2                SHFMAX=SHIFT
        386     2            END IF
        387     1        END IF
        388              IF (SHFMIN <= 0.99D0*SHFMAX) GOTO 340
        389          360 EVALUE=SHFMIN
        390        C
        391        C     Apply the inverse Householder transformations to D.
        392        C
        393          370 NM=N-1
        394     1        DO K=NM,1,-1
        395     1            KP=K+1
        396     1            SUM=ZERO
        397     2            DO I=KP,N
        398     2                SUM=SUM+D(I)*H(I,K)
        399     2            END DO
        400     2            DO I=KP,N
        401     2                D(I)=D(I)-SUM*H(I,K)
        402     2            END DO
        403     1        END DO
        404        C
        405        C     Return from the subroutine.
        406        C
        407          400 RETURN
        408              END

 Diagnostic messages: program name(TRSTEP)
   3909-W: "trstep.f", line 2: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 3: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 8: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 9: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 10: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 11: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 12: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 13: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 14: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 15: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 16: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 17: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 18: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 19: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 20: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 21: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 22: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 23: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 24: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 25: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 26: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 27: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 28: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 29: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 30: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 31: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 32: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 33: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 47: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 48: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 49: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 50: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 51: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 52: Fixed form source is an obsolescent feature.
   2315-I: "trstep.f", line 62, column 19: Value of real or complex expression being compared by relational operator "==", "/=", ".EQ." or ".NE.".
   3909-W: "trstep.f", line 96: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 97: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 98: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 115: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 116: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 117: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 118: Fixed form source is an obsolescent feature.
   2315-I: "trstep.f", line 127, column 17: Value of real or complex expression being compared by relational operator "==", "/=", ".EQ." or ".NE.".
   2315-I: "trstep.f", line 128, column 21: Value of real or complex expression being compared by relational operator "==", "/=", ".EQ." or ".NE.".
   3909-W: "trstep.f", line 135: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 136: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 137: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 145: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 146: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 147: Fixed form source is an obsolescent feature.
   2315-I: "trstep.f", line 155, column 40: Value of real or complex expression being compared by relational operator "==", "/=", ".EQ." or ".NE.".
   2315-I: "trstep.f", line 162, column 18: Value of real or complex expression being compared by relational operator "==", "/=", ".EQ." or ".NE.".
   3909-W: "trstep.f", line 163: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 164: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 165: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 166: Fixed form source is an obsolescent feature.
   2315-I: "trstep.f", line 168, column 15: Value of real or complex expression being compared by relational operator "==", "/=", ".EQ." or ".NE.".
   2315-I: "trstep.f", line 169, column 19: Value of real or complex expression being compared by relational operator "==", "/=", ".EQ." or ".NE.".
   3909-W: "trstep.f", line 175: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 176: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 177: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 178: Fixed form source is an obsolescent feature.
   2315-I: "trstep.f", line 196, column 21: Value of real or complex expression being compared by relational operator "==", "/=", ".EQ." or ".NE.".
   3909-W: "trstep.f", line 207: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 208: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 209: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 210: Fixed form source is an obsolescent feature.
   2315-I: "trstep.f", line 212, column 15: Value of real or complex expression being compared by relational operator "==", "/=", ".EQ." or ".NE.".
   3909-W: "trstep.f", line 224: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 225: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 226: Fixed form source is an obsolescent feature.
   2315-I: "trstep.f", line 227, column 16: Value of real or complex expression being compared by relational operator "==", "/=", ".EQ." or ".NE.".
   3909-W: "trstep.f", line 235: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 236: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 237: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 246: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 247: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 248: Fixed form source is an obsolescent feature.
   2315-I: "trstep.f", line 255, column 15: Value of real or complex expression being compared by relational operator "==", "/=", ".EQ." or ".NE.".
   3909-W: "trstep.f", line 256: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 257: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 258: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 271: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 272: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 273: Fixed form source is an obsolescent feature.
   2315-I: "trstep.f", line 276, column 21: Value of real or complex expression being compared by relational operator "==", "/=", ".EQ." or ".NE.".
   3909-W: "trstep.f", line 291: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 292: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 293: Fixed form source is an obsolescent feature.
   2315-I: "trstep.f", line 294, column 18: Value of real or complex expression being compared by relational operator "==", "/=", ".EQ." or ".NE.".
   3909-W: "trstep.f", line 312: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 313: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 314: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 327: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 328: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 329: Fixed form source is an obsolescent feature.
   2315-I: "trstep.f", line 337, column 18: Value of real or complex expression being compared by relational operator "==", "/=", ".EQ." or ".NE.".
   3909-W: "trstep.f", line 344: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 345: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 346: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 347: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 355: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 356: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 357: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 358: Fixed form source is an obsolescent feature.
   2315-I: "trstep.f", line 374, column 26: Value of real or complex expression being compared by relational operator "==", "/=", ".EQ." or ".NE.".
   3909-W: "trstep.f", line 390: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 391: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 392: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 404: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 405: Fixed form source is an obsolescent feature.
   3909-W: "trstep.f", line 406: Fixed form source is an obsolescent feature.

 Procedure information
   Lines      : 408
   Statements : 310

 Scoping unit of external sub-program : TRSTEP
   Attribute and Cross reference of name
     D
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : DIMENSION, dummy-argument
      |(Declaration)    : 1  7
      |(Definition)     : 41  131  179  186  189  197  202  220  242  244  265  321  401
      |(Reference)      : 190  192  197  198  216  220  244  252  265  310  321  398  401
     DABS
      |(Class and Type) : intrinsic function name, REAL(8)
      |(Attributes)     : PURE, ELEMENTAL
      |(Declaration)    : 
      |(Definition)     : 
      |(Reference)      : 119  119  123  123  123  180  180  185  187  315
     DELSQ
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 37
      |(Reference)      : 255  315  318
     DELTA
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : dummy-argument
      |(Declaration)    : 1
      |(Definition)     : 
      |(Reference)      : 37  37  129  138  218  228  260  263
     DHD
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 182  187  190
      |(Reference)      : 206
     DMAX1
      |(Class and Type) : intrinsic function name, REAL(8)
      |(Attributes)     : PURE, ELEMENTAL
      |(Declaration)    : 
      |(Definition)     : 
      |(Reference)      : 124  138  231  325  335
     DMIN1
      |(Class and Type) : intrinsic function name, REAL(8)
      |(Attributes)     : PURE, ELEMENTAL
      |(Declaration)    : 
      |(Definition)     : 
      |(Reference)      : 125  233  284  353
     DNORM
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 259
      |(Reference)      : 260  263
     DSIGN
      |(Class and Type) : intrinsic function name, REAL(8)
      |(Attributes)     : PURE, ELEMENTAL
      |(Declaration)    : 
      |(Definition)     : 
      |(Reference)      : 67  186  218  298  317
     DSQ
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 181  192  198  249  252
      |(Reference)      : 198  206  218  252  255  259  261  261  315
     DSQRT
      |(Class and Type) : intrinsic function name, REAL(8)
      |(Attributes)     : PURE, ELEMENTAL
      |(Declaration)    : 
      |(Definition)     : 
      |(Reference)      : 67  69  104  218  259  316
     DTG
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 214  216
      |(Reference)      : 216  218
     DTZ
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 306  310
      |(Reference)      : 310  316  316  317  317
     EVALUE
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : dummy-argument
      |(Declaration)    : 1
      |(Definition)     : 38  389
      |(Reference)      : 
     G
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : DIMENSION, dummy-argument
      |(Declaration)    : 1  7
      |(Definition)     : 
      |(Reference)      : 101  102
     GAM
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 317
      |(Reference)      : 318  318  321
     GG
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : DIMENSION, dummy-argument
      |(Declaration)    : 1  7
      |(Definition)     : 101  112
      |(Reference)      : 109  112  131  216  238  240
     GNORM
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 104
      |(Reference)      : 128  129  138  228  281  330
     GSQ
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 99  102
      |(Reference)      : 102  104  167  168  212
     H
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : DIMENSION, dummy-argument
      |(Declaration)    : 1  7
      |(Definition)     : 44  64  68  72  90
      |(Reference)      : 42  44  59  63  66  69  71  79  80  90  109  112  398  401
     HNORM
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 119  124
      |(Reference)      : 124  127  138
     I
      |(Class and Type) : variable name, INTEGER(4)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 40  58  70  78  89  100  108  111  122  130  201  215  219  239  243  251  264  296  301  307  320  397  400
      |(Reference)      : 41  42  42  42  43  44  44  59  71  71  72  72  73  73  73  79  79  79  80  80  90  90  90  90  90  101  101  102  109  109  112  112  112  123  123  123  125  131  131  202  216  216  220  220  240  240  240  240  240  244  244  244  244  244  252  253  253  265  265  297  297  298  298  302  302  302  302  302  308  308  309  310  310  321  321  321  398  398  401  401  401
     ITERC
      |(Class and Type) : variable name, INTEGER(4)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 144  148
      |(Reference)      : 148  269
     J
      |(Class and Type) : variable name, INTEGER(4)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 43  76  85
      |(Reference)      : 44  44  77  79  79  80  80  80  82  82  86  86  86  86  86  87  88  90  90  90  90
     JP
      |(Class and Type) : variable name, INTEGER(4)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 77  88
      |(Reference)      : 78  89
     K
      |(Class and Type) : variable name, INTEGER(4)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 53  105  151  159  174  195  351  361  367  394
      |(Reference)      : 54  59  63  63  64  66  67  68  68  69  71  72  106  109  112  152  153  153  153  153  155  155  156  157  157  159  160  161  162  162  179  180  180  182  184  185  186  186  187  187  189  189  190  190  190  192  194  195  196  197  197  197  197  198  201  352  352  364  365  366  366  367  372  373  375  380  380  383  395  398  401
     KIND
      |(Class and Type) : intrinsic function name, none
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 
      |(Reference)      : 4
     KP
      |(Class and Type) : variable name, INTEGER(4)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 54  106  395
      |(Reference)      : 56  57  63  64  66  68  69  70  76  85  108  111  397  400
     KPP
      |(Class and Type) : variable name, INTEGER(4)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 57
      |(Reference)      : 58
     KSAV
      |(Class and Type) : variable name, INTEGER(4)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 149  156  162
      |(Reference)      : 167  172  174
     KSAVE
      |(Class and Type) : variable name, INTEGER(4)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 359  383
      |(Reference)      : 372  373
     N
      |(Class and Type) : variable name, INTEGER(4)-implicited
      |(Attributes)     : dummy-argument
      |(Declaration)    : 1
      |(Definition)     : 
      |(Reference)      : 7  39  40  56  58  70  78  84  84  85  87  89  100  108  111  121  122  130  160  215  219  239  242  242  251  264  296  300  300  307  320  351  365  393  397  400
     NM
      |(Class and Type) : variable name, INTEGER(4)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 39  393
      |(Reference)      : 53  76  105  243  301  394
     ONE
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 34
      |(Reference)      : 179  181  186  192  212  260  260  261  276  281  286  295  298  330  337
     PAR
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 140  228  230  231  233
      |(Reference)      : 150  153  157  169  170  171  184  205  206  231  233  255  261  269  270  275  278  279  282  283  287  318  325  333  335  336  338  339  341
     PARL
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 138  205  287
      |(Reference)      : 139  140  230  269  278  338
     PARLEST
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 139  206  275  279  325  335
      |(Reference)      : 213  228  231  325  335
     PARU
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 141  170  341
      |(Reference)      : 227  230  270  270  282  282  331  333
     PARUEST
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 142  171  285  336  339
      |(Reference)      : 211  213  233  233  284  284
     PHI
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 260
      |(Reference)      : 261  261  274  277  278  279  282  283  288  332  333  335  338  339  342
     PHIL
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 288
      |(Reference)      : 277  278  338
     PHIU
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 342
      |(Reference)      : 282  332  333
     PIV
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : DIMENSION, dummy-argument
      |(Declaration)    : 1  7
      |(Definition)     : 150  153  157  364
      |(Reference)      : 152  153  155  161  162  180  182  185  187  190  197  238  240  244  253  295  298  302  308  375  380  380
     PIVKSV
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 376  379  384
      |(Reference)      : 374  375
     PIVOT
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 349  352
      |(Reference)      : 350  352  353
     POSDEF
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 143  286
      |(Reference)      : 276  294  337
     SCALE
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 129  218  263
      |(Reference)      : 131  220  265
     SHFMAX
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 350  353  377  380  385
      |(Reference)      : 353  360  388
     SHFMIN
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 348  370
      |(Reference)      : 360  380  388  389
     SHIFT
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 360
      |(Reference)      : 362  366  370  377  380  385
     SLOPE
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 278  281  282  330  333  338
      |(Reference)      : 279  283  335  339
     SUM
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 55  59  107  109  396  398
      |(Reference)      : 59  62  67  68  69  109  112  398  401
     TD
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : DIMENSION, dummy-argument
      |(Declaration)    : 1  7
      |(Definition)     : 42  86
      |(Reference)      : 73  86  119  120  123  125  150  153  157  184  349  352  362  366
     TDMIN
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 120  125
      |(Reference)      : 125  138
     TEMP
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 66  69  123  184  211  212  261  283  284  297  318  362  366
      |(Reference)      : 67  67  67  68  71  124  185  187  189  212  213  262  284  285  298  298  319  363  364  366  375  375  376  380  380  384
     TEMPA
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 315
      |(Reference)      : 316  317
     TEMPB
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 316
      |(Reference)      : 317
     TN
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : DIMENSION, dummy-argument
      |(Declaration)    : 1  7
      |(Definition)     : 63  67  121
      |(Reference)      : 68  119  123  123  153  155  180  186  187  189  190  196  197  240  244  297  302  352  366
     TOL
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : dummy-argument
      |(Declaration)    : 1
      |(Definition)     : 
      |(Reference)      : 212  261  318
     TRSTEP
      |(Class and Type) : external subroutine name
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 1
      |(Reference)      : 
     TWO
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 35
      |(Reference)      : 69  86  187  228
     W
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : DIMENSION, dummy-argument
      |(Declaration)    : 1  7
      |(Definition)     : 71  238  240  295  298
      |(Reference)      : 72  73  79  80  82  84  86  86  90  90  90  240  242  244  253  297  300  302  308
     WSQ
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 250  253
      |(Reference)      : 253  261  318
     WWSQ
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 304  308
      |(Reference)      : 308  318  325
     WZ
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 75  82  84
      |(Reference)      : 82  84  86  90
     Z
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : DIMENSION, dummy-argument
      |(Declaration)    : 1  7
      |(Definition)     : 73  79  80  300  302
      |(Reference)      : 79  80  82  84  86  90  90  302  309  310  321
     ZERO
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 36
      |(Reference)      : 38  41  55  62  64  75  99  107  121  127  128  138  141  142  143  152  155  155  161  162  167  168  169  196  202  212  213  214  227  233  249  250  255  262  270  274  282  284  294  304  305  306  319  331  348  363  374  379  396
     ZSQ
      |(Class and Type) : variable name, REAL(8)-implicited
      |(Attributes)     : 
      |(Declaration)    : 
      |(Definition)     : 305  309
      |(Reference)      : 309  316  325
   Cross reference of label
     (Label) (label-kind)               (line-no.)
     ------- ------------- ------------ ----------
        140  execution     (Definition) 148  
                           (Reference)  234
        150  execution     (Definition) 152  
                           (Reference)  160
        160  execution     (Definition) 179  
                           (Reference)  155  161
        170  execution     (Definition) 194  
                           (Reference)  199
        190  execution     (Definition) 211  
                           (Reference)  172
        220  execution     (Definition) 227  
                           (Reference)  289  343
        230  execution     (Definition) 238  
                           (Reference)  167
        320  execution     (Definition) 348  
                           (Reference)  255
        340  execution     (Definition) 360  
                           (Reference)  388
        350  execution     (Definition) 363  
                           (Reference)  368
        360  execution     (Definition) 389  
                           (Reference)  372  374
        370  execution     (Definition) 393  
                           (Reference)  133  169  222  267  269  270  277  323  332
        400  execution     (Definition) 407  
                           (Reference)  128

 Total information
   Procedures       : 1
   Total lines      : 408
   Total statements : 310


 Lahey/Fujitsu Fortran 95 Compiler Release L8.10b  Sat Feb 12 17:36:58 2022
 Copyright (C) 1994-2008 Lahey Computer Systems.  All rights reserved.
 Copyright (C) 1998-2008 FUJITSU LIMITED. All rights reserved.

 Compilation information
   Current directory : /home/zaikunzhang/Bureau/neupdfo/fsrc/classical/uobyqa
   Source file       : uobyqb.f
   Compiler options  : --ap --nblock -c --chk aefosux --chkglobal --nco 
                     : --nconcc --dal --ndbl --nf95 --nfast -g --in --info 
                     : --ninline --li --lst --nlong --maxfatals 50 --nml 
                     : --nmldefault --o0 --no --nocl --nopenmp --nparallel 
                     : --nprefetch --npca --nprivate --nquad --quiet --sav 
                     : --nshared --sse2 --nstaticlink --nswm --nthreadheap 
                     : --nthreads --trace --ntrap --nunroll --nvarheap 
                     : --nvarstack --nversion --warn --nwide --nwisk --wo --zfm 
                     : --xref

 External subroutine subprogram "uobyqb"
  (line-no.)(nest)
          1        !----------------------------------------------------------------------!
          2        !      SUBROUTINE UOBYQB (N,X,RHOBEG,RHOEND,IPRINT,MAXFUN,NPT,XBASE,
          3        !CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
          4        !C     1  XOPT,XNEW,XPT,PQ,PL,H,G,D,VLAG,W)
          5        !     1  XOPT,XNEW,XPT,PQ,PL,H,G,D,VLAG,W,F,INFO,FTARGET)
          6        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
          7        !CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
          8        !C      IMPLICIT REAL*8 (A-H,O-Z)
          9        !      IMPLICIT REAL(KIND(0.0D0)) (A-H,O-Z)
         10        !      IMPLICIT INTEGER (I-N)
         11        !----------------------------------------------------------------------!
         12        
         13              subroutine uobyqb(calfun, n, x, rhobeg, rhoend, iprint, maxfun,
         14             & npt, xbase, xopt, xnew, xpt, pq, pl, h, g, d, vlag, w, f, info,
         15             & ftarget, nf, xhist, maxxhist, fhist, maxfhist)
         16        
         17              use, non_intrinsic :: consts_mod, only : RP, IK
         18              use, non_intrinsic :: evaluate_mod, only : evaluate
         19              use, non_intrinsic :: history_mod, only : savehist, rangehist
         20              use, non_intrinsic :: pintrf_mod, only : OBJ
         21        
         22              implicit real(RP) (a - h, o - z)
         23              implicit integer(IK) (i - n)
         24        
         25              procedure(OBJ) :: calfun
         26              integer(IK), intent(in) :: maxxhist
         27              integer(IK), intent(in) :: maxfhist
         28              integer(IK), intent(in) :: npt
         29              integer(IK), intent(out) :: nf
         30              real(RP), intent(inout) :: x(n)
         31              real(RP), intent(out) :: xhist(n, maxxhist)
         32              real(RP), intent(out) :: fhist(maxfhist)
         33        
         34        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         35              DIMENSION XBASE(*),XOPT(*),XNEW(*),XPT(NPT,*),PQ(*),
         36             1  PL(NPT,*),H(N,*),G(*),D(*),VLAG(*),W(*)
         37        C
         38        C     The arguments N, X, RHOBEG, RHOEND, IPRINT and MAXFUN are identical to
         39        C       the corresponding arguments in SUBROUTINE UOBYQA.
         40        C     NPT is set by UOBYQA to (N*N+3*N+2)/2 for the above dimension statement.
         41        C     XBASE will contain a shift of origin that reduces the contributions from
         42        C       rounding errors to values of the model and Lagrange functions.
         43        C     XOPT will be set to the displacement from XBASE of the vector of
         44        C       variables that provides the least calculated F so far.
         45        C     XNEW will be set to the displacement from XBASE of the vector of
         46        C       variables for the current calculation of F.
         47        C     XPT will contain the interpolation point coordinates relative to XBASE.
         48        C     PQ will contain the parameters of the quadratic model.
         49        C     PL will contain the parameters of the Lagrange functions.
         50        C     H will provide the second derivatives that TRSTEP and LAGMAX require.
         51        C     G will provide the first derivatives that TRSTEP and LAGMAX require.
         52        C     D is reserved for trial steps from XOPT, except that it will contain
         53        C       diagonal second derivatives during the initialization procedure.
         54        C     VLAG will contain the values of the Lagrange functions at a new point X.
         55        C     The array W will be used for working space. Its length must be at least
         56        C     max [ 6*N, ( N**2 + 3*N + 2 ) / 2 ].
         57        C
         58        C     Set some constants.
         59        C
         60              ONE=1.0D0
         61              TWO=2.0D0
         62              ZERO=0.0D0
         63              HALF=0.5D0
         64              TOL=0.01D0
         65              NNP=N+N+1
         66              NPTM=NPT-1
         67              NFTEST=MAX0(MAXFUN,1)
         68        C
         69        C     Initialization. NF is the number of function calculations so far.
         70        C
         71              RHO=RHOBEG
         72              RHOSQ=RHO*RHO
         73              NF=0
         74     1        DO I=1,N
         75     1            XBASE(I)=X(I)
         76     2            DO K=1,NPT
         77     2                XPT(K,I)=ZERO
         78     2            END DO
         79     1        END DO
         80     1        DO K=1,NPT
         81     2            DO J=1,NPTM
         82     2                PL(K,J)=ZERO
         83     2            END DO
         84     1        END DO
         85        C
         86        C     The branch to label 120 obtains a new value of the objective function
         87        C     and then there is a branch back to label 50, because the new function
         88        C     value is needed to form the initial quadratic model. The least function
         89        C     value so far and its index are noted below.
         90        C
         91     1     30 DO I=1,N
         92     1            X(I)=XBASE(I)+XPT(NF+1,I)
         93     1        END DO
         94              GOTO 120
         95     1     50 IF (NF == 1) THEN
         96     1            FOPT=F
         97     1            KOPT=NF
         98     1            FBASE=F
         99     1            J=0
        100     1            JSWITCH=-1
        101     1            IH=N
        102     1        ELSE
        103     2            IF (F < FOPT) THEN
        104     2                FOPT=F
        105     2                KOPT=NF
        106     2            END IF
        107     1        END IF
        108        C
        109        C     Form the gradient and diagonal second derivatives of the initial
        110        C     quadratic model and Lagrange functions.
        111        C
        112     1        IF (NF <= NNP) THEN
        113     1            JSWITCH=-JSWITCH
        114     2            IF (JSWITCH > 0) THEN
        115     3                IF (J >= 1) THEN
        116     3                    IH=IH+J
        117     4                    IF (W(J) < ZERO) THEN
        118     4                        D(J)=(FSAVE+F-TWO*FBASE)/RHOSQ
        119     4                        PQ(J)=(FSAVE-F)/(TWO*RHO)
        120     4                        PL(1,IH)=-TWO/RHOSQ
        121     4                        PL(NF-1,J)=HALF/RHO
        122     4                        PL(NF-1,IH)=ONE/RHOSQ
        123     4                    ELSE
        124     4                        PQ(J)=(4.0D0*FSAVE-3.0D0*FBASE-F)/(TWO*RHO)
        125     4                        D(J)=(FBASE+F-TWO*FSAVE)/RHOSQ
        126     4                        PL(1,J)=-1.5D0/RHO
        127     4                        PL(1,IH)=ONE/RHOSQ
        128     4                        PL(NF-1,J)=TWO/RHO
        129     4                        PL(NF-1,IH)=-TWO/RHOSQ
        130     4                    END IF
        131     3                    PQ(IH)=D(J)
        132     3                    PL(NF,J)=-HALF/RHO
        133     3                    PL(NF,IH)=ONE/RHOSQ
        134     3                END IF
        135     2  C
        136     2  C     Pick the shift from XBASE to the next initial interpolation point
        137     2  C     that provides diagonal second derivatives.
        138     2  C
        139     3                IF (J < N) THEN
        140     3                    J=J+1
        141     3                    XPT(NF+1,J)=RHO
        142     3                END IF
        143     2            ELSE
        144     2                FSAVE=F
        145     3                IF (F < FBASE) THEN
        146     3                    W(J)=RHO
        147     3                    XPT(NF+1,J)=TWO*RHO
        148     3                ELSE
        149     3                    W(J)=-RHO
        150     3                    XPT(NF+1,J)=-RHO
        151     3                END IF
        152     2            END IF
        153     1            IF (NF < NNP) GOTO 30
        154     1  C
        155     1  C     Form the off-diagonal second derivatives of the initial quadratic model.
        156     1  C
        157     1            IH=N
        158     1            IP=1
        159     1            IQ=2
        160     1        END IF
        161              IH=IH+1
        162     1        IF (NF > NNP) THEN
        163     1            TEMP=ONE/(W(IP)*W(IQ))
        164     1            TEMPA=F-FBASE-W(IP)*PQ(IP)-W(IQ)*PQ(IQ)
        165     1            PQ(IH)=(TEMPA-HALF*RHOSQ*(D(IP)+D(IQ)))*TEMP
        166     1            PL(1,IH)=TEMP
        167     1            IW=IP+IP
        168     1            IF (W(IP) < ZERO) IW=IW+1
        169     1            PL(IW,IH)=-TEMP
        170     1            IW=IQ+IQ
        171     1            IF (W(IQ) < ZERO) IW=IW+1
        172     1            PL(IW,IH)=-TEMP
        173     1            PL(NF,IH)=TEMP
        174     1  C
        175     1  C     Pick the shift from XBASE to the next initial interpolation point
        176     1  C     that provides off-diagonal second derivatives.
        177     1  C
        178     1            IP=IP+1
        179     1        END IF
        180     1        IF (IP == IQ) THEN
        181     1            IH=IH+1
        182     1            IP=1
        183     1            IQ=IQ+1
        184     1        END IF
        185     1        IF (NF < NPT) THEN
        186     1            XPT(NF+1,IP)=W(IP)
        187     1            XPT(NF+1,IQ)=W(IQ)
        188     1            GOTO 30
        189     1        END IF
        190        C
        191        C     Set parameters to begin the iterations for the current RHO.
        192        C
        193              SIXTHM=ZERO
        194              DELTA=RHO
        195           60 TWORSQ=(TWO*RHO)**2
        196              RHOSQ=RHO*RHO
        197        C
        198        C     Form the gradient of the quadratic model at the trust region centre.
        199        C
        200           70 KNEW=0
        201              IH=N
        202     1        DO J=1,N
        203     1            XOPT(J)=XPT(KOPT,J)
        204     1            G(J)=PQ(J)
        205     2            DO I=1,J
        206     2                IH=IH+1
        207     2                G(I)=G(I)+PQ(IH)*XOPT(J)
        208     2                IF (I < J) G(J)=G(J)+PQ(IH)*XOPT(I)
        209     2                H(I,J)=PQ(IH)
        210     2            END DO
        211     1        END DO
        212        C
        213        C     Generate the next trust region step and test its length. Set KNEW
        214        C     to -1 if the purpose of the next F will be to improve conditioning,
        215        C     and also calculate a lower bound on the Hessian term of the model Q.
        216        C
        217              CALL TRSTEP (N,G,H,DELTA,TOL,D,W(1),W(N+1),W(2*N+1),W(3*N+1),
        218             1  W(4*N+1),W(5*N+1),EVALUE)
        219              TEMP=ZERO
        220     1        DO I=1,N
        221     1            TEMP=TEMP+D(I)**2
        222     1        END DO
        223              DNORM=DMIN1(DELTA,DSQRT(TEMP))
        224              ERRTOL=-ONE
        225     1        IF (DNORM < HALF*RHO) THEN
        226     1            KNEW=-1
        227     1            ERRTOL=HALF*EVALUE*RHO*RHO
        228     1            IF (NF <= NPT+9) ERRTOL=ZERO
        229     1            GOTO 290
        230     1        END IF
        231        C
        232        C     Calculate the next value of the objective function.
        233        C
        234     1    100 DO I=1,N
        235     1            XNEW(I)=XOPT(I)+D(I)
        236     1            X(I)=XBASE(I)+XNEW(I)
        237     1        END DO
        238     1    120 IF (NF >= NFTEST) THEN
        239     1            IF (IPRINT > 0) PRINT 130
        240     1    130     FORMAT (/4X,'Return from UOBYQA because CALFUN has been',
        241     1       1      ' called MAXFUN times')
        242     1  CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
        243     1            INFO=3
        244     1  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        245     1            GOTO 420
        246     1        END IF
        247              NF=NF+1
        248        !------------------------------------------------------------------------!
        249              !CALL CALFUN (N,X,F)
        250              call evaluate(calfun, x, f)
        251              call savehist(nf, x, xhist, f, fhist)
        252        !------------------------------------------------------------------------!
        253        
        254        CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
        255        C     By Zaikun (commented on 02-06-2019; implemented in 2016):
        256        C     Exit if F .LE. FTARGET.
        257     1        IF (F <= FTARGET) THEN
        258     1            INFO=1
        259     1            GOTO 436
        260     1        END IF
        261        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        262        
        263     1        IF (IPRINT == 3) THEN
        264     1            PRINT 140, NF,F,(X(I),I=1,N)
        265     1    140      FORMAT (/4X,'Function number',I6,'    F =',1PD18.10,
        266     1       1       '    The corresponding X is:'/(2X,5D15.6))
        267     1        END IF
        268              IF (NF <= NPT) GOTO 50
        269        CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
        270        C      IF (KNEW .EQ. -1) GOTO 420
        271     1        IF (KNEW == -1) THEN
        272     1            INFO=0
        273     1            GOTO 420
        274     1        END IF
        275        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        276        C
        277        C     Use the quadratic model to predict the change in F due to the step D,
        278        C     and find the values of the Lagrange functions at the new point.
        279        C
        280              VQUAD=ZERO
        281              IH=N
        282     1        DO J=1,N
        283     1            W(J)=D(J)
        284     1            VQUAD=VQUAD+W(J)*PQ(J)
        285     2            DO I=1,J
        286     2                IH=IH+1
        287     2                W(IH)=D(I)*XNEW(J)+D(J)*XOPT(I)
        288     2                IF (I == J) W(IH)=HALF*W(IH)
        289     2                VQUAD=VQUAD+W(IH)*PQ(IH)
        290     2            END DO
        291     1        END DO
        292     1        DO K=1,NPT
        293     1            TEMP=ZERO
        294     2            DO J=1,NPTM
        295     2                TEMP=TEMP+W(J)*PL(K,J)
        296     2            END DO
        297     1            VLAG(K)=TEMP
        298     1        END DO
        299              VLAG(KOPT)=VLAG(KOPT)+ONE
        300        C
        301        C     Update SIXTHM, which is a lower bound on one sixth of the greatest
        302        C     third derivative of F.
        303        C
        304              DIFF=F-FOPT-VQUAD
        305              SUM=ZERO
        306     1        DO K=1,NPT
        307     1            TEMP=ZERO
        308     2            DO I=1,N
        309     2                TEMP=TEMP+(XPT(K,I)-XNEW(I))**2
        310     2            END DO
        311     1            TEMP=DSQRT(TEMP)
        312     1            SUM=SUM+DABS(TEMP*TEMP*TEMP*VLAG(K))
        313     1        END DO
        314              SIXTHM=DMAX1(SIXTHM,DABS(DIFF)/SUM)
        315        C
        316        C     Update FOPT and XOPT if the new F is the least value of the objective
        317        C     function so far. Then branch if D is not a trust region step.
        318        C
        319              FSAVE=FOPT
        320     1        IF (F < FOPT) THEN
        321     1            FOPT=F
        322     2            DO I=1,N
        323     2                XOPT(I)=XNEW(I)
        324     2            END DO
        325     1        END IF
        326              KSAVE=KNEW
        327              IF (KNEW > 0) GOTO 240
        328        C
        329        C     Pick the next value of DELTA after a trust region step.
        330        C
        331     1        IF (VQUAD >= ZERO) THEN
        332     1            IF (IPRINT > 0) PRINT 210
        333     1    210     FORMAT (/4X,'Return from UOBYQA because a trust',
        334     1       1      ' region step has failed to reduce Q')
        335     1  CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
        336     1            INFO=2
        337     1  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        338     1            GOTO 420
        339     1        END IF
        340              RATIO=(F-FSAVE)/VQUAD
        341     1        IF (RATIO <= 0.1D0) THEN
        342     1            DELTA=HALF*DNORM
        343     1        ELSE IF (RATIO. LE. 0.7D0) THEN
        344     1            DELTA=DMAX1(HALF*DELTA,DNORM)
        345     1        ELSE
        346     1            DELTA=DMAX1(DELTA,1.25D0*DNORM,DNORM+RHO)
        347     1        END IF
        348              IF (DELTA <= 1.5D0*RHO) DELTA=RHO
        349        C
        350        C     Set KNEW to the index of the next interpolation point to be deleted.
        351        C
        352              KTEMP=0
        353              DETRAT=ZERO
        354     1        IF (F >= FSAVE) THEN
        355     1            KTEMP=KOPT
        356     1            DETRAT=ONE
        357     1        END IF
        358     1        DO K=1,NPT
        359     1            SUM=ZERO
        360     2            DO I=1,N
        361     2                SUM=SUM+(XPT(K,I)-XOPT(I))**2
        362     2            END DO
        363     1            TEMP=DABS(VLAG(K))
        364     1            IF (SUM > RHOSQ) TEMP=TEMP*(SUM/RHOSQ)**1.5D0
        365     2            IF (TEMP > DETRAT .AND. K /= KTEMP) THEN
        366     2                DETRAT=TEMP
        367     2                DDKNEW=SUM
        368     2                KNEW=K
        369     2            END IF
        370     1        END DO
        371              IF (KNEW == 0) GOTO 290
        372        C
        373        C     Replace the interpolation point that has index KNEW by the point XNEW,
        374        C     and also update the Lagrange functions and the quadratic model.
        375        C
        376     1    240 DO I=1,N
        377     1            XPT(KNEW,I)=XNEW(I)
        378     1        END DO
        379              TEMP=ONE/VLAG(KNEW)
        380     1        DO J=1,NPTM
        381     1            PL(KNEW,J)=TEMP*PL(KNEW,J)
        382     1            PQ(J)=PQ(J)+DIFF*PL(KNEW,J)
        383     1        END DO
        384     1        DO K=1,NPT
        385     2            IF (K /= KNEW) THEN
        386     2                TEMP=VLAG(K)
        387     3                DO J=1,NPTM
        388     3                    PL(K,J)=PL(K,J)-TEMP*PL(KNEW,J)
        389     3                END DO
        390     2            END IF
        391     1        END DO
        392        C
        393        C     Update KOPT if F is the least calculated value of the objective
        394        C     function. Then branch for another trust region calculation. The
        395        C     case KSAVE>0 indicates that a model step has just been taken.
        396        C
        397     1        IF (F < FSAVE) THEN
        398     1            KOPT=KNEW
        399     1            GOTO 70
        400     1        END IF
        401              IF (KSAVE > 0) GOTO 70
        402              IF (DNORM > TWO*RHO) GOTO 70
        403              IF (DDKNEW > TWORSQ) GOTO 70
        404        C
        405        C     Alternatively, find out if the interpolation points are close
        406        C     enough to the best point so far.
        407        C
        408     1    290 DO K=1,NPT
        409     1            W(K)=ZERO
        410     2            DO I=1,N
        411     2                W(K)=W(K)+(XPT(K,I)-XOPT(I))**2
        412     2            END DO
        413     1        END DO
        414          310 KNEW=-1
        415              DISTEST=TWORSQ
        416     1        DO K=1,NPT
        417     2            IF (W(K) > DISTEST) THEN
        418     2                KNEW=K
        419     2                DISTEST=W(K)
        420     2            END IF
        421     1        END DO
        422        C
        423        C     If a point is sufficiently far away, then set the gradient and Hessian
        424        C     of its Lagrange function at the centre of the trust region, and find
        425        C     half the sum of squares of components of the Hessian.
        426        C
        427     1        IF (KNEW > 0) THEN
        428     1            IH=N
        429     1            SUMH=ZERO
        430     2            DO J=1,N
        431     2                G(J)=PL(KNEW,J)
        432     3                DO I=1,J
        433     3                    IH=IH+1
        434     3                    TEMP=PL(KNEW,IH)
        435     3                    G(J)=G(J)+TEMP*XOPT(I)
        436     4                    IF (I < J) THEN
        437     4                        G(I)=G(I)+TEMP*XOPT(J)
        438     4                        SUMH=SUMH+TEMP*TEMP
        439     4                    END IF
        440     3                    H(I,J)=TEMP
        441     3                END DO
        442     2                SUMH=SUMH+HALF*TEMP*TEMP
        443     2            END DO
        444     1  C
        445     1  C     If ERRTOL is positive, test whether to replace the interpolation point
        446     1  C     with index KNEW, using a bound on the maximum modulus of its Lagrange
        447     1  C     function in the trust region.
        448     1  C
        449     2            IF (ERRTOL > ZERO) THEN
        450     2                W(KNEW)=ZERO
        451     2                SUMG=ZERO
        452     3                DO I=1,N
        453     3                    SUMG=SUMG+G(I)**2
        454     3                END DO
        455     2                ESTIM=RHO*(DSQRT(SUMG)+RHO*DSQRT(HALF*SUMH))
        456     2                WMULT=SIXTHM*DISTEST**1.5D0
        457     2                IF (WMULT*ESTIM <= ERRTOL) GOTO 310
        458     2            END IF
        459     1  C
        460     1  C     If the KNEW-th point may be replaced, then pick a D that gives a large
        461     1  C     value of the modulus of its Lagrange function within the trust region.
        462     1  C     Here the vector XNEW is used as temporary working space.
        463     1  C
        464     1            CALL LAGMAX (N,G,H,RHO,D,XNEW,VMAX)
        465     2            IF (ERRTOL > ZERO) THEN
        466     2                IF (WMULT*VMAX <= ERRTOL) GOTO 310
        467     2            END IF
        468     1            GOTO 100
        469     1        END IF
        470              IF (DNORM > RHO) GOTO 70
        471        C
        472        C     Prepare to reduce RHO by shifting XBASE to the best point so far,
        473        C     and make the corresponding changes to the gradients of the Lagrange
        474        C     functions and the quadratic model.
        475        C
        476     1        IF (RHO > RHOEND) THEN
        477     1            IH=N
        478     2            DO J=1,N
        479     2                XBASE(J)=XBASE(J)+XOPT(J)
        480     3                DO K=1,NPT
        481     3                    XPT(K,J)=XPT(K,J)-XOPT(J)
        482     3                END DO
        483     3                DO I=1,J
        484     3                    IH=IH+1
        485     3                    PQ(I)=PQ(I)+PQ(IH)*XOPT(J)
        486     4                    IF (I < J) THEN
        487     4                        PQ(J)=PQ(J)+PQ(IH)*XOPT(I)
        488     5                        DO K=1,NPT
        489     5                            PL(K,J)=PL(K,J)+PL(K,IH)*XOPT(I)
        490     5                        END DO
        491     4                    END IF
        492     4                    DO K=1,NPT
        493     4                        PL(K,I)=PL(K,I)+PL(K,IH)*XOPT(J)
        494     4                    END DO
        495     3                END DO
        496     2            END DO
        497     1  C
        498     1  C     Pick the next values of RHO and DELTA.
        499     1  C
        500     1            DELTA=HALF*RHO
        501     1            RATIO=RHO/RHOEND
        502     2            IF (RATIO <= 16.0D0) THEN
        503     2                RHO=RHOEND
        504     2            ELSE IF (RATIO <= 250.0D0) THEN
        505     2                RHO=DSQRT(RATIO)*RHOEND
        506     2            ELSE
        507     2                RHO=0.1D0*RHO
        508     2            END IF
        509     1            DELTA=DMAX1(DELTA,RHO)
        510     2            IF (IPRINT >= 2) THEN
        511     2                IF (IPRINT >= 3) PRINT 390
        512     2    390         FORMAT (5X)
        513     2                PRINT 400, RHO,NF
        514     2    400         FORMAT (/4X,'New RHO =',1PD11.4,5X,'Number of',
        515     2       1          ' function values =',I6)
        516     2                PRINT 410, FOPT,(XBASE(I),I=1,N)
        517     2    410         FORMAT (4X,'Least value of F =',1PD23.15,9X,
        518     2       1          'The corresponding X is:'/(2X,5D15.6))
        519     2            END IF
        520     1            GOTO 60
        521     1        END IF
        522        C
        523        C     Return from the calculation, after another Newton-Raphson step, if
        524        C     it is too short to have been tried before.
        525        C
        526        CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
        527              INFO=0
        528        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        529              IF (ERRTOL >= ZERO) GOTO 100
        530     1    420 IF (FOPT <= F) THEN
        531     2            DO I=1,N
        532     2                X(I)=XBASE(I)+XOPT(I)
        533     2            END DO
        534     1            F=FOPT
        535     1        END IF
        536        CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
        537        C      IF (IPRINT .GE. 1) THEN
        538     1    436 IF (IPRINT >= 1) THEN
        539     1  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        540     1            PRINT 440, NF
        541     1    440     FORMAT (/4X,'At the return from UOBYQA',5X,
        542     1       1      'Number of function values =',I6)
        543     1            PRINT 410, F,(X(I),I=1,N)
        544     1        END IF
        545        
        546        !---------------------------------------------!
        547              call rangehist(nf, xhist, fhist)
        548        !---------------------------------------------!
        549        
        550              RETURN
        551              END

 Diagnostic messages: program name(uobyqb)
   3909-W: "uobyqb.f", line 14: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 15: Fixed form source is an obsolescent feature.
   1333-S: "uobyqb.f", line 17, column 10: Name expected.
   1333-S: "uobyqb.f", line 18, column 10: Name expected.
   1333-S: "uobyqb.f", line 19, column 10: Name expected.
   1333-S: "uobyqb.f", line 20, column 10: Name expected.
   1185-S: "uobyqb.f", line 22: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "uobyqb.f", line 22, column 21: Type specification or length specification invalid.
   1185-S: "uobyqb.f", line 23: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "uobyqb.f", line 23, column 24: Type specification or length specification invalid.
   1302-S: "uobyqb.f", line 25: Not a valid Fortran statement.
   1185-S: "uobyqb.f", line 26: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "uobyqb.f", line 26, column 15: Type specification or length specification invalid.
   1185-S: "uobyqb.f", line 27: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "uobyqb.f", line 27, column 15: Type specification or length specification invalid.
   1185-S: "uobyqb.f", line 28: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "uobyqb.f", line 28, column 15: Type specification or length specification invalid.
   1185-S: "uobyqb.f", line 29: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "uobyqb.f", line 29, column 15: Type specification or length specification invalid.
   1185-S: "uobyqb.f", line 30: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "uobyqb.f", line 30, column 12: Type specification or length specification invalid.
   1185-S: "uobyqb.f", line 31: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "uobyqb.f", line 31, column 12: Type specification or length specification invalid.
   1185-S: "uobyqb.f", line 32: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "uobyqb.f", line 32, column 12: Type specification or length specification invalid.
   2018-S: "uobyqb.f", line 35: When IMPLICIT NONE is specified, 'NPT' must be declared in a type declaration statement.
   2018-S: "uobyqb.f", line 35: When IMPLICIT NONE is specified, 'XPT' must be declared in a type declaration statement.
   2018-S: "uobyqb.f", line 35: When IMPLICIT NONE is specified, 'PL' must be declared in a type declaration statement.
   2018-S: "uobyqb.f", line 35: When IMPLICIT NONE is specified, 'N' must be declared in a type declaration statement.
   2018-S: "uobyqb.f", line 35: When IMPLICIT NONE is specified, 'H' must be declared in a type declaration statement.
   3909-W: "uobyqb.f", line 36: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 37: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 38: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 39: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 40: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 41: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 42: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 43: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 44: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 45: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 46: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 47: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 48: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 49: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 50: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 51: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 52: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 53: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 54: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 55: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 56: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 57: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 58: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 59: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 68: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 69: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 70: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 85: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 86: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 87: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 88: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 89: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 90: Fixed form source is an obsolescent feature.
   1719-S: "uobyqb.f", line 92, column 11: 'X' already used as a function name.
   3909-W: "uobyqb.f", line 108: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 109: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 110: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 111: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 135: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 136: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 137: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 138: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 154: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 155: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 156: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 174: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 175: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 176: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 177: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 190: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 191: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 192: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 197: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 198: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 199: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 212: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 213: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 214: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 215: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 216: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 218: Fixed form source is an obsolescent feature.
   2018-S: "uobyqb.f", line 224: When IMPLICIT NONE is specified, 'ERRTOL' must be declared in a type declaration statement.
   3909-W: "uobyqb.f", line 231: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 232: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 233: Fixed form source is an obsolescent feature.
   1719-S: "uobyqb.f", line 236, column 11: 'X' already used as a function name.
   2018-S: "uobyqb.f", line 239: When IMPLICIT NONE is specified, 'IPRINT' must be declared in a type declaration statement.
   3909-W: "uobyqb.f", line 241: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 242: Fixed form source is an obsolescent feature.
   2018-S: "uobyqb.f", line 243: When IMPLICIT NONE is specified, 'INFO' must be declared in a type declaration statement.
   3909-W: "uobyqb.f", line 254: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 255: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 256: Fixed form source is an obsolescent feature.
   2018-S: "uobyqb.f", line 257: When IMPLICIT NONE is specified, 'FTARGET' must be declared in a type declaration statement.
   3909-W: "uobyqb.f", line 266: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 269: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 270: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 276: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 277: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 278: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 279: Fixed form source is an obsolescent feature.
   2018-S: "uobyqb.f", line 280: When IMPLICIT NONE is specified, 'VQUAD' must be declared in a type declaration statement.
   3909-W: "uobyqb.f", line 300: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 301: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 302: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 303: Fixed form source is an obsolescent feature.
   2018-S: "uobyqb.f", line 304: When IMPLICIT NONE is specified, 'DIFF' must be declared in a type declaration statement.
   2018-S: "uobyqb.f", line 305: When IMPLICIT NONE is specified, 'SUM' must be declared in a type declaration statement.
   3909-W: "uobyqb.f", line 315: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 316: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 317: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 318: Fixed form source is an obsolescent feature.
   2018-S: "uobyqb.f", line 326: When IMPLICIT NONE is specified, 'KSAVE' must be declared in a type declaration statement.
   3909-W: "uobyqb.f", line 328: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 329: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 330: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 334: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 335: Fixed form source is an obsolescent feature.
   2018-S: "uobyqb.f", line 340: When IMPLICIT NONE is specified, 'RATIO' must be declared in a type declaration statement.
   3909-W: "uobyqb.f", line 349: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 350: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 351: Fixed form source is an obsolescent feature.
   2018-S: "uobyqb.f", line 352: When IMPLICIT NONE is specified, 'KTEMP' must be declared in a type declaration statement.
   2018-S: "uobyqb.f", line 353: When IMPLICIT NONE is specified, 'DETRAT' must be declared in a type declaration statement.
   2018-S: "uobyqb.f", line 367: When IMPLICIT NONE is specified, 'DDKNEW' must be declared in a type declaration statement.
   3909-W: "uobyqb.f", line 372: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 373: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 374: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 375: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 392: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 393: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 394: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 395: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 396: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 404: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 405: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 406: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 407: Fixed form source is an obsolescent feature.
   2018-S: "uobyqb.f", line 415: When IMPLICIT NONE is specified, 'DISTEST' must be declared in a type declaration statement.
   3909-W: "uobyqb.f", line 422: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 423: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 424: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 425: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 426: Fixed form source is an obsolescent feature.
   2018-S: "uobyqb.f", line 429: When IMPLICIT NONE is specified, 'SUMH' must be declared in a type declaration statement.
   3909-W: "uobyqb.f", line 444: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 445: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 446: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 447: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 448: Fixed form source is an obsolescent feature.
   2018-S: "uobyqb.f", line 451: When IMPLICIT NONE is specified, 'SUMG' must be declared in a type declaration statement.
   2018-S: "uobyqb.f", line 455: When IMPLICIT NONE is specified, 'ESTIM' must be declared in a type declaration statement.
   2018-S: "uobyqb.f", line 456: When IMPLICIT NONE is specified, 'WMULT' must be declared in a type declaration statement.
   3909-W: "uobyqb.f", line 459: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 460: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 461: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 462: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 463: Fixed form source is an obsolescent feature.
   2018-S: "uobyqb.f", line 464: When IMPLICIT NONE is specified, 'VMAX' must be declared in a type declaration statement.
   3909-W: "uobyqb.f", line 471: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 472: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 473: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 474: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 475: Fixed form source is an obsolescent feature.
   2018-S: "uobyqb.f", line 476: When IMPLICIT NONE is specified, 'RHOEND' must be declared in a type declaration statement.
   3909-W: "uobyqb.f", line 497: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 498: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 499: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 515: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 518: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 522: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 523: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 524: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 525: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 526: Fixed form source is an obsolescent feature.
   1719-S: "uobyqb.f", line 532, column 15: 'X' already used as a function name.
   3909-W: "uobyqb.f", line 536: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 537: Fixed form source is an obsolescent feature.
   3909-W: "uobyqb.f", line 542: Fixed form source is an obsolescent feature.

 Procedure information
   Lines      : 551
   Statements : 380

 Total information
   Procedures       : 1
   Total lines      : 551
   Total statements : 380


 Lahey/Fujitsu Fortran 95 Compiler Release L8.10b  Sat Feb 12 17:36:58 2022
 Copyright (C) 1994-2008 Lahey Computer Systems.  All rights reserved.
 Copyright (C) 1998-2008 FUJITSU LIMITED. All rights reserved.

 Compilation information
   Current directory : /home/zaikunzhang/Bureau/neupdfo/fsrc/classical/uobyqa
   Source file       : uobyqa.f90
   Compiler options  : --ap --nblock -c --chk aefosux --chkglobal --nco 
                     : --nconcc --dal --ndbl --nf95 --nfast -g --in --info 
                     : --ninline --li --lst --nlong --maxfatals 50 --nml 
                     : --nmldefault --o0 --no --nocl --nopenmp --nparallel 
                     : --nprefetch --npca --nprivate --nquad --quiet --sav 
                     : --nshared --sse2 --nstaticlink --nswm --nthreadheap 
                     : --nthreads --trace --ntrap --nunroll --nvarheap 
                     : --nvarstack --nversion --warn --nwide --nwisk --wo --zfm 
                     : --xref

 Module "uobyqa_mod"
  (line-no.)(nest)
          1        module uobyqa_mod
          2        !--------------------------------------------------------------------------------------------------!
          3        ! Classical mode. Not maintained. Not recommended. Please use the modernized version instead.
          4        !
          5        ! The usage is the same as the modernized version.
          6        !--------------------------------------------------------------------------------------------------!
          7        
          8        implicit none
          9        private
         10        public :: uobyqa
         11        
         12        
         13        contains
         14        
         15        
         16        subroutine uobyqa(calfun, x, f, &
         17            & nf, rhobeg, rhoend, ftarget, maxfun, iprint, eta1, eta2, gamma1, gamma2, &
         18            & xhist, fhist, maxhist, info)
         19        
         20        ! Generic modules
         21        use, non_intrinsic :: consts_mod, only : DEBUGGING
         22        use, non_intrinsic :: consts_mod, only : MAXFUN_DIM_DFT
         23        use, non_intrinsic :: consts_mod, only : RHOBEG_DFT, RHOEND_DFT, FTARGET_DFT, IPRINT_DFT
         24        use, non_intrinsic :: consts_mod, only : RP, IK, ZERO, ONE, TWO, HALF, TEN, TENTH, EPS, MSGLEN
         25        use, non_intrinsic :: debug_mod, only : assert, warning
         26        use, non_intrinsic :: evaluate_mod, only : moderatex
         27        use, non_intrinsic :: history_mod, only : prehist
         28        use, non_intrinsic :: infnan_mod, only : is_nan, is_finite
         29        use, non_intrinsic :: memory_mod, only : safealloc
         30        use, non_intrinsic :: pintrf_mod, only : OBJ
         31        use, non_intrinsic :: preproc_mod, only : preproc
         32        
         33        ! Solver-specific modules
         34        !use, non_intrinsic :: uobyqb_mod, only : uobyqb
         35        
         36        implicit none
         37        
         38        ! Arguments
         39        procedure(OBJ) :: calfun
         40        ! N.B.: The INTENT attribute cannot be specified for a dummy procedure without the POINTER attribute
         41        real(RP), intent(inout) :: x(:)
         42        real(RP), intent(out) :: f
         43        integer(IK), intent(out), optional :: nf
         44        real(RP), intent(in), optional :: rhobeg
         45        real(RP), intent(in), optional :: rhoend
         46        real(RP), intent(in), optional :: ftarget
         47        integer(IK), intent(in), optional :: maxfun
         48        integer(IK), intent(in), optional :: iprint
         49        real(RP), intent(in), optional :: eta1
         50        real(RP), intent(in), optional :: eta2
         51        real(RP), intent(in), optional :: gamma1
         52        real(RP), intent(in), optional :: gamma2
         53        real(RP), intent(out), optional, allocatable :: fhist(:)
         54        real(RP), intent(out), optional, allocatable :: xhist(:, :)
         55        integer(IK), intent(in), optional :: maxhist
         56        integer(IK), intent(out), optional :: info
         57        
         58        ! Local variables
         59        character(len=*), parameter :: ifmt = '(I0)'  ! I0: use the minimum number of digits needed to print
         60        character(len=*), parameter :: solver = 'UOBYQA'
         61        character(len=*), parameter :: srname = 'UOBYQA'
         62        character(len=MSGLEN) :: wmsg
         63        integer(IK) :: info_loc
         64        integer(IK) :: iprint_loc
         65        integer(IK) :: maxfun_loc
         66        integer(IK) :: maxhist_loc
         67        integer(IK) :: n
         68        integer(IK) :: nf_loc
         69        integer(IK) :: nhist
         70        real(RP) :: eta1_loc
         71        real(RP) :: eta2_loc
         72        real(RP) :: ftarget_loc
         73        real(RP) :: gamma1_loc
         74        real(RP) :: gamma2_loc
         75        real(RP) :: rhobeg_loc
         76        real(RP) :: rhoend_loc
         77        real(RP), allocatable :: fhist_loc(:)
         78        real(RP), allocatable :: xhist_loc(:, :)
         79        
         80        
         81        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         82        ! Working variables
         83        real(RP), allocatable :: w(:)
         84        integer(IK) :: npt, ixb, ixo, ixn, ixp, ipq, ipl, ih, ig, id, ivl, iw
         85        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         86        
         87        
         88        ! Sizes
         89        n = int(size(x), kind(n))
         90        
         91        ! Replace any NaN in X by ZERO and Inf/-Inf in X by HUGENUM/-HUGENUM.
         92        x = moderatex(x)
         93        
         94        ! Read the inputs.
         95        
         96        ! If RHOBEG is present, then RHOBEG_LOC is a copy of RHOBEG; otherwise, RHOBEG_LOC takes the default
         97        ! value for RHOBEG, taking the value of RHOEND into account. Note that RHOEND is considered only if
         98        ! it is present and it is VALID (i.e., finite and positive). The other inputs are read similarly.
         99     1  if (present(rhobeg)) then
        100     1      rhobeg_loc = rhobeg
        101     1  elseif (present(rhoend)) then
        102     1      ! Fortran does not take short-circuit evaluation of logic expressions. Thus it is WRONG to
        103     1      ! combine the evaluation of PRESENT(RHOEND) and the evaluation of IS_FINITE(RHOEND) as
        104     1      ! "IF (PRESENT(RHOEND) .AND. IS_FINITE(RHOEND))". The compiler may choose to evaluate the
        105     1      ! IS_FINITE(RHOEND) even if PRESENT(RHOEND) is false!
        106     2      if (is_finite(rhoend) .and. rhoend > ZERO) then
        107     2          rhobeg_loc = max(TEN * rhoend, RHOBEG_DFT)
        108     2      else
        109     2          rhobeg_loc = RHOBEG_DFT
        110     2      end if
        111     1  else
        112     1      rhobeg_loc = RHOBEG_DFT
        113     1  end if
        114        
        115     1  if (present(rhoend)) then
        116     1      rhoend_loc = rhoend
        117     1  elseif (rhobeg_loc > 0) then
        118     1      rhoend_loc = max(EPS, min(TENTH * rhobeg_loc, RHOEND_DFT))
        119     1  else
        120     1      rhoend_loc = RHOEND_DFT
        121     1  end if
        122        
        123     1  if (present(ftarget)) then
        124     1      ftarget_loc = ftarget
        125     1  else
        126     1      ftarget_loc = FTARGET_DFT
        127     1  end if
        128        
        129     1  if (present(maxfun)) then
        130     1      maxfun_loc = maxfun
        131     1  else
        132     1      maxfun_loc = MAXFUN_DIM_DFT * n
        133     1  end if
        134        
        135     1  if (present(iprint)) then
        136     1      iprint_loc = iprint
        137     1  else
        138     1      iprint_loc = IPRINT_DFT
        139     1  end if
        140        
        141     1  if (present(eta1)) then
        142     1      eta1_loc = eta1
        143     1  elseif (present(eta2)) then
        144     2      if (eta2 > ZERO .and. eta2 < ONE) then
        145     2          eta1_loc = max(EPS, eta2 / 7.0_RP)
        146     2      end if
        147     1  else
        148     1      eta1_loc = TENTH
        149     1  end if
        150        
        151     1  if (present(eta2)) then
        152     1      eta2_loc = eta2
        153     1  elseif (eta1_loc > ZERO .and. eta1_loc < ONE) then
        154     1      eta2_loc = (eta1_loc + TWO) / 3.0_RP
        155     1  else
        156     1      eta2_loc = 0.7_RP
        157     1  end if
        158        
        159     1  if (present(gamma1)) then
        160     1      gamma1_loc = gamma1
        161     1  else
        162     1      gamma1_loc = HALF
        163     1  end if
        164        
        165     1  if (present(gamma2)) then
        166     1      gamma2_loc = gamma2
        167     1  else
        168     1      gamma2_loc = TWO
        169     1  end if
        170        
        171     1  if (present(maxhist)) then
        172     1      maxhist_loc = maxhist
        173     1  else
        174     1      maxhist_loc = maxval([maxfun_loc, 1_IK + (n + 1_IK) * (n + 2_IK) / 2_IK, MAXFUN_DIM_DFT * n])
        175     1  end if
        176        
        177        ! Preprocess the inputs in case some of them are invalid.
        178        call preproc(solver, n, iprint_loc, maxfun_loc, maxhist_loc, ftarget_loc, rhobeg_loc, rhoend_loc, &
        179            & eta1=eta1_loc, eta2=eta2_loc, gamma1=gamma1_loc, gamma2=gamma2_loc)
        180        
        181        ! Further revise MAXHIST_LOC according to MAXMEMORY, and allocate memory for the history.
        182        ! In MATLAB/Python/Julia/R implementation, we should simply set MAXHIST = MAXFUN and initialize
        183        ! FHIST = NaN(1, MAXFUN), XHIST = NaN(N, MAXFUN) if they are requested; replace MAXFUN with 0 for
        184        ! the history that is not requested.
        185        call prehist(maxhist_loc, n, present(xhist), xhist_loc, present(fhist), fhist_loc)
        186        
        187        
        188        !--------------------------------------------------------------------------------------------------!
        189        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        190        ! Working space
        191        call safealloc(w, int(n**4 + 8 * n**3 + 23 * n**2 + 42 * n + max(2 * n**2 + 4, 18 * n) / 4, IK))
        192        npt = (n * n + 3 * n + 2) / 2
        193        ixb = 1
        194        ixo = ixb + n
        195        ixn = ixo + n
        196        ixp = ixn + n
        197        ipq = ixp + n * npt
        198        ipl = ipq + npt - 1
        199        ih = ipl + (npt - 1) * npt
        200        ig = ih + n * n
        201        id = ig + n
        202        ivl = ih
        203        iw = id + n
        204        call uobyqb(calfun, n, x, rhobeg_loc, rhoend_loc, iprint_loc, maxfun_loc, npt, w(ixb), w(ixo), &
        205             &  w(ixn), w(ixp), w(ipq), w(ipl), w(ih), w(ig), w(id), w(ivl), w(iw), f, &
        206             &  info_loc, ftarget_loc, &
        207             &  nf_loc, xhist_loc, int(size(xhist_loc, 2), IK), fhist_loc, int(size(fhist_loc), IK))
        208        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        209        !--------------------------------------------------------------------------------------------------!
        210        
        211        
        212        
        213        ! Write the outputs.
        214        
        215     1  if (present(nf)) then
        216     1      nf = nf_loc
        217     1  end if
        218        
        219     1  if (present(info)) then
        220     1      info = info_loc
        221     1  end if
        222        
        223        ! Copy XHIST_LOC to XHIST if needed.
        224     1  if (present(xhist)) then
        225     1      nhist = min(nf_loc, int(size(xhist_loc, 2), IK))
        226     1      !----------------------------------------------------!
        227     1      call safealloc(xhist, n, nhist)  ! Removable in F2003.
        228     1      !----------------------------------------------------!
        229     1      xhist = xhist_loc(:, 1:nhist)
        230     1      ! N.B.:
        231     1      ! 0. Allocate XHIST as long as it is present, even if the size is 0; otherwise, it will be
        232     1      ! illegal to enquire XHIST after exit.
        233     1      ! 1. Even though Fortran 2003 supports automatic (re)allocation of allocatable arrays upon
        234     1      ! intrinsic assignment, we keep the line of SAFEALLOC, because some very new compilers (Absoft
        235     1      ! Fortran 21.0) are still not standard-compliant in this respect.
        236     1      ! 2. NF may not be present. Hence we should NOT use NF but NF_LOC.
        237     1      ! 3. When SIZE(XHIST_LOC, 2) > NF_LOC, which is the normal case in practice, XHIST_LOC contains
        238     1      ! GARBAGE in XHIST_LOC(:, NF_LOC + 1 : END). Therefore, we MUST cap XHIST at NF_LOC so that
        239     1      ! XHIST cointains only valid history. For this reason, there is no way to avoid allocating
        240     1      ! two copies of memory for XHIST unless we declare it to be a POINTER instead of ALLOCATABLE.
        241     1  end if
        242        ! F2003 automatically deallocate local ALLOCATABLE variables at exit, yet we prefer to deallocate
        243        ! them immediately when they finish their jobs.
        244        deallocate (xhist_loc)
        245        
        246        ! Copy FHIST_LOC to FHIST if needed.
        247     1  if (present(fhist)) then
        248     1      nhist = min(nf_loc, int(size(fhist_loc), IK))
        249     1      !--------------------------------------------------!
        250     1      call safealloc(fhist, nhist)  ! Removable in F2003.
        251     1      !--------------------------------------------------!
        252     1      fhist = fhist_loc(1:nhist)  ! The same as XHIST, we must cap FHIST at NF_LOC.
        253     1  end if
        254        deallocate (fhist_loc)
        255        
        256        ! If MAXFHIST_IN >= NF_LOC > MAXFHIST_LOC, warn that not all history is recorded.
        257     1  if ((present(xhist) .or. present(fhist)) .and. maxhist_loc < nf_loc) then
        258     1      write (wmsg, ifmt) maxhist_loc
        259     1      call warning(solver, 'Only the history of the last '//trim(wmsg)//' iteration(s) is recoreded')
        260     1  end if
        261        
        262        ! Postconditions
        263     1  if (DEBUGGING) then
        264     1      call assert(nf_loc <= maxfun_loc, 'NF <= MAXFUN', srname)
        265     1      call assert(size(x) == n .and. .not. any(is_nan(x)), 'SIZE(X) == N, X does not contain NaN', srname)
        266     1      nhist = min(nf_loc, maxhist_loc)
        267     2      if (present(xhist)) then
        268     2          call assert(size(xhist, 1) == n .and. size(xhist, 2) == nhist, 'SIZE(XHIST) == [N, NHIST]', srname)
        269     2          call assert(.not. any(is_nan(xhist)), 'XHIST does not contain NaN', srname)
        270     2      end if
        271     2      if (present(fhist)) then
        272     2          call assert(size(fhist) == nhist, 'SIZE(FHIST) == NHIST', srname)
        273     2          call assert(.not. any(fhist < f), 'F is the smallest in FHIST', srname)
        274     2      end if
        275     1  end if
        276        
        277        end subroutine uobyqa
        278        
        279        
        280        end module uobyqa_mod

 Diagnostic messages: program name(uobyqa_mod)
  Module subprogram name(uobyqa)
   1333-S: "uobyqa.f90", line 21, column 4: Name expected.
   1333-S: "uobyqa.f90", line 22, column 4: Name expected.
   1333-S: "uobyqa.f90", line 23, column 4: Name expected.
   1333-S: "uobyqa.f90", line 24, column 4: Name expected.
   1333-S: "uobyqa.f90", line 25, column 4: Name expected.
   1333-S: "uobyqa.f90", line 26, column 4: Name expected.
   1333-S: "uobyqa.f90", line 27, column 4: Name expected.
   1333-S: "uobyqa.f90", line 28, column 4: Name expected.
   1333-S: "uobyqa.f90", line 29, column 4: Name expected.
   1333-S: "uobyqa.f90", line 30, column 4: Name expected.
   1333-S: "uobyqa.f90", line 31, column 4: Name expected.
   1302-S: "uobyqa.f90", line 39: Not a valid Fortran statement.
   1185-S: "uobyqa.f90", line 41: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "uobyqa.f90", line 41, column 6: Type specification or length specification invalid.
   1185-S: "uobyqa.f90", line 42: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "uobyqa.f90", line 42, column 6: Type specification or length specification invalid.
   1185-S: "uobyqa.f90", line 43: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "uobyqa.f90", line 43, column 9: Type specification or length specification invalid.
   1185-S: "uobyqa.f90", line 44: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "uobyqa.f90", line 44, column 6: Type specification or length specification invalid.
   1185-S: "uobyqa.f90", line 45: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "uobyqa.f90", line 45, column 6: Type specification or length specification invalid.
   1185-S: "uobyqa.f90", line 46: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "uobyqa.f90", line 46, column 6: Type specification or length specification invalid.
   1185-S: "uobyqa.f90", line 47: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "uobyqa.f90", line 47, column 9: Type specification or length specification invalid.
   1185-S: "uobyqa.f90", line 48: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "uobyqa.f90", line 48, column 9: Type specification or length specification invalid.
   1185-S: "uobyqa.f90", line 49: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "uobyqa.f90", line 49, column 6: Type specification or length specification invalid.
   1185-S: "uobyqa.f90", line 50: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "uobyqa.f90", line 50, column 6: Type specification or length specification invalid.
   1185-S: "uobyqa.f90", line 51: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "uobyqa.f90", line 51, column 6: Type specification or length specification invalid.
   1185-S: "uobyqa.f90", line 52: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "uobyqa.f90", line 52, column 6: Type specification or length specification invalid.
   1185-S: "uobyqa.f90", line 53: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "uobyqa.f90", line 53, column 6: Type specification or length specification invalid.
   1185-S: "uobyqa.f90", line 54: In an initialization or specification expression, 'RP' must be a named constant.
   1326-S: "uobyqa.f90", line 54, column 6: Type specification or length specification invalid.
   1185-S: "uobyqa.f90", line 55: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "uobyqa.f90", line 55, column 9: Type specification or length specification invalid.
   1185-S: "uobyqa.f90", line 56: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "uobyqa.f90", line 56, column 9: Type specification or length specification invalid.
   1185-S: "uobyqa.f90", line 63: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "uobyqa.f90", line 63, column 9: Type specification or length specification invalid.
   1185-S: "uobyqa.f90", line 64: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "uobyqa.f90", line 64, column 9: Type specification or length specification invalid.
   1185-S: "uobyqa.f90", line 65: In an initialization or specification expression, 'IK' must be a named constant.
   1326-S: "uobyqa.f90", line 65, column 9: Type specification or length specification invalid.

 Procedure information
   Lines      : 280
   Statements : 176

 Total information
   Procedures       : 1
   Total lines      : 280
   Total statements : 176

